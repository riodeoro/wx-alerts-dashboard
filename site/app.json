[{"name":"app.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# app.R\n\n# ---------- Library Imports ----------\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(plotly)\nlibrary(bslib)\nlibrary(jsonlite)\nlibrary(DT)\nlibrary(zoo)\nlibrary(viridis)\nlibrary(ggplot2)\nlibrary(httr)\nlibrary(xml2)\nlibrary(future)\nlibrary(furrr)\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringdist) # Added for metadata update functions\nlibrary(readr)      # For read_csv\n\n# ---------- API Configuration ----------\nBASE_URL <- \"el-086-api.elements360.aem.eco/aem/DataAPI\"\nSYSTEM_KEY <- \"6af158e4-53d9-4747-ad67-71197f689e1f\"\n\n# ---------- Generic Caching Helper ----------\n# Function to manage cached data with expiration\nis_cache_valid <- function(cache_timestamp, max_age_minutes = 30) {\n  if (is.null(cache_timestamp)) return(FALSE)\n  \n  current_time <- Sys.time()\n  if (difftime(current_time, cache_timestamp, units = \"mins\") < max_age_minutes) {\n    return(TRUE)\n  }\n  return(FALSE)\n}\n\n# ---------- Update metadata from API (in-memory version) ----------\nupdate_metadata_from_api <- function(api_url,\n                                   original_metadata = NULL,\n                                   coord_tolerance = 1,\n                                   name_similarity_threshold = 0.8) {\n  \n  tryCatch({\n    # Fetch XML from API\n    message(\"Fetching data from API...\")\n    response <- GET(api_url)\n    \n    if (status_code(response) != 200) {\n      stop(sprintf(\"API request failed with status code: %d\", status_code(response)))\n    }\n    \n    xml_string <- rawToChar(response$content)\n    \n    # Parse XML string directly into a dataframe\n    xml_doc <- read_xml(xml_string)\n    rows <- xml_find_all(xml_doc, \"//row\")\n    \n    message(sprintf(\"Retrieved %d records from API\", length(rows)))\n    \n    # Convert XML to dataframe directly\n    site_data <- map_dfr(rows, function(row) {\n      elements <- xml_children(row)\n      setNames(\n        as.list(xml_text(elements)),\n        xml_name(elements)\n      )\n    }) %>%\n      # Select only the columns we need for matching and updating\n      select(location, latitude_dec, longitude_dec, or_site_id, site_id, client_id, system_id)\n    \n    # Use provided metadata or create minimal structure if NULL\n    metadata <- original_metadata\n    if (is.null(metadata)) {\n      metadata <- data.frame(\n        STATION = character(),\n        LATITUDE = numeric(),\n        LONGITUDE = numeric(),\n        FIRE_CENTRE = character(),\n        FIRE_ZONE = character(),\n        ELEVATION = numeric(),\n        stringsAsFactors = FALSE\n      )\n    }\n    \n    # Standardize station names for comparison\n    standardize_name <- function(name) {\n      name %>%\n        toupper() %>%\n        gsub(\"[[:punct:]]\", \"\", .) %>%\n        gsub(\"\\\\s+\", \"\", .) %>%\n        gsub(\"STATION\", \"\", .) %>%\n        gsub(\"STN\", \"\", .)\n    }\n    \n    # Create temporary working copies with standardized names\n    site_data_temp <- site_data %>%\n      mutate(\n        latitude_dec = as.numeric(latitude_dec),\n        longitude_dec = as.numeric(longitude_dec),\n        location_std = standardize_name(location)\n      )\n    \n    metadata_temp <- metadata %>%\n      mutate(\n        LATITUDE = as.numeric(LATITUDE),\n        LONGITUDE = as.numeric(LONGITUDE),\n        STATION_std = standardize_name(STATION)\n      )\n    \n    # Calculate name similarity\n    calculate_name_similarity <- function(name1, name2) {\n      if (is.na(name1) || is.na(name2)) return(0)\n      exact_match <- as.numeric(name1 == name2)\n      levenshtein_sim <- 1 - stringdist(name1, name2, method = \"lv\") / max(nchar(name1), nchar(name2))\n      return(max(exact_match, levenshtein_sim))\n    }\n    \n    # Find matches using both coordinates and names\n    find_matches <- function(lat1, lon1, station_name, site_data_temp, coord_tolerance, name_threshold) {\n      coord_matches <- site_data_temp[abs(site_data_temp$latitude_dec - lat1) <= coord_tolerance & \n                                    abs(site_data_temp$longitude_dec - lon1) <= coord_tolerance, ]\n      \n      if (nrow(coord_matches) == 0) return(NULL)\n      \n      coord_matches$name_similarity <- sapply(coord_matches$location_std, \n                                            function(x) calculate_name_similarity(x, station_name))\n      \n      # Find best match regardless of threshold for reporting\n      best_match <- coord_matches[which.max(coord_matches$name_similarity), ]\n      best_match$meets_threshold <- best_match$name_similarity >= name_threshold\n      \n      return(best_match)\n    }\n    \n    # Track matching details for reporting\n    match_details <- data.frame(\n      row = integer(),\n      coord_match = logical(),\n      name_match = logical(),\n      original_station = character(),\n      matched_location = character(),\n      similarity_score = numeric(),\n      was_updated = logical()\n    )\n    \n    # Add new columns to metadata if they don't exist\n    if (!\"or_site_id\" %in% names(metadata)) metadata$or_site_id <- NA\n    if (!\"site_id\" %in% names(metadata)) metadata$site_id <- NA\n    if (!\"client_id\" %in% names(metadata)) metadata$client_id <- NA\n    if (!\"system_id\" %in% names(metadata)) metadata$system_id <- NA\n    \n    # Apply matching\n    for (i in 1:nrow(metadata_temp)) {\n      match <- find_matches(metadata_temp$LATITUDE[i], \n                          metadata_temp$LONGITUDE[i],\n                          metadata_temp$STATION_std[i],\n                          site_data_temp, \n                          coord_tolerance,\n                          name_similarity_threshold)\n      \n      if (!is.null(match)) {\n        was_updated <- FALSE\n        if (match$meets_threshold) {\n          metadata$or_site_id[i] <- match$or_site_id\n          metadata$site_id[i] <- match$site_id\n          metadata$client_id[i] <- match$client_id\n          metadata$system_id[i] <- match$system_id\n          was_updated <- TRUE\n        }\n        \n        match_details <- rbind(match_details, data.frame(\n          row = i,\n          coord_match = TRUE,\n          name_match = match$name_similarity >= name_similarity_threshold,\n          original_station = metadata$STATION[i],\n          matched_location = match$location,\n          similarity_score = match$name_similarity,\n          was_updated = was_updated\n        ))\n      }\n    }\n    \n    # Generate report summary info\n    total_records <- nrow(metadata)\n    total_matches <- sum(match_details$was_updated)\n    low_similarity_matches <- sum(match_details$coord_match & !match_details$name_match)\n    \n    # Create a report attribute to attach to the result\n    attr(metadata, \"update_report\") <- list(\n      total_records = total_records,\n      total_matches = total_matches,\n      low_similarity_matches = low_similarity_matches,\n      match_details = match_details,\n      coord_tolerance = coord_tolerance,\n      name_similarity_threshold = name_similarity_threshold\n    )\n    \n    message(sprintf(\"Update complete:\n    Total records processed: %d\n    Records updated: %d\n    Coordinate matches found: %d\n    - Strong matches (updated): %d\n    - Low similarity matches (not updated): %d\n    - Coordinate tolerance: %f degrees\n    - Name similarity threshold: %f\", \n    total_records, total_matches, nrow(match_details), total_matches, \n    low_similarity_matches, coord_tolerance, name_similarity_threshold))\n    \n    if (low_similarity_matches > 0) {\n      message(\"\\nCoordinate matches with low name similarity (these were NOT updated):\")\n      low_similarity_matches <- match_details[!match_details$name_match, ]\n      print(low_similarity_matches[, c(\"original_station\", \"matched_location\", \"similarity_score\")])\n    }\n    \n    # Return the updated metadata\n    return(metadata)\n    \n  }, error = function(e) {\n    message(sprintf(\"Error during processing: %s\", e$message))\n    return(NULL)\n  })\n}\n\n# ---------- Function to fetch data with caching ----------\nfetch_with_cache <- function(fetch_function, cache_container, cache_key, timestamp_key, force_refresh = FALSE, max_age_minutes = 30, ...) {\n  # Check if we have valid cached data\n  if (!force_refresh && \n      !is.null(cache_container[[cache_key]]) && \n      is_cache_valid(cache_container[[timestamp_key]], max_age_minutes)) {\n    \n    message(sprintf(\"Using cached %s (last updated %s)\", \n                   cache_key, \n                   format(cache_container[[timestamp_key]], \"%H:%M:%S\")))\n    \n    return(cache_container[[cache_key]])\n  }\n  \n  # No valid cache, fetch fresh data\n  result <- fetch_function(...)\n  \n  if (!is.null(result)) {\n    # Update cache\n    cache_container[[cache_key]] <- result\n    cache_container[[timestamp_key]] <- Sys.time()\n  }\n  \n  return(result)\n}\n\n# ---------- Function to fetch raw metadata from API ----------\nfetch_metadata_from_api <- function() {\n  # Define the API endpoint\n  api_url <- \"el-086-api.elements360.aem.eco/aem/DataAPI?method=GetSiteMetaData&system_key=6af158e4-53d9-4747-ad67-71197f689e1f&format=xml\"\n  \n  tryCatch({\n    # Fetch data directly from API\n    message(\"Fetching station metadata from Elements 360 API...\")\n    response <- GET(api_url)\n    \n    if (status_code(response) != 200) {\n      stop(sprintf(\"API request failed with status code: %d\", status_code(response)))\n    }\n    \n    xml_string <- rawToChar(response$content)\n    \n    # Parse XML string directly into a dataframe\n    xml_doc <- read_xml(xml_string)\n    rows <- xml_find_all(xml_doc, \"//row\")\n    \n    message(sprintf(\"Retrieved %d records from API\", length(rows)))\n    \n    # Convert XML to dataframe\n    site_data <- map_dfr(rows, function(row) {\n      elements <- xml_children(row)\n      setNames(\n        as.list(xml_text(elements)),\n        xml_name(elements)\n      )\n    })\n    \n    # Create a properly structured metadata dataframe\n    metadata <- site_data %>%\n      select(\n        site_id,\n        location,\n        latitude_dec,\n        longitude_dec,\n        or_site_id,\n        client_id,\n        system_id\n      ) %>%\n      mutate(\n        STATION = location,\n        LATITUDE = as.numeric(latitude_dec),\n        LONGITUDE = as.numeric(longitude_dec),\n        # Assign default values for required fields\n        FIRE_CENTRE = \"Unknown\",\n        FIRE_ZONE = \"Unknown\",\n        ELEVATION = as.numeric(NA)\n      )\n    \n    # Return complete metadata\n    return(metadata)\n    \n  }, error = function(e) {\n    message(sprintf(\"Error fetching metadata: %s\", e$message))\n    return(NULL)\n  })\n}\n\n# ---------- Load Static STATION_METADATA from included file ----------\n# This function loads the embedded metadata file that ships with the app\nload_static_metadata <- function() {\n  tryCatch({\n    # Try to read from a static file included with the app\n    static_metadata_path <- \"data/static_data/STATION_METADATA.csv\"\n    if (file.exists(static_metadata_path)) {\n      metadata <- readr::read_csv(static_metadata_path, show_col_types = FALSE)\n      message(\"Loaded static metadata from embedded file\")\n      return(metadata)\n    } else {\n      message(\"Static metadata file not found, will use API data only\")\n      return(NULL)\n    }\n  }, error = function(e) {\n    message(sprintf(\"Error loading static metadata: %s\", e$message))\n    return(NULL)\n  })\n}\n\n# ---------- Merge metadata sources with sophisticated matching ----------\nmerge_metadata_sources <- function(static_metadata, api_metadata) {\n  if (is.null(static_metadata) && is.null(api_metadata)) {\n    message(\"No metadata sources available!\")\n    return(NULL)\n  }\n  \n  if (is.null(static_metadata)) {\n    message(\"Using API metadata only\")\n    return(api_metadata)\n  }\n  \n  if (is.null(api_metadata)) {\n    message(\"Using static metadata only\")\n    return(static_metadata)\n  }\n  \n  # We have both sources - use the sophisticated matching algorithm\n  # CSV is the \"gold standard\" - we only want to update site IDs\n  message(\"Merging metadata sources using coordinate and name matching...\")\n  \n  # Use update_metadata_from_api with the actual API URL\n  # This preserves the station names and metadata from static_metadata\n  # but adds the API site IDs where coordinates match\n  api_url <- \"el-086-api.elements360.aem.eco/aem/DataAPI?method=GetSiteMetaData&system_key=6af158e4-53d9-4747-ad67-71197f689e1f&format=xml\"\n  \n  merged_metadata <- update_metadata_from_api(\n    api_url = api_url,\n    original_metadata = static_metadata,\n    coord_tolerance = 1,\n    name_similarity_threshold = 0.8\n  )\n  \n  if (is.null(merged_metadata)) {\n    message(\"Metadata merge failed, falling back to static metadata\")\n    return(static_metadata)\n  }\n  \n  # Important: We're considering CSV as the gold standard\n  # Only using API to add site_id, not adding new stations from API\n  # This ensures dropdown menus only show stations from the CSV\n  message(\"Using CSV as the gold standard - not adding API-only stations\")\n  \n  return(merged_metadata)\n}\n\nobserve_fire_centers <- function(session, station_metadata) {\n  # Extract unique fire centers from the station metadata\n  req(station_metadata())\n  \n  fire_centers <- unique(station_metadata()$FIRE_CENTRE)\n  fire_centers <- sort(fire_centers[!is.na(fire_centers)])\n  \n  # Update the fire centre select input\n  updateSelectInput(session, \"fire_centre\", \n                   choices = fire_centers,\n                   selected = fire_centers[1])\n}\n\n# ---------- Source Files ----------\n# Core files\nsource(\"data/ui_definition2.R\")\n\naddResourcePath(\"www\", \"www\")\n\n# Module function files\nsource(\"data/r/temperature_module/temperature_functions.R\")\nsource(\"data/r/rh_module/rh_functions.R\")\nsource(\"data/r/wind_module/wind_functions.R\")\nsource(\"data/r/power_module/power_functions.R\")\nsource(\"data/r/crmp_module/crmp_functions.R\")\nsource(\"data/r/db_module/db_functions.R\")\nsource(\"data/r/precipitation_module/precipitation_functions.R\")\n\n# Module chart files\nsource(\"data/r/wind_module/wind_charts.R\")\nsource(\"data/r/temperature_module/temperature_charts.R\")\nsource(\"data/r/rh_module/rh_charts.R\")\nsource(\"data/r/crmp_module/crmp_charts.R\")\nsource(\"data/r/precipitation_module/precipitation_charts.R\")\nsource(\"data/r/db_module/db_charts.R\")\nsource(\"data/r/power_module/power_charts.R\")\n\n# Module output files\nsource(\"data/r/db_module/db_output.R\")\nsource(\"data/r/wind_module/wind_output.R\")\nsource(\"data/r/precipitation_module/precipitation_output.R\")\nsource(\"data/r/temperature_module/temperature_output.R\")\nsource(\"data/r/crmp_module/crmp_output.R\")\nsource(\"data/r/rh_module/rh_output.R\")\nsource(\"data/r/power_module/power_output.R\")\n\n# ---------- API Data Fetching Functions ----------\n\n#' Fetch sensor metadata from the API with caching\n#' \n#' @param force_refresh Boolean indicating whether to force a refresh\n#' @return data.frame containing sensor metadata or NULL if error\nfetch_sensor_metadata <- function(force_refresh = FALSE) {\n  url <- paste0(\n    BASE_URL,\n    \"?method=GetSensorMetaData\",\n    \"&system_key=\", SYSTEM_KEY,\n    \"&format=xml\"\n  )\n  \n  tryCatch({\n    response <- GET(url)\n    if (http_status(response)$category == \"Success\") {\n      parsed_xml <- read_xml(rawToChar(response$content))\n      rows <- xml_find_all(parsed_xml, \"//row\")\n      \n      # Pre-allocate vectors for better performance\n      n_rows <- length(rows)\n      site_ids <- character(n_rows)\n      sensor_ids <- character(n_rows)\n      descriptions <- character(n_rows)\n      units <- character(n_rows)\n      active_flags <- logical(n_rows)\n      \n      # Fill vectors in a single pass\n      for (i in seq_len(n_rows)) {\n        row <- rows[[i]]\n        site_ids[i] <- xml_text(xml_find_first(row, \".//site_id\"))\n        sensor_ids[i] <- xml_text(xml_find_first(row, \".//sensor_id\"))\n        descriptions[i] <- xml_text(xml_find_first(row, \".//description\"))\n        units[i] <- xml_text(xml_find_first(row, \".//units\"))\n        active_flags[i] <- as.logical(as.numeric(xml_text(xml_find_first(row, \".//active\"))))\n      }\n      \n      # Create data frame in one operation\n      sensor_data <- data.frame(\n        site_id = site_ids,\n        sensor_id = sensor_ids,\n        description = descriptions,\n        units = units,\n        active = active_flags,\n        stringsAsFactors = FALSE\n      )\n      \n      return(sensor_data)\n    }\n    return(NULL)\n  }, error = function(e) {\n    warning(paste(\"Error fetching sensor metadata:\", e$message))\n    return(NULL)\n  })\n}\n\n#' Construct batch API URL for data retrieval\n#' \n#' @param start_time Start time in ISO format\n#' @param end_time End time in ISO format\n#' @return Character string containing the API URL\nconstruct_batch_api_url <- function(start_time, end_time) {\n  paste0(\n    BASE_URL,\n    \"?method=GetSensorData\",\n    \"&system_key=\", SYSTEM_KEY,\n    \"&data_start=\", start_time,\n    \"&data_end=\", end_time,\n    \"&timezone=PST\"\n  )\n}\n\n#' Generate time chunks for parallel processing\n#' \n#' @param start_time Start time as datetime\n#' @param end_time End time as datetime\n#' @return List of time chunks\ngenerate_time_chunks <- function(start_time, end_time) {\n  # Convert inputs to POSIXct if they aren't already\n  start_time <- as.POSIXct(start_time)\n  end_time <- as.POSIXct(end_time)\n  \n  # Generate sequence of dates at once\n  dates <- seq(start_time, end_time, by = \"24 hours\")\n  \n  # Add end time if it's not included\n  if (end_time > dates[length(dates)]) {\n    dates <- c(dates, end_time)\n  }\n  \n  # Format all dates at once using vectorized operations\n  dates_formatted <- format(dates, \"%Y-%m-%d%%20%H:%M\")\n  \n  # Create chunks with proper formatting - pre-allocate list\n  n_chunks <- length(dates) - 1\n  chunks <- vector(\"list\", n_chunks)\n  \n  for (i in seq_len(n_chunks)) {\n    chunks[[i]] <- list(\n      start = dates_formatted[i],\n      end = dates_formatted[i + 1]\n    )\n  }\n  \n  return(chunks)\n}\n\n#' Parse weather data from XML response with optimized type conversions\n#' \n#' @param xml_content XML content from API response\n#' @return data.frame containing parsed weather data or NULL if error\nparse_weather_data <- function(xml_content) {\n  if (is.null(xml_content) || nchar(xml_content) == 0) {\n    warning(\"Empty or null XML content\")\n    return(NULL)\n  }\n  \n  tryCatch({\n    parsed_xml <- read_xml(xml_content)\n    rows <- xml_find_all(parsed_xml, \"//row\")\n    \n    if (length(rows) == 0) {\n      warning(\"No rows found in XML\")\n      return(NULL)\n    }\n    \n    # Extract all values at once using xpath and vectorized operations\n    site_ids <- xml_text(xml_find_all(parsed_xml, \"//row/site_id\"))\n    sensor_ids <- xml_text(xml_find_all(parsed_xml, \"//row/sensor_id\"))\n    receive_times <- xml_text(xml_find_all(parsed_xml, \"//row/receive_time\"))\n    data_times <- xml_text(xml_find_all(parsed_xml, \"//row/data_time\"))\n    data_values_str <- xml_text(xml_find_all(parsed_xml, \"//row/data_value\"))\n    data_qualities <- xml_text(xml_find_all(parsed_xml, \"//row/data_quality\"))\n    units <- xml_text(xml_find_all(parsed_xml, \"//row/units\"))\n    \n    # Convert data values to numeric in one operation\n    data_values <- suppressWarnings(as.numeric(data_values_str))\n    \n    # Find valid rows (where data_value is a number)\n    valid_rows <- !is.na(data_values)\n    \n    if (!any(valid_rows)) {\n      warning(\"No valid numeric values found\")\n      return(NULL)\n    }\n    \n    # Create data frame with only valid rows\n    weather_data <- data.frame(\n      site_id = site_ids[valid_rows],\n      sensor_id = sensor_ids[valid_rows],\n      receive_time = receive_times[valid_rows],\n      data_time = data_times[valid_rows],\n      data_value = data_values[valid_rows],\n      data_quality = data_qualities[valid_rows],\n      units = units[valid_rows],\n      stringsAsFactors = FALSE\n    )\n    \n    # Convert datetime columns only once\n    # Use lubridate for faster parsing\n    weather_data$receive_time <- ymd_hms(weather_data$receive_time)\n    weather_data$data_time <- ymd_hms(weather_data$data_time)\n    \n    return(weather_data)\n  }, error = function(e) {\n    warning(sprintf(\"Error in parse_weather_data: %s\", e$message))\n    return(NULL)\n  })\n}\n\n#' Fetch data for multiple stations in parallel with optimized processing\n#' \n#' @param time_chunks List of time chunk pairs (start and end times)\n#' @return data.frame containing combined weather data or NULL if error\nfetch_batch_chunk_data_parallel <- function(time_chunks) {\n  # Set up parallel processing\n  plan(multisession, workers = min(length(time_chunks), 12))\n  \n  # Define safe function for fetching\n  safe_fetch <- safely(function(chunk) {\n    tryCatch({\n      url <- construct_batch_api_url(chunk$start, chunk$end)\n      response <- GET(url)\n      \n      if (http_status(response)$category == \"Success\") {\n        content <- rawToChar(response$content)\n        if (nchar(content) == 0) {\n          warning(\"Empty response content\")\n          return(NULL)\n        }\n        \n        parsed_data <- parse_weather_data(content)\n        return(parsed_data)\n      } else {\n        warning(sprintf(\"HTTP request failed: %s\", http_status(response)$message))\n        return(NULL)\n      }\n    }, error = function(e) {\n      warning(sprintf(\"Error in chunk processing: %s\", e$message))\n      return(NULL)\n    })\n  })\n  \n  # Process chunks in parallel\n  results <- future_map(time_chunks, safe_fetch, .progress = FALSE)\n  \n  # Extract valid results\n  valid_results <- list()\n  for (i in seq_along(results)) {\n    result <- results[[i]]\n    if (!is.null(result$result) && is.data.frame(result$result) && nrow(result$result) > 0) {\n      valid_results[[length(valid_results) + 1]] <- result$result\n    }\n  }\n  \n  if (length(valid_results) == 0) {\n    warning(\"No valid results found\")\n    return(NULL)\n  }\n  \n  # Use dplyr::bind_rows for more efficient binding\n  tryCatch({\n    combined_data <- bind_rows(valid_results)\n    return(combined_data)\n  }, error = function(e) {\n    warning(sprintf(\"Error combining results: %s\", e$message))\n    return(NULL)\n  })\n}\n\n#' Fetch weather data using API with optimized data conversion\n#'\n#' @param fire_centre Fire centre to fetch data for\n#' @param stations List of stations to fetch\n#' @param time_range List containing start and end times\n#' @return List of data frames with station data\nfetch_weather_data_api <- function(fire_centre, stations, time_range) {\n  # Generate time chunks for API calls\n  time_chunks <- generate_time_chunks(time_range$start, time_range$end)\n  \n  # Fetch data in parallel\n  all_data <- fetch_batch_chunk_data_parallel(time_chunks)\n  \n  if (is.null(all_data) || nrow(all_data) == 0) {\n    warning(\"No data retrieved from API\")\n    return(list())\n  }\n  \n  # Filter for requested stations - use semi_join for efficiency\n  stations_subset <- stations %>% select(site_id)\n  data_filtered <- all_data %>% \n    semi_join(stations_subset, by = \"site_id\")\n  \n  if (nrow(data_filtered) == 0) {\n    warning(\"No data available for the selected stations\")\n    return(list())\n  }\n  \n  # Join with station metadata - use left_join once\n  relevant_station_cols <- stations %>%\n    select(site_id, STATION, FIRE_CENTRE, FIRE_ZONE, LATITUDE, LONGITUDE, ELEVATION)\n  \n  data_with_station <- data_filtered %>%\n    left_join(relevant_station_cols, by = \"site_id\")\n  \n  # Add DateTimeNum column as formatted string (required format for app compatibility)\n  data_with_datetime <- data_with_station %>%\n    mutate(DateTimeNum = format(data_time, \"%Y-%b-%d %H:%M:%S\"))\n  \n  # Handle duplicates more efficiently by aggregating before pivot\n  data_aggregated <- data_with_datetime %>%\n    group_by(site_id, STATION, FIRE_CENTRE, FIRE_ZONE, LATITUDE, LONGITUDE, \n            ELEVATION, DateTimeNum, sensor_id) %>%\n    summarize(data_value = mean(data_value, na.rm = TRUE), .groups = \"drop\")\n  \n  # Now pivot without needing the aggregation function\n  transformed_data <- data_aggregated %>%\n    pivot_wider(\n      id_cols = c(site_id, STATION, FIRE_CENTRE, FIRE_ZONE, LATITUDE, LONGITUDE, \n                 ELEVATION, DateTimeNum),\n      names_from = sensor_id,\n      values_from = data_value\n    ) %>%\n    arrange(desc(DateTimeNum)) %>%\n    group_by(STATION) %>%\n    group_split()\n  \n  # Convert list to named list and ensure numeric columns\n  if (length(transformed_data) > 0) {\n    # Get column types once\n    numeric_cols <- setdiff(names(transformed_data[[1]]), \n                           c(\"site_id\", \"STATION\", \"FIRE_CENTRE\", \"FIRE_ZONE\", \"DateTimeNum\"))\n    \n    # Convert each dataset with vectorized operations\n    transformed_data <- lapply(transformed_data, function(df) {\n      # Convert all numeric columns at once using across()\n      df <- df %>%\n        mutate(across(all_of(numeric_cols), as.numeric))\n      \n      # Convert to data.frame for compatibility\n      as.data.frame(df, stringsAsFactors = FALSE)\n    })\n    \n    # Name the list entries without the dbo. prefix\n    station_names <- map_chr(transformed_data, ~unique(.x$STATION))\n    names(transformed_data) <- station_names\n    \n    return(transformed_data)\n  }\n  \n  return(list())\n}\n\n# ---------- CRMP Module Helper Functions ----------\n#' Scan for active CRMP sensors in the station data\n#'\n#' @param WX_stations List of weather station data\n#' @return List of active CRMP sensors by station\nscan_active_crmp_sensors <- function(WX_stations) {\n  crmp_sensors <- c(\"SDepth\", \"SD\", \"PrecipOP2\", \"PrecipOP1\", \"PrecipPC2\", \"PrecipRIT\", \"PC\", \"Pcp_raw\")\n  \n  # Initialize results list\n  active_sensors <- list()\n  \n  # Check each station\n  for (station_name in names(WX_stations)) {\n    station_data <- WX_stations[[station_name]]\n    \n    # Skip invalid data\n    if (is.null(station_data) || nrow(station_data) == 0) next\n    \n    # Find which CRMP sensors have data in this station\n    active <- character(0)\n    for (sensor in crmp_sensors) {\n      if (sensor %in% names(station_data) && any(!is.na(station_data[[sensor]]))) {\n        active <- c(active, sensor)\n      }\n    }\n    \n    # Only add stations with at least one active CRMP sensor\n    if (length(active) > 0) {\n      active_sensors[[station_name]] <- active\n    }\n  }\n  \n  return(active_sensors)\n}\n\n#' Fetch space weather alerts from NOAA\n#'\n#' @return Data frame of alerts or NULL if error\nfetch_space_weather_alerts <- function() {\n  tryCatch({\n    # Simulated response since this is meant to be a placeholder\n    alerts <- data.frame(\n      alert_time = format(Sys.time() - sample(1:72, 5) * 3600, \"%Y-%m-%d %H:%M:%S\"),\n      category = sample(c(\"Radio Blackout\", \"Solar Radiation Storm\", \"Geomagnetic Storm\"), 5, replace = TRUE),\n      level = sample(c(\"Minor\", \"Moderate\", \"Strong\", \"Severe\", \"Extreme\"), 5, replace = TRUE),\n      description = c(\n        \"R1 (Minor) Radio Blackout\",\n        \"S1 (Minor) Solar Radiation Storm\",\n        \"G2 (Moderate) Geomagnetic Storm\",\n        \"S2 (Moderate) Solar Radiation Storm\",\n        \"G1 (Minor) Geomagnetic Storm\"\n      ),\n      expected_impact = c(\n        \"Minor degradation of HF radio communication\",\n        \"Minor radiation hazard to astronauts\",\n        \"Power grid fluctuations, aurora visible at high latitudes\",\n        \"Increased radiation exposure to astronauts, minor impact on satellites\",\n        \"Minor impact on power systems, aurora visible at high latitudes\"\n      ),\n      stringsAsFactors = FALSE\n    )\n    return(alerts)\n  }, error = function(e) {\n    warning(\"Error fetching space weather alerts:\", e$message)\n    return(NULL)\n  })\n}\n\n# ---------- Server Function Definition ----------\nserver <- function(input, output, session) {\n  # Initialize reactive values\n  wx_data <- reactiveVal(NULL)\n  WX_stations <- reactiveVal(NULL)\n  station_metadata <- reactiveVal(NULL)\n  sensor_metadata <- reactiveVal(NULL)\n  active_crmp_sensors <- reactiveVal(NULL)\n  available_stations <- reactiveVal(NULL)\n  \n  # Create a cache container\n  api_cache <- reactiveValues(\n    metadata = NULL,\n    sensor_metadata = NULL,\n    last_metadata_fetch = NULL,\n    last_sensor_fetch = NULL\n  )\n  \n  # Initialize caches \n  cached_power_data <- reactiveVal(NULL)\n  cached_temp_extremes <- reactiveVal(NULL)\n  cached_missing_entries <- reactiveVal(NULL)\n  cached_rn1_outliers <- reactiveVal(NULL)\n  cached_constant_temp <- reactiveVal(NULL)\n  cached_zero_wspd <- reactiveVal(NULL)\n  cached_precip_changes <- reactiveVal(NULL)\n  cached_consecutive_rh <- reactiveVal(NULL)\n  cached_temp_trends <- reactiveVal(NULL)\n  cached_vbat_trends <- reactiveVal(NULL)\n  \n  # Load metadata on startup (in-memory approach)\n # Load metadata on startup (in-memory approach) with optimized timing\nobserve({\n  # Wait until the UI is fully rendered before fetching metadata\n  session$onFlushed(function() {\n    # Use a separate tryCatch block to avoid reactive context issues\n    tryCatch({\n      # First try to load static metadata included with the app\n      static_metadata <- load_static_metadata()\n      \n      # Then fetch metadata from API directly without using the reactive cache\n      api_metadata <- fetch_metadata_from_api()\n      \n      # Merge the two sources using sophisticated matching\n      final_metadata <- merge_metadata_sources(static_metadata, api_metadata)\n      \n      # Only after processing is complete, update the reactive cache\n      if (!is.null(final_metadata)) {\n        # Update cache manually\n        api_cache$metadata <- final_metadata\n        api_cache$last_metadata_fetch <- Sys.time()\n        \n        # Update the reactive value\n        station_metadata(final_metadata)\n        \n        # Report success to server log\n        message(sprintf(\"Metadata loaded with %d stations\", nrow(final_metadata)))\n      }\n    }, error = function(e) {\n      message(sprintf(\"Error in metadata loading: %s\", e$message))\n      # Try to use static metadata if API fails\n      static_metadata <- load_static_metadata()\n      if (!is.null(static_metadata)) {\n        station_metadata(static_metadata)\n        message(sprintf(\"Falling back to static metadata with %d stations\", nrow(static_metadata)))\n      } else {\n        # Create minimal metadata as a last resort\n        message(\"WARNING: Failed to create metadata from any source!\")\n        empty_metadata <- data.frame(\n          STATION = character(0),\n          site_id = character(0),\n          LATITUDE = numeric(0),\n          LONGITUDE = numeric(0),\n          FIRE_CENTRE = character(0),\n          FIRE_ZONE = character(0),\n          ELEVATION = numeric(0),\n          stringsAsFactors = FALSE\n        )\n        station_metadata(empty_metadata)\n      }\n    })\n  })\n})  \n   \n  # Load sensor metadata from API with caching\n  observe({\n    # Use the fetch_with_cache helper\n    sensor_meta <- fetch_with_cache(\n      fetch_function = fetch_sensor_metadata,\n      cache_container = api_cache,\n      cache_key = \"sensor_metadata\", \n      timestamp_key = \"last_sensor_fetch\"\n    )\n    \n    if (!is.null(sensor_meta)) {\n      sensor_metadata(sensor_meta)\n    }\n  })\n  \n  # Update fetch based on time selection\n  observe({\n    req(input$time_preset)\n    if (input$time_preset != \"custom\") {\n      # Convert the preset value to numeric and update num_entries\n      updateNumericInput(session, \"num_entries\",\n                        value = as.numeric(input$time_preset))\n    }\n  })\n  \n  # Update available stations when fire centre changes\n  observe({\n    req(input$fire_centre, station_metadata())\n    \n    # Get stations for the selected fire centre\n    available_stations <- station_metadata() %>%\n      filter(FIRE_CENTRE == input$fire_centre, !is.na(site_id)) %>%\n      select(STATION, site_id)\n    \n    if (input$station_selection_type == \"specific\") {\n      # Update station selection choices only when in specific selection mode\n      updateSelectizeInput(session, \"selected_stations\",\n                         choices = setNames(available_stations$site_id, available_stations$STATION))\n    }\n    \n    # Store available stations for later use\n    available_stations(available_stations)\n  })\n  \n  # Add the observer that was causing the error, but inside the server function\n observe({\n  req(station_metadata())\n  \n  # Get current selection\n  current_selection <- input$fire_centre\n  \n  # Get and sort fire centers from metadata\n  fire_centers <- unique(station_metadata()$FIRE_CENTRE)\n  fire_centers <- sort(fire_centers[!is.na(fire_centers)])\n  \n  # If no fire centers found, show a warning\n  if (length(fire_centers) == 0) {\n    showNotification(\"No fire centers found in metadata\", type = \"warning\")\n    return()\n  }\n  \n  # Determine selection to use\n  selected_center <- if(current_selection %in% fire_centers) {\n    current_selection  # Keep current selection if it exists\n  } else {\n    fire_centers[1]  # Otherwise use the first one\n  }\n  \n  # Update UI\n  updateSelectInput(session, \"fire_centre\", \n                  choices = fire_centers,\n                  selected = selected_center)\n})\n  \n  # Modify the data fetching section\n  observeEvent(input$fetch_data, {\n    req(input$fire_centre, station_metadata())\n    \n    withProgress(message = \"Fetching data...\", {\n      # Determine time range based on user selection\n      time_range <- if (input$fetch_type == \"last_n\") {\n        end_time <- Sys.time()\n        hours <- as.numeric(input$num_entries)\n        list(\n          start = end_time - hours * 3600,\n          end = end_time\n        )\n      } else if (input$fetch_type == \"by_date\") {\n        list(\n          start = as.POSIXct(paste(input$select_date, \"00:00:00\")),\n          end = as.POSIXct(paste(input$select_date, \"23:59:59\"))\n        )\n      } else if (input$fetch_type == \"date_range\") {\n        list(\n          start = as.POSIXct(paste(input$start_date, \"00:00:00\")),\n          end = as.POSIXct(paste(input$end_date, \"23:59:59\"))\n        )\n      }\n      \n      # Get stations for the selected fire centre\n      fire_centre_stations <- station_metadata() %>%\n        filter(FIRE_CENTRE == input$fire_centre, !is.na(site_id))\n      \n      # Filter stations based on user selection\n      selected_stations <- if (input$station_selection_type == \"specific\" && \n                             length(input$selected_stations) > 0) {\n        fire_centre_stations %>%\n          filter(site_id %in% input$selected_stations)\n      } else {\n        fire_centre_stations\n      }\n      \n      # Fetch weather data using API\n      stations_data <- fetch_weather_data_api(\n        input$fire_centre, \n        selected_stations, \n        time_range\n      )\n      \n      # Update reactive values\n      WX_stations(stations_data)\n      wx_data(stations_data)\n      \n      # Process and cache active CRMP sensors\n      active_sensors <- tryCatch({\n        scan_active_crmp_sensors(stations_data)\n      }, error = function(e) {\n        warning(\"Error scanning CRMP sensors:\", e$message)\n        return(list())\n      })\n      active_crmp_sensors(active_sensors)\n      \n      # Cache expensive calculations within isolate to prevent reactivity\n      isolate({\n        # Cache power data\n        power_data <- lapply(stations_data, function(station_data) {\n          if (is.null(station_data) || \n              !all(c(\"Vbat\", \"Ibat\", \"Vslr\", \"Islr\") %in% names(station_data)) ||\n              nrow(station_data) == 0) {\n            return(NULL)\n          }\n          \n          # Safely calculate statistics to avoid warnings with empty vectors\n          calculate_safe_stat <- function(data, fn, default = NA) {\n            if (length(data) > 0 && any(!is.na(data))) {\n              fn(data, na.rm = TRUE)\n            } else {\n              default\n            }\n          }\n          \n          # Safe which.min/max that handles empty vectors\n          safe_which_min <- function(data) {\n            if (length(data) > 0 && any(!is.na(data))) {\n              which.min(replace(data, is.na(data), Inf))\n            } else {\n              NA_integer_\n            }\n          }\n          \n          safe_which_max <- function(data) {\n            if (length(data) > 0 && any(!is.na(data))) {\n              which.max(replace(data, is.na(data), -Inf))\n            } else {\n              NA_integer_\n            }\n          }\n          \n          # Ensure all columns are numeric\n          for (col in c(\"Vbat\", \"Ibat\", \"Vslr\", \"Islr\")) {\n            station_data[[col]] <- as.numeric(station_data[[col]])\n          }\n          if (\"Temp\" %in% names(station_data)) {\n            station_data$Temp <- as.numeric(station_data$Temp)\n          }\n          \n          stats <- list(\n            mean_battery_voltage = calculate_safe_stat(station_data$Vbat, mean),\n            min_battery_voltage = calculate_safe_stat(station_data$Vbat, min),\n            max_battery_voltage = calculate_safe_stat(station_data$Vbat, max),\n            min_battery_voltage_time = {\n              idx <- safe_which_min(station_data$Vbat)\n              if (!is.na(idx) && idx <= length(station_data$DateTimeNum)) {\n                station_data$DateTimeNum[idx]\n              } else {\n                NA\n              }\n            },\n            max_battery_voltage_time = {\n              idx <- safe_which_max(station_data$Vbat)\n              if (!is.na(idx) && idx <= length(station_data$DateTimeNum)) {\n                station_data$DateTimeNum[idx]\n              } else {\n                NA\n              }\n            },\n            mean_battery_current = calculate_safe_stat(station_data$Ibat, mean),\n            mean_solar_voltage = calculate_safe_stat(station_data$Vslr, mean),\n            max_solar_voltage = calculate_safe_stat(station_data$Vslr, max),\n            max_solar_voltage_time = {\n              idx <- safe_which_max(station_data$Vslr)\n              if (!is.na(idx) && idx <= length(station_data$DateTimeNum)) {\n                station_data$DateTimeNum[idx]\n              } else {\n                NA\n              }\n            },\n            mean_solar_current = calculate_safe_stat(station_data$Islr, mean),\n            max_solar_current = calculate_safe_stat(station_data$Islr, max),\n            max_solar_current_time = {\n              idx <- safe_which_max(station_data$Islr)\n              if (!is.na(idx) && idx <= length(station_data$DateTimeNum)) {\n                station_data$DateTimeNum[idx]\n              } else {\n                NA\n              }\n            }\n          )\n          \n          list(data = station_data, stats = stats)\n        })\n        cached_power_data(power_data[!sapply(power_data, is.null)])\n        \n        # Cache other calculations - wrap in try to prevent errors\n        tryCatch({\n          cached_missing_entries(check_for_missing_entries(stations_data))\n        }, error = function(e) {\n          warning(\"Error caching missing entries:\", e$message)\n        })\n        \n        tryCatch({\n          cached_rn1_outliers(lapply(stations_data, identify_outliers, k = 6))\n        }, error = function(e) {\n          warning(\"Error caching RN1 outliers:\", e$message)\n        })\n        \n        tryCatch({\n          cached_constant_temp(lapply(stations_data, find_constant_temp_periods))\n        }, error = function(e) {\n          warning(\"Error caching constant temp data:\", e$message)\n        })\n        \n        tryCatch({\n          cached_zero_wspd(lapply(stations_data, find_zero_wspd_periods))\n        }, error = function(e) {\n          warning(\"Error caching zero wind speed data:\", e$message)\n        })\n        \n        tryCatch({\n          cached_consecutive_rh(check_consecutive_rh(stations_data))\n        }, error = function(e) {\n          warning(\"Error caching consecutive RH data:\", e$message)\n        })\n        \n        # Cache temperature extremes\n        tryCatch({\n          temp_extremes <- data.frame(\n            Station = character(),\n            Temp = numeric(),\n            DateTimeNum = character(),\n            stringsAsFactors = FALSE\n          )\n          for(station_name in names(stations_data)) {\n            station_data <- stations_data[[station_name]]\n            if (!is.null(station_data) && \"Temp\" %in% names(station_data) && nrow(station_data) > 0) {\n              station_trends <- data.frame(\n                Station = station_name,\n                Temp = as.numeric(station_data$Temp),\n                DateTimeNum = station_data$DateTimeNum,\n                stringsAsFactors = FALSE\n              )\n              temp_extremes <- rbind(temp_extremes, station_trends)\n            }\n          }\n          cached_temp_extremes(temp_extremes)\n        }, error = function(e) {\n          warning(\"Error caching temperature extremes:\", e$message)\n        })\n        \n        # Cache temperature trends\n        tryCatch({\n          temp_trends <- list()\n          for(station_name in names(stations_data)) {\n            trends <- identify_temp_trends(stations_data[[station_name]])\n            if(length(trends) > 0) {\n              temp_trends[[station_name]] <- trends\n            }\n          }\n          cached_temp_trends(temp_trends)\n        }, error = function(e) {\n          warning(\"Error caching temperature trends:\", e$message)\n        })\n        \n        # Cache precipitation changes\n        tryCatch({\n          precip_changes <- list()\n          for (station in names(active_sensors)) {\n            station_data <- stations_data[[station]]\n            if (!is.null(station_data)) {\n              if (\"PrecipOP2\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_OP2\")]] <- identify_precip_changes(station_data, \"PrecipOP2\")\n              }\n              if (\"PrecipOP1\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_OP1\")]] <- identify_precip_changes(station_data, \"PrecipOP1\")\n              }\n              if (\"PrecipPC2\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_PC2\")]] <- identify_precip_changes(station_data, \"PrecipPC2\")\n              }\n              if (\"Pcp_raw\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_Pcp_raw\")]] <- identify_precip_changes(station_data, \"Pcp_raw\")\n              }\n              if (\"PrecipRIT\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_RIT\")]] <- identify_precip_changes(station_data, \"PrecipRIT\")\n              }\n              if (\"PC\" %in% names(station_data)) {\n                precip_changes[[paste0(station, \"_PC\")]] <- identify_precip_changes(station_data, \"PC\")\n              }\n            }\n          }\n          cached_precip_changes(precip_changes)\n        }, error = function(e) {\n          warning(\"Error caching precipitation changes:\", e$message)\n        })\n        \n        # Cache Vbat trends\n        tryCatch({\n          cached_vbat_trends(prepare_trend_data(cached_power_data()))\n        }, error = function(e) {\n          warning(\"Error caching Vbat trends:\", e$message)\n        })\n      })\n\n      \n      # Update UI station selectors\n      updateSelectizeInput(session, \"db_station_select\",\n                         choices = c(\"All Stations\", names(stations_data)))\n      \n      stations_with_power <- names(cached_power_data())\n      updateSelectizeInput(session, \"power_station_select\",\n                         choices = c(\"All Stations\", stations_with_power))\n      \n      updateSelectInput(session, \"temp_analysis_station_select\",\n                       choices = c(\"All Stations\", names(wx_data())))\n      \n      observe({\n        trend_data <- cached_vbat_trends()\n        if (!is.null(trend_data) && length(trend_data) > 0) {\n          updateSelectInput(session, \"vbat_trends_station_select\",\n                          choices = c(\"All Stations\", names(trend_data)),\n                          selected = \"All Stations\")\n        }\n      })\n      \n      zero_wspd <- cached_zero_wspd()\n      zero_wspd_stations <- names(zero_wspd)[sapply(zero_wspd, function(x) !is.null(x) && is.data.frame(x) && nrow(x) > 0)]\n      updateSelectizeInput(session, \"zero_wspd_station_select\",\n                         choices = c(\"All Stations\", zero_wspd_stations))\n      \n      constant_temp <- cached_constant_temp()\n      constant_temp_stations <- names(constant_temp)[sapply(constant_temp, function(x) !is.null(x) && is.data.frame(x) && nrow(x) > 0)]\n      updateSelectizeInput(session, \"constant_temp_station_select\",\n                         choices = c(\"All Stations\", constant_temp_stations))\n      \n      consecutive_rh <- cached_consecutive_rh()\n      if (is.data.frame(consecutive_rh)) {\n        rh_stations <- unique(consecutive_rh$Station)\n        updateSelectizeInput(session, \"rh_station_select\",\n                           choices = c(\"All Stations\", rh_stations))\n      }\n      \n      rn1_outliers <- cached_rn1_outliers()\n      rn1_outliers_stations <- names(rn1_outliers)[sapply(rn1_outliers, function(x) !is.null(x) && is.data.frame(x) && nrow(x) > 0)]\n      updateSelectizeInput(session, \"rn1_outliers_station_select\",\n                         choices = c(\"All Stations\", rn1_outliers_stations))\n      \n      temp_trends <- cached_temp_trends()\n      trend_stations <- names(temp_trends)[sapply(temp_trends, function(x) length(x) > 0)]\n      updateSelectizeInput(session, \"temp_trends_station_select\",\n                         choices = c(\"All Stations\", trend_stations))\n      \n      if (!is.null(active_crmp_sensors()) && length(active_crmp_sensors()) > 0) {\n        updateSelectizeInput(session, \"crmp_station_select\",\n                           choices = c(\"All Stations\", names(active_crmp_sensors())))\n      }\n    })\n  })\n  \n  # ---------- Last Entry Time Check ----------\n  last_entry_time_check <- eventReactive(input$fetch_data, {\n    req(WX_stations())\n    \n    # Get current time in Pacific Time\n    current_time <- with_tz(Sys.time(), \"America/Los_Angeles\")\n    \n    # Flag to determine if we're fetching historical data\n    is_historical <- input$fetch_type %in% c(\"by_date\", \"date_range\")\n    \n    results <- lapply(names(WX_stations()), function(station_name) {\n      station_data <- WX_stations()[[station_name]]\n      \n      if (is.null(station_data) || nrow(station_data) == 0) {\n        return(data.frame(\n          Station = station_name,\n          LastEntry = as.character(NA),\n          TimeDifference = as.numeric(NA),\n          Status = \"No data\"\n        ))\n      }\n      \n      # Parse timestamp directly as Pacific Time since that's what it is\n      last_entry_time <- try({\n        as.POSIXct(station_data$DateTimeNum[1], format = \"%Y-%b-%d %H:%M:%S\", tz = \"America/Los_Angeles\")\n      }, silent = TRUE)\n      \n      if (inherits(last_entry_time, \"try-error\") || is.na(last_entry_time)) {\n        return(data.frame(\n          Station = clean_station_name,\n          LastEntry = as.character(NA),\n          TimeDifference = as.numeric(NA),\n          Status = \"Invalid date\"\n        ))\n      }\n      \n      # Calculate time difference (both times in Pacific Time)\n      time_diff <- as.numeric(difftime(current_time, last_entry_time, units = \"hours\"))\n      \n      # Determine status based on whether we're looking at historical data\n      status <- if (is_historical) {\n        \"Historical\"\n      } else {\n        dplyr::case_when(\n          is.na(time_diff) ~ \"Invalid date\",\n          time_diff <= 1 ~ \"Up to date\",\n          time_diff <= 3 ~ \"Slightly delayed\",\n          time_diff <= 6 ~ \"Delayed\",\n          TRUE ~ \"Significantly delayed\"\n        )\n      }\n      \n      data.frame(\n        Station = station_name,\n        LastEntry = format(last_entry_time, \"%Y-%m-%d %H:%M\"),\n        TimeDifference = round(time_diff, 2),\n        Status = status,\n        stringsAsFactors = FALSE\n      )\n    })\n    \n    do.call(rbind, results)\n  })\n  \n  # ---------- Reactive Expressions ----------\n  # Use cached values in reactive expressions\n  all_power_data <- reactive({\n    cached_power_data()\n  })\n  \n  temp_extremes_data <- reactive({\n    cached_temp_extremes()\n  })\n  \n  missing_entries_data <- reactive({\n    cached_missing_entries()\n  })\n  \n  all_rn1_outliers <- reactive({\n    cached_rn1_outliers()\n  })\n  \n  constant_temp_data <- reactive({\n    cached_constant_temp()\n  })\n  \n  zero_wspd_data <- reactive({\n    cached_zero_wspd()\n  })\n  \n  vbat_trend_data <- reactive({\n    cached_vbat_trends()\n  })\n  \n  all_precip_changes <- reactive({\n    cached_precip_changes()\n  })\n  \n  # Space weather data\n  space_weather_data <- reactive({\n    fetch_space_weather_alerts()\n  })\n  \n  # ---------- Output Renderings ----------\n  output$data_status <- renderText({\n    req(input$fetch_data)\n    \n    if (input$fetch_type == \"last_n\") {\n      sprintf(\"Last %dh • %s\", input$num_entries, input$fire_centre)\n    } else if (input$fetch_type == \"by_date\") {\n      sprintf(\"%s • %s\", \n              format(input$select_date, \"%b %d, %Y\"),\n              input$fire_centre)\n    } else {\n      sprintf(\"%s - %s • %s\", \n              format(input$start_date, \"%b %d, %Y\"),\n              format(input$end_date, \"%b %d, %Y\"),\n              input$fire_centre)\n    }\n  })\n  \n  # DB Module Outputs\n  output$last_entry_time_check <- renderDT({\n    status_data <- last_entry_time_check()\n    \n    if (!is.null(input$db_station_select) && input$db_station_select != \"All Stations\") {\n      status_data <- status_data %>%\n        filter(Station == input$db_station_select)\n    }\n    \n    # Rename columns for display\n    names(status_data) <- c(\"Station\", \"Last Entry\", \"Hours Since Update\", \"Status\")\n    \n    render_report_status_output(status_data)\n  })\n  \n  output$space_weather_table <- renderDT({\n    render_space_weather_table(space_weather_data(), input)\n  })\n  \n  output$missing_entries_output <- renderPrint({\n    render_missing_entries_output(missing_entries_data, input$db_station_select)\n  })\n  \n  output$missing_entries_plot <- renderPlotly({\n    create_missing_entries_plot(missing_entries_data(), input$db_station_select)\n  })\n  \n  output$recent_entries <- renderDT({\n    req(wx_data(), input$db_station_select)\n    \n    selected_data <- if (input$db_station_select == \"All Stations\") {\n      wx_data()\n    } else {\n      # Create a new list with only the selected station\n      selected_station_data <- list()\n      selected_station_data[[input$db_station_select]] <- wx_data()[[input$db_station_select]]\n      selected_station_data\n    }\n    \n    render_recent_entries(selected_data)\n  }, server = FALSE)  \n  \n  output$original_output <- renderPrint({\n    render_check_for_blanks(wx_data())\n  })\n  \n  # Power Module Outputs\n  output$vbat_waterfall_plot <- renderPlotly({\n    create_vbat_waterfall_plot(all_power_data(), input$power_station_select)\n  })\n  \n  output$vbat_trends_plot <- renderPlotly({\n    trend_data <- vbat_trend_data()\n    req(trend_data)\n    create_vbat_trends_plot(trend_data, input$vbat_trends_station_select)\n  })\n  \n  output$power_status_output <- renderPrint({\n    render_power_status_output(input, all_power_data)\n  })\n  \n  output$battery_voltage_alerts <- renderPrint({\n    render_battery_voltage_alerts(all_power_data())\n  })\n  \n  output$vbat_trends_output <- renderPrint({\n    req(all_power_data(), input$vbat_trends_station_select)\n    selected_data <- all_power_data()\n    \n    # Filter the data based on station selection\n    if (!is.null(input$vbat_trends_station_select) && \n        !\"All Stations\" %in% input$vbat_trends_station_select) {\n      selected_data <- selected_data[input$vbat_trends_station_select]\n    }\n    \n    cat(analyze_vbat_trends(selected_data))\n  })\n  \n  # CRMP Module Outputs\n  output$sdepth_concerns_output <- renderPrint({\n    render_sdepth_concerns_output(wx_data(), active_crmp_sensors())\n  })\n  \n  output$crmp_precip_changes <- renderPrint({\n    render_crmp_precip_changes(all_precip_changes())\n  })\n  \n  output$crmp_entries <- renderPrint({\n    req(input$crmp_station_select)\n    \n    if (input$crmp_station_select == \"All Stations\") {\n      render_crmp_entries(wx_data(), active_crmp_sensors())\n    } else {\n      selected_station_data <- list()\n      selected_station_data[[input$crmp_station_select]] <- wx_data()[[input$crmp_station_select]]\n      \n      selected_checks <- list()\n      selected_checks[[input$crmp_station_select]] <- active_crmp_sensors()[[input$crmp_station_select]]\n      \n      render_crmp_entries(selected_station_data, selected_checks)\n    }\n  })\n  \n  output$precip_plot <- renderPlotly({\n    create_precip_plot(wx_data(), input$crmp_station_select)\n  })\n  \n  output$sdepth_plot <- renderPlotly({\n    create_sdepth_plot(wx_data(), input$crmp_station_select)\n  })\n  \n  # Wind Module Outputs\n  output$high_wspd_output <- renderPrint({\n    render_high_wspd_output(wx_data())\n  })\n  \n  output$dir_check <- renderPrint({\n    render_dir_check_output(wx_data())\n  })\n  \n  output$zero_wspd_output <- renderPrint({\n    render_zero_wspd_output(wx_data(), input$zero_wspd_station_select)\n  })\n  \n  output$zero_wspd_plot <- renderPlotly({\n    create_zero_wspd_plot(zero_wspd_data(), input$zero_wspd_station_select)\n  })\n  \n  # Temperature Module Outputs\n  output$extreme_temp_output <- renderPrint({\n    render_extreme_temp_output(wx_data())\n  })\n  \n  output$temp_change_heatmap <- renderPlotly({\n    req(wx_data())\n    create_temp_change_heatmap(wx_data(), input$temp_analysis_station_select)\n  })\n  \n  output$temp_extremes_output <- renderPrint({\n    render_temp_extremes_output(wx_data())\n  })\n  \n  output$temp_check <- renderPrint({\n    req(constant_temp_data(), input$constant_temp_station_select)\n    render_temp_check(input, constant_temp_data())\n  })\n  \n  output$erratic_temp_output <- renderPrint({\n    req(wx_data())\n    render_erratic_temp_output(wx_data(), input$temp_analysis_station_select)\n  })  \n  \n  output$rapid_temp_changes_output <- renderPrint({\n    render_rapid_temp_changes_output(wx_data())\n  })\n  \n  output$temp_range_plot <- renderPlotly({\n    create_temp_range_plot(temp_extremes_data())\n  })\n  \n  output$constant_temp_summary_plot <- renderPlotly({\n    req(constant_temp_data(), input$constant_temp_station_select)\n    create_constant_temp_summary(constant_temp_data(), input$constant_temp_station_select)\n  })\n  \n  output$constant_temp_plot <- renderPlotly({\n    req(constant_temp_data())\n    create_constant_temp_plot(constant_temp_data(), input$constant_temp_station_select)\n  })\n  \n  # RH Module Outputs\n  output$low_rh_output <- renderPrint({\n    render_low_rh_output(wx_data())\n  })\n  \n  output$consecutive_rh_output <- renderPrint({\n    render_consecutive_rh_output(wx_data(), input$rh_station_select)\n  })\n  \n  output$consecutive_rh_plot <- renderPlotly({\n    create_consecutive_rh_plot(wx_data(), input$rh_station_select)\n  })\n  \n  # Precipitation Module Outputs\n  output$decreasing_trends_output <- renderPrint({\n    req(input$fetch_data, input$temp_trends_station_select)\n    render_decreasing_trends_output(wx_data(), input$temp_trends_station_select)\n  })\n  \n  output$station_rainfall_output <- renderPrint({\n    req(wx_data())  # Ensure wx_data is available\n    render_station_rainfall_output(wx_data(), input$station_select)\n  })\n  \n  output$rn1_outliers_output <- renderPrint({\n    render_rn1_outliers_output(input, all_rn1_outliers())\n  })\n  \n  output$rn1_outliers_plot <- renderPlotly({\n    create_rn1_outliers_plot(wx_data(), all_rn1_outliers(), input$rn1_outliers_station_select)\n  })\n  \n  output$df_structure <- renderPrint({\n    req(wx_data(), input$db_station_select)\n    \n    if (input$db_station_select == \"All Stations\") {\n      # Show structure for all stations\n      for (station_name in names(wx_data())) {\n        station_data <- wx_data()[[station_name]]\n        if (!is.null(station_data) && nrow(station_data) > 0) {\n          cat(\"\\nStructure for station:\", station_name, \"\\n\")\n          str(station_data)\n          cat(\"\\n\")\n        }\n      }\n    } else {\n      # Show structure for selected station only\n      selected_data <- wx_data()[[input$db_station_select]]\n      if (!is.null(selected_data) && nrow(selected_data) > 0) {\n        str(selected_data)\n      } else {\n        cat(\"No data available for selected station\")\n      }\n    }\n  })\n}\n\n# ---------- Run Application ----------\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"data/r/crmp_module/crmp_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# crmp_module/crmp_charts.R\n\n# Create a precipitation plot for CRMP stations\n#' Create a plot of cumulative precipitation measurements over time\n#'\n#' @param WX_stations List of weather station data frames\n#' @param selected_station The station identifier selected in the UI\n#' @return A plotly object showing precipitation measurements over time\ncreate_precip_plot <- function(WX_stations, selected_station) {\n  # Initialize an empty plot with a message for when no data is available\n  empty_plot <- plotly::plot_ly() %>% \n    plotly::add_annotations(\n      text = \"No precipitation data available for the selected station(s)\",\n      showarrow = FALSE,\n      font = list(size = 15)\n    )\n  \n  # Return empty plot if WX_stations is NULL or empty\n  if (is.null(WX_stations) || length(WX_stations) == 0) {\n    return(empty_plot)\n  }\n  \n  # Return empty plot if \"All Stations\" is selected\n  if (selected_station == \"All Stations\") {\n    return(empty_plot)\n  }\n  \n  # Check if selected station exists\n  if (!selected_station %in% names(WX_stations)) {\n    return(empty_plot)\n  }\n  \n  # Get data for the selected station\n  station_data <- WX_stations[[selected_station]]\n  \n  # Return empty plot if station data is NULL or empty\n  if (is.null(station_data) || nrow(station_data) == 0) {\n    return(empty_plot)\n  }\n  \n  # Check for precipitation columns\n  precip_sensors <- c(\"PrecipOP2\", \"PrecipOP1\", \"PrecipPC2\", \"PrecipRIT\", \"PC\", \"Pcp_raw\")\n  available_sensors <- intersect(precip_sensors, names(station_data))\n  \n  # Return empty plot if no precipitation data is available\n  if (length(available_sensors) == 0) {\n    return(empty_plot)\n  }\n  \n  # Convert dates if needed\n  if (is.character(station_data$DateTimeNum)) {\n    station_data$DateTime <- as.POSIXct(station_data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\")\n  } else {\n    station_data$DateTime <- station_data$DateTimeNum\n  }\n  \n  # Sort data chronologically\n  station_data <- station_data[order(station_data$DateTime), ]\n  \n  # Initialize plot\n  p <- plotly::plot_ly()\n  has_data <- FALSE\n  \n  # Define color palette for different sensor types\n  sensor_colors <- c(\n    \"PrecipOP2\" = \"#1f77b4\",  # Blue\n    \"PrecipOP1\" = \"#ff7f0e\",  # Orange\n    \"PrecipPC2\" = \"#2ca02c\",  # Green\n    \"PrecipRIT\" = \"#d62728\",  # Red\n    \"PC\" = \"#9467bd\",         # Purple\n    \"Pcp_raw\" = \"#8c564b\"     # Brown\n  )\n  \n  # Add a trace for each available precipitation sensor\n  for (sensor in available_sensors) {\n    # Skip if no valid data\n    if (!any(!is.na(station_data[[sensor]]))) next\n    \n    # Get user-friendly name for the sensor\n    sensor_name <- switch(sensor,\n                         \"PrecipOP2\" = \"Optical Precip 2\",\n                         \"PrecipOP1\" = \"Optical Precip 1\",\n                         \"PrecipPC2\" = \"Precip Counter 2\",\n                         \"PrecipRIT\" = \"RIT Precip\",\n                         \"PC\" = \"Precip Counter\",\n                         \"Pcp_raw\" = \"Raw Precip\",\n                         sensor)\n    \n    # Add trace for this sensor\n    p <- p %>% plotly::add_trace(\n      data = station_data,\n      x = ~DateTime,\n      y = as.formula(paste0(\"~\", sensor)),\n      type = \"scatter\",\n      mode = \"lines+markers\",\n      name = sensor_name,\n      line = list(color = sensor_colors[sensor], width = 2),\n      marker = list(size = 4, color = sensor_colors[sensor]),\n      hoverinfo = \"text\",\n      text = ~paste(\n        \"Station:\", selected_station,\n        \"<br>Date:\", format(DateTime, \"%Y-%m-%d %H:%M\"),\n        \"<br>\", sensor_name, \":\", round(get(sensor), 2), \"mm\"\n      )\n    )\n    has_data <- TRUE\n  }\n  \n  # Return empty plot if no valid precipitation data was found\n  if (!has_data) {\n    return(empty_plot)\n  }\n  \n  # Finalize plot layout\n  p <- p %>% plotly::layout(\n    title = paste(\"Cumulative Precipitation -\", selected_station),\n    xaxis = list(title = \"Date & Time\"),\n    yaxis = list(title = \"Precipitation (mm)\"),\n    hovermode = \"closest\",\n    legend = list(orientation = \"h\", y = -0.2)\n  )\n  \n  return(p)\n}\n\n\n#' Create a snow depth plot\n#' Create a plot of snow depth measurements over time\n#'\n#' @param WX_stations List of weather station data frames\n#' @param selected_station The station identifier selected in the UI\n#' @return A plotly object showing snow depth measurements over time\ncreate_sdepth_plot <- function(WX_stations, selected_station) {\n  # Initialize an empty plot with a message\n  empty_plot <- plotly::plot_ly() %>% \n    plotly::add_annotations(\n      text = \"No snow depth data available for the selected station(s)\",\n      showarrow = FALSE,\n      font = list(size = 15)\n    )\n  \n  # Handle case when no data is available\n  if (is.null(WX_stations) || length(WX_stations) == 0) {\n    return(empty_plot)\n  }\n  \n  # Return empty plot if \"All Stations\" is selected\n  if (selected_station == \"All Stations\") {\n    return(empty_plot)\n  }\n  \n  # Determine station to plot\n  if (!selected_station %in% names(WX_stations)) {\n    return(empty_plot)\n  }\n  \n  # Only plot the selected station\n  stations_to_plot <- selected_station\n  \n  # Initialize plot\n  p <- plotly::plot_ly()\n  has_data <- FALSE\n  \n  # Process each selected station\n  for (station_name in stations_to_plot) {\n    # Skip if station doesn't exist in our data\n    if (!station_name %in% names(WX_stations)) next\n    \n    station_data <- WX_stations[[station_name]]\n    \n    # Skip if no data available\n    if (is.null(station_data) || nrow(station_data) == 0) next\n    \n    # Check for snow depth columns\n    has_sdepth <- \"SDepth\" %in% names(station_data) && any(!is.na(station_data$SDepth))\n    has_sd <- \"SD\" %in% names(station_data) && any(!is.na(station_data$SD))\n    \n    # Skip if no snow depth data\n    if (!has_sdepth && !has_sd) next\n    \n    # Convert dates if needed\n    if (is.character(station_data$DateTimeNum)) {\n      station_data$DateTime <- as.POSIXct(station_data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\")\n    } else {\n      station_data$DateTime <- station_data$DateTimeNum\n    }\n    \n    # Sort data chronologically\n    station_data <- station_data[order(station_data$DateTime), ]\n    \n    # Add SDepth trace if available\n    if (has_sdepth) {\n      p <- p %>% plotly::add_trace(\n        data = station_data,\n        x = ~DateTime,\n        y = ~SDepth,\n        type = \"scatter\",\n        mode = \"lines+markers\",\n        name = paste(station_name, \"- SDepth\"),\n        marker = list(size = 3),\n        hoverinfo = \"text\",\n        text = ~paste(\n          \"Station:\", station_name,\n          \"<br>Date:\", format(DateTime, \"%Y-%m-%d %H:%M\"),\n          \"<br>Snow Depth:\", round(SDepth, 1), \"cm\"\n        )\n      )\n      has_data <- TRUE\n    }\n    \n    # Add SD trace if available\n    if (has_sd) {\n      p <- p %>% plotly::add_trace(\n        data = station_data,\n        x = ~DateTime,\n        y = ~SD,\n        type = \"scatter\",\n        mode = \"lines+markers\",\n        name = paste(station_name, \"- SD\"),\n        marker = list(size = 3),\n        hoverinfo = \"text\",\n        text = ~paste(\n          \"Station:\", station_name,\n          \"<br>Date:\", format(DateTime, \"%Y-%m-%d %H:%M\"),\n          \"<br>Snow Depth:\", round(SD, 1), \"cm\"\n        )\n      )\n      has_data <- TRUE\n    }\n  }\n  \n  # Return empty plot if no data was found\n  if (!has_data) {\n    return(empty_plot)\n  }\n  \n  # Finalize plot layout\n  p <- p %>% plotly::layout(\n    title = \"Snow Depth Measurements\",\n    xaxis = list(title = \"Date & Time\"),\n    yaxis = list(title = \"Snow Depth (cm)\"),\n    hovermode = \"closest\",\n    legend = list(orientation = \"h\", y = -0.2)\n  )\n  \n  return(p)\n}","type":"text"},{"name":"data/r/crmp_module/crmp_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/crmp_module/crmp_functions.R\n\nidentify_sdepth_concerns <- function(data, change_threshold = 10, negative_threshold = -2.0) {\n  has_sdepth <- \"SDepth\" %in% colnames(data)\n  has_sd <- \"SD\" %in% colnames(data)\n  \n  if (!has_sdepth && !has_sd) {\n    warning(\"Neither 'SDepth' nor 'SD' columns are present in the data. Returning empty results.\")\n    return(list(\n      rapid_changes = data.frame(),\n      negative_summary = data.frame()\n    ))\n  }\n  \n  # Process each sensor type separately and combine results\n  results_list <- list()\n  \n  if (has_sdepth) {\n    # Calculate changes for SDepth\n    sdepth_data <- data %>%\n      arrange(DateTimeNum) %>%\n      mutate(\n        sensor_type = \"SDepth\",\n        depth_value = SDepth,\n        depth_change = SDepth - lag(SDepth),\n        is_negative = SDepth < negative_threshold\n      )\n    results_list$SDepth <- process_depth_data(sdepth_data, change_threshold)\n  }\n  \n  if (has_sd) {\n    # Calculate changes for SD\n    sd_data <- data %>%\n      arrange(DateTimeNum) %>%\n      mutate(\n        sensor_type = \"SD\",\n        depth_value = SD,\n        depth_change = SD - lag(SD),\n        is_negative = SD < negative_threshold\n      )\n    results_list$SD <- process_depth_data(sd_data, change_threshold)\n  }\n  \n  # Combine results from both sensors\n  combined_results <- list(\n    rapid_changes = bind_rows(\n      if(has_sdepth) results_list$SDepth$rapid_changes else NULL,\n      if(has_sd) results_list$SD$rapid_changes else NULL\n    ),\n    negative_summary = bind_rows(\n      if(has_sdepth) results_list$SDepth$negative_summary else NULL,\n      if(has_sd) results_list$SD$negative_summary else NULL\n    )\n  )\n  \n  return(combined_results)\n}\n\n# Helper function to process depth data\nprocess_depth_data <- function(data, change_threshold) {\n  # Identify rapid changes\n  rapid_changes <- data %>%\n    filter(abs(depth_change) > change_threshold) %>%\n    mutate(\n      change_type = ifelse(depth_change > 0, \"increase\", \"decrease\")\n    ) %>%\n    select(DateTimeNum, sensor_type, depth_value, depth_change, change_type) %>%\n    arrange(desc(DateTimeNum))\n  \n  # Summarize negative values\n  negative_summary <- data %>%\n    filter(is_negative) %>%\n    summarize(\n      sensor_type = first(sensor_type),\n      total_negative_count = n(),\n      first_occurrence = if (n() > 0) min(DateTimeNum, na.rm = TRUE) else NA,\n      last_occurrence = if (n() > 0) max(DateTimeNum, na.rm = TRUE) else NA,\n      min_value = if (n() > 0) min(depth_value, na.rm = TRUE) else NA,\n      median_value = if (n() > 0) median(depth_value, na.rm = TRUE) else NA\n    )\n  \n  list(\n    rapid_changes = rapid_changes,\n    negative_summary = negative_summary\n  )\n}\n\nrender_sdepth_concerns_output <- function(WX_stations, active_crmp_sensors) {\n  cat(\"\\nChecks for rapid hourly changes (>10cm) or negative values\\n\\n\")\n  \n  # Get stations with either SDepth or SD sensors\n  depth_stations <- names(active_crmp_sensors)[sapply(active_crmp_sensors, function(x) \n    \"SDepth\" %in% x || \"SD\" %in% x)]\n  concerns_found <- FALSE\n  \n  for (station in depth_stations) {\n    station_data <- WX_stations[[station]]\n    if (is.null(station_data)) next\n    concerns <- identify_sdepth_concerns(station_data)\n    if (is.null(concerns)) next\n    \n    # Only proceed if there are actual concerns to report\n    if (nrow(concerns$rapid_changes) > 0 || \n        (nrow(concerns$negative_summary) > 0 && any(concerns$negative_summary$total_negative_count > 0))) {\n      concerns_found <- TRUE\n      cat(sprintf(\"Station: %s\\n\", station))\n      cat(paste(rep(\"-\", nchar(station) + 9), collapse = \"\"), \"\\n\")\n      \n      # Report rapid changes\n      if (nrow(concerns$rapid_changes) > 0) {\n        cat(\"\\nRapid Changes (>10cm):\\n\")\n        changes_to_print <- concerns$rapid_changes %>%\n          mutate(\n            Change = sprintf(\"%+.1f cm\", depth_change)\n          ) %>%\n          select(DateTimeNum, sensor_type, change_type, Change, depth_value)\n        print(changes_to_print, row.names = FALSE)\n      }\n      \n      # Report negative value summary by sensor type\n      if (nrow(concerns$negative_summary) > 0) {\n        for (sensor in unique(concerns$negative_summary$sensor_type)) {\n          sensor_summary <- concerns$negative_summary %>% \n            filter(sensor_type == sensor, total_negative_count > 0)\n          \n          if (nrow(sensor_summary) > 0) {\n            cat(sprintf(\"\\nNegative Values Summary (%s):\\n\", sensor))\n            cat(sprintf(\"Total occurrences: %d\\n\", sensor_summary$total_negative_count))\n            cat(sprintf(\"Period: %s to %s\\n\", sensor_summary$first_occurrence, \n                       sensor_summary$last_occurrence))\n            cat(sprintf(\"Min value: %.1f cm, Median: %.1f cm\\n\", \n                       sensor_summary$min_value, \n                       sensor_summary$median_value))\n          }\n        }\n      }\n      cat(\"\\n\")\n    }\n  }\n  if (!concerns_found) {\n    cat(\"No snow depth alerts detected.\\n\")\n  }\n}\n\n# PRECIPOP2 and PRECIPP2 alert function\nidentify_precip_changes <- function(data, column, increase_threshold = 10, decrease_threshold = -2.0) {\n  if (!column %in% colnames(data)) {\n    return(NULL)\n  }\n\n  data <- data %>%\n    mutate(\n      # Calculate change looking at the next reading in descending order\n      PrecipChange = !!sym(column) - lead(!!sym(column)),\n      # Flag concerning changes\n      ChangeType = case_when(\n        PrecipChange > increase_threshold ~ \"Large Increase\",\n        PrecipChange < decrease_threshold ~ \"Decrease\",\n        TRUE ~ NA_character_\n      )\n    ) %>%\n    filter(!is.na(ChangeType)) %>%  # Keep only rows with flagged changes\n    select(DateTimeNum, !!sym(column), PrecipChange, ChangeType)\n\n  # Return NULL if no concerning changes are detected\n  if (nrow(data) == 0) return(NULL)\n  \n  data\n}","type":"text"},{"name":"data/r/crmp_module/crmp_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/crmp_module/crmp_output.R\n\n#' Render SDEPTH and SD concerns output\n#' @param WX_stations List of weather station data\n#' @param active_crmp_sensors List of active CRMP sensors\nrender_sdepth_concerns_output <- function(WX_stations, active_crmp_sensors) {\n  cat(\"\\nChecks for rapid hourly changes (>10cm) or negative values\\n\\n\")\n  \n  # Get stations with either SDepth or SD sensors\n  depth_stations <- names(active_crmp_sensors)[sapply(active_crmp_sensors, function(x) \n    \"SDepth\" %in% x || \"SD\" %in% x)]\n  concerns_found <- FALSE\n  \n  for (station in depth_stations) {\n    station_data <- WX_stations[[station]]\n    if (is.null(station_data)) next\n    concerns <- identify_sdepth_concerns(station_data)\n    if (is.null(concerns)) next\n    \n    # Only proceed if there are actual concerns to report\n    if (nrow(concerns$rapid_changes) > 0 || \n        (nrow(concerns$negative_summary) > 0 && any(concerns$negative_summary$total_negative_count > 0))) {\n      concerns_found <- TRUE\n      cat(sprintf(\"Station: %s\\n\", station))\n      cat(paste(rep(\"-\", nchar(station) + 9), collapse = \"\"), \"\\n\")\n      \n      # Report rapid changes\n      if (nrow(concerns$rapid_changes) > 0) {\n        cat(\"\\nRapid Changes (>10cm):\\n\")\n        changes_to_print <- concerns$rapid_changes %>%\n          mutate(\n            Change = sprintf(\"%+.1f cm\", depth_change)\n          ) %>%\n          select(DateTimeNum, sensor_type, change_type, Change, depth_value)\n        print(changes_to_print, row.names = FALSE)\n      }\n      \n      # Report negative value summary by sensor type only if negative values exist\n      if (nrow(concerns$negative_summary) > 0) {\n        negative_sensors <- concerns$negative_summary %>%\n          filter(total_negative_count > 0)\n        \n        if (nrow(negative_sensors) > 0) {\n          for (sensor in unique(negative_sensors$sensor_type)) {\n            sensor_summary <- negative_sensors %>% \n              filter(sensor_type == sensor)\n            \n            cat(sprintf(\"\\nNegative Values Summary (%s):\\n\", sensor))\n            cat(sprintf(\"Total occurrences: %d\\n\", sensor_summary$total_negative_count))\n            cat(sprintf(\"Period: %s to %s\\n\", sensor_summary$first_occurrence, \n                       sensor_summary$last_occurrence))\n            cat(sprintf(\"Min value: %.1f cm, Median: %.1f cm\\n\", \n                       sensor_summary$min_value, \n                       sensor_summary$median_value))\n          }\n        }\n      }\n      cat(\"\\n\")\n    }\n  }\n  if (!concerns_found) {\n    cat(\"No snow depth alerts detected.\\n\")\n  }\n}\n#' Render PRECIPOP2 and CP2 issues output\n#' @param precip_changes List of precipitation changes\nrender_crmp_precip_changes <- function(precip_changes) {\n  cat(\"Flags notable hourly changes in PrecipOP2 and PrecipPC2:\\n\")\n  cat(\"- Large Increases: > 10mm between readings\\n\")\n  cat(\"- Decreases: < -3.0mm\\n\\n\")\n  \n  # More comprehensive check for \"no changes\"\n  has_changes <- FALSE\n  for (station in names(precip_changes)) {\n    if (!is.null(precip_changes[[station]]) && \n        inherits(precip_changes[[station]], \"data.frame\") && \n        nrow(precip_changes[[station]]) > 0) {\n      has_changes <- TRUE\n      break\n    }\n  }\n  \n  if (!has_changes) {\n    cat(\"No notable changes detected.\")\n  } else {\n    for (station in names(precip_changes)) {\n      if (!is.null(precip_changes[[station]]) && \n          inherits(precip_changes[[station]], \"data.frame\") && \n          nrow(precip_changes[[station]]) > 0) {\n        # Extract just the station name without dbo. and without the _OP2/_PC2 suffix\n        clean_station <- sub(\"^dbo\\\\.\", \"\", strsplit(station, \"_[OP|PC]2\")[[1]][1])\n        precip_type <- ifelse(grepl(\"_OP2$\", station), \"PrecipOP2\", \"PrecipPC2\")\n        cat(\"\\n\", clean_station, \" (\", precip_type, \")\\n\", sep = \"\")\n        print(precip_changes[[station]], row.names = FALSE)\n      }\n    }\n  }\n}\n\n#' Render CRMP entries output\n#' @param WX_stations List of weather station data\n#' @param active_crmp_sensors List of active CRMP sensors\nrender_crmp_entries <- function(WX_stations, active_crmp_sensors) {\n  req(WX_stations)\n  \n  for (station in names(active_crmp_sensors)) {\n    data <- WX_stations[[station]]\n    if (is.null(data)) next\n    \n    clean_station_name <- sub(\"^dbo\\\\.\", \"\", station)\n    cat(\"\\n\", clean_station_name, \"\\n\", sep = \"\")\n    \n    # Get active sensors for this station\n    active_sensors <- active_crmp_sensors[[station]]\n    \n    # Get columns that exist in the data\n    cols_to_show <- c(\"DateTimeNum\", intersect(active_sensors, names(data)))\n    if (length(cols_to_show) > 1) {  # Only proceed if we have CRMP columns\n      print(data[cols_to_show])\n    }\n  }\n}","type":"text"},{"name":"data/r/db_module/db_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/db_module/db_charts.R\n\n#' Create a plot showing missing entries across stations\n#' @param missing_entries_data Data frame containing missing entries information\n#' @param selected_station Selected station name (optional)\n#' @return Plotly object showing missing entries over time\ncreate_missing_entries_plot <- function(missing_entries_data, selected_station = NULL) {\n  # Check for valid data\n  if (!is.data.frame(missing_entries_data) || nrow(missing_entries_data) == 0) {\n    return(plot_ly() %>% \n      layout(\n        title = \"No missing entries to display\",\n        xaxis = list(title = \"Date and Time\"),\n        yaxis = list(title = \"Station\")\n      ))\n  }\n  \n  # Filter by selected station if specified\n  missing_entries <- missing_entries_data\n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    missing_entries <- missing_entries %>% filter(Table == selected_station)\n  }\n  \n  # Ensure data after filtering\n  if (nrow(missing_entries) == 0) {\n    return(plot_ly() %>% \n      layout(\n        title = \"No data gaps to display for selected station\",\n        xaxis = list(title = \"Date and Time\"),\n        yaxis = list(title = \"Station\")\n      ))\n  }\n  \n  # Convert datetime and filter out NA values\n  missing_entries$MissingDateTime <- as.POSIXct(missing_entries$MissingDateTime, tz=\"UTC\")\n  missing_entries <- missing_entries %>% filter(!is.na(MissingDateTime))\n  \n  # Check for valid entries after datetime processing\n  if (nrow(missing_entries) == 0) {\n    return(plot_ly() %>% \n      layout(\n        title = \"No valid datetime entries to display\",\n        xaxis = list(title = \"Date and Time\"),\n        yaxis = list(title = \"Station\")\n      ))\n  }\n  \n  # Create the plot\n  plot_ly(\n    missing_entries, \n    x = ~MissingDateTime, \n    y = ~Table, \n    type = 'scatter', \n    mode = 'markers',\n    marker = list(size = 5, color = 'black'),\n    hoverinfo = 'text',\n    text = ~paste(\n      \"Station:\", Table, \n      \"<br>Missing Hour:\", format(MissingDateTime, \"%Y-%m-%d %H:00:00\")\n    )\n  ) %>%\n    layout(\n      title = \"Missing Hourly Entries by Station\",\n      xaxis = list(\n        title = \"Date and Time\", \n        rangeslider = list(visible = TRUE)\n      ),\n      yaxis = list(title = \"Station\"),\n      hoverlabel = list(bgcolor = \"white\"),\n      showlegend = FALSE\n    )\n}\n","type":"text"},{"name":"data/r/db_module/db_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/db_module/db_functions.R\n\n#CHECK FOR MISSING ENTRIES FUNCTION\ncheck_for_missing_entries <- function(data, buffer_minutes = 2) {\n  missing_entries_info <- data.frame(\n    Table = character(),\n    MissingDateTime = as.POSIXct(character()),\n    stringsAsFactors = FALSE\n  )\n  \n  for (table_name in names(data)) {\n    df <- data[[table_name]]\n    \n    if (nrow(df) > 1) {\n      # Convert timestamps to POSIXct\n      df$DateTimeNum <- as.POSIXct(df$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n      df <- df %>% arrange(DateTimeNum)\n      \n      # Create sequence of expected hourly timestamps\n      # Now we don't subtract an hour when creating the sequence\n      sequence_start <- floor_date(min(df$DateTimeNum), \"hour\")\n      sequence_end <- ceiling_date(max(df$DateTimeNum), \"hour\")\n      \n      expected_times <- seq(from = sequence_start,\n                          to = sequence_end,\n                          by = \"hour\")\n      \n      # Modified check that doesn't add an hour to the comparison\n      is_time_present <- function(time) {\n        any(df$DateTimeNum >= time - minutes(buffer_minutes) &\n            df$DateTimeNum <= time + minutes(buffer_minutes))\n      }\n      \n      # Find missing timestamps\n      missing_times <- expected_times[!sapply(expected_times, is_time_present)]\n      \n      # Remove the first expected time if it's missing (to avoid false positive)\n      if (length(missing_times) > 0 && missing_times[1] == expected_times[1]) {\n        missing_times <- missing_times[-1]\n      }\n      \n      if (length(missing_times) > 0) {\n        missing_entries_info <- rbind(missing_entries_info, data.frame(\n          Table = table_name,\n          MissingDateTime = missing_times,\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n  }\n  \n  if (nrow(missing_entries_info) > 0) {\n    missing_entries_info\n  } else {\n    \"No missing entries detected.\"\n  }\n}\n# CHECK FOR BLANKS FUNCTION\ncheck_for_blanks <- function(data_list) {\n  # Initialize results dataframe\n  blank_info <- data.frame(\n    Table = character(),\n    Column = character(),\n    Row = integer(),\n    Issue = character(),\n    Value = character(),\n    DateTime = character(),\n    stringsAsFactors = FALSE\n  )\n  \n  # Helper function to safely convert to numeric\n  safe_as_numeric <- function(x) {\n    result <- suppressWarnings(as.numeric(x))\n    if (all(is.na(result))) return(x)\n    return(result)\n  }\n  \n  # Helper function to check for special NA values\n  is_special_na <- function(x) {\n    special_nas <- c(\"NA\", \"N/A\", \"n/a\", \"NULL\", \"null\", \"<NA>\", \"#N/A\", \"NaN\", \"\")\n    if (is.character(x)) {\n      return(trimws(x) %in% special_nas | trimws(x) == \"\")\n    }\n    return(FALSE)\n  }\n  \n  # First pass: identify active sensors for each station\n  for (table_name in names(data_list)) {\n    data <- data_list[[table_name]]\n    if (is.null(data) || nrow(data) == 0) next\n    \n    # Get all columns that have actual data (excluding standard metadata columns)\n    metadata_columns <- c(\"site_id\", \"STATION\", \"FIRE_CENTRE\", \"FIRE_ZONE\", \n                         \"LATITUDE\", \"LONGITUDE\", \"ELEVATION\", \"DateTimeNum\")\n    \n    data_columns <- setdiff(names(data), metadata_columns)\n    \n    # Check each relevant column\n    for (col in data_columns) {\n      # Convert to numeric if possible\n      values <- safe_as_numeric(data[[col]])\n      \n      # Check each row\n      for (row in 1:nrow(data)) {\n        value <- values[row]\n        \n        # Initialize issue as NULL\n        issue <- NULL\n        \n        # Series of checks\n        if (is.na(value)) {\n          issue <- \"NA value\"\n        } else if (is.nan(value)) {\n          issue <- \"NaN value\"\n        } else if (is.character(value) && trimws(value) == \"\") {\n          issue <- \"Empty string\"\n        } else if (is.character(value) && is_special_na(value)) {\n          issue <- \"Special NA value\"\n        } else if (is.infinite(value)) {\n          issue <- if (value > 0) \"Positive infinity\" else \"Negative infinity\"\n        } else if (is.character(value) && grepl(\"^\\\\s+$\", value)) {\n          issue <- \"Whitespace only\"\n        }\n        \n        # Check for invalid numeric values in numeric columns\n        if (is.null(issue) && !is.character(values)) {\n          numeric_value <- suppressWarnings(as.numeric(value))\n          if (is.na(numeric_value) && !is.na(value)) {\n            issue <- \"Invalid numeric value\"\n          }\n        }\n        \n        # Add to results if an issue was found\n        if (!is.null(issue)) {\n          blank_info <- rbind(blank_info, data.frame(\n            Table = table_name,\n            Column = col,\n            Row = row,\n            Issue = issue,\n            Value = as.character(value),\n            DateTime = as.character(data[row, \"DateTimeNum\"]),\n            stringsAsFactors = FALSE\n          ))\n        }\n      }\n    }\n  }\n  \n  # Return results\n  if (nrow(blank_info) > 0) {\n    # Sort by Table, DateTime, and Column for better readability\n    blank_info <- blank_info[order(blank_info$Table, blank_info$DateTime, blank_info$Column), ]\n    return(blank_info)\n  } else {\n    return(\"No blank or invalid values found in available columns.\")\n  }\n}","type":"text"},{"name":"data/r/db_module/db_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/db_module/db_output.R\n\nrender_missing_entries_output <- function(missing_entries_data, selected_station) {\n  missing_entries <- missing_entries_data()\n  \n  if (!is.data.frame(missing_entries) || nrow(missing_entries) == 0) {\n    cat(\"No missing entries detected.\\n\")\n    return(invisible())\n  }\n  \n  missing_entries <- missing_entries %>% \n    filter(!is.na(MissingDateTime)) %>%\n    arrange(Table, desc(MissingDateTime))\n  \n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    missing_entries <- missing_entries %>% filter(Table == selected_station)\n  }\n  \n  if (nrow(missing_entries) == 0) {\n    cat(\"No missing entries detected for the selected station(s).\\n\")\n    return(invisible())\n  }\n  \n  # Calculate summary statistics\n  station_summary <- missing_entries %>%\n    group_by(Table) %>%\n    summarise(\n      total_missing = n(),\n      earliest_missing = min(MissingDateTime),\n      latest_missing = max(MissingDateTime)\n    )\n  \n  for (station in unique(missing_entries$Table)) {\n    station_stats <- station_summary %>% filter(Table == station)\n    cleaned_station_name <- gsub(\"^dbo\\\\.\", \"\", station)\n    \n    cat(cleaned_station_name, \"\\n\", rep(\"-\", nchar(cleaned_station_name)), \"\\n\", sep = \"\")\n    cat(\"Total missing hourly entries:\", station_stats$total_missing, \"\\n\")\n    cat(\"Time span:\", format(station_stats$earliest_missing, \"%Y-%m-%d %H:00\"),\n        \"to\", format(station_stats$latest_missing, \"%Y-%m-%d %H:00\"), \"\\n\\n\")\n  }\n  \n  return(invisible())\n}\n\n#' Render the report status output table\n#' @param last_entry_time_check Reactive data frame with station status information\nrender_report_status_output <- function(last_entry_time_check) {\n  datatable(\n    last_entry_time_check,\n    options = list(\n      pageLength = 10,  \n      order = list(list(1, 'asc')),\n      columnDefs = list(\n        list(width = \"20%\", targets = c(0, 1, 2, 3))\n      ),\n      dom = '<\"top\"f>rt<\"bottom\"ip>',  # Customize the DOM positioning\n      language = list(\n        search = \"Filter stations:\"  # Customize search placeholder\n      )\n    ),\n    rownames = FALSE,\n    class = 'cell-border stripe hover'  # Add additional classes for better styling\n  ) %>%\n    formatStyle(\n      'Status',\n      backgroundColor = styleEqual(\n        c(\"Up to date\", \"Slightly delayed\", \"Delayed\", \"Significantly delayed\", \"No data\", \"Historical\"),\n        c('rgba(67, 160, 71, 0.15)',    # Soft green\n          'rgba(251, 192, 45, 0.15)',    # Warm yellow\n          'rgba(251, 140, 0, 0.15)',     # Soft orange\n          'rgba(229, 57, 53, 0.15)',     # Muted red\n          'rgba(117, 117, 117, 0.12)',   # Neutral grey\n          'rgba(66, 165, 245, 0.15)')    # Pleasant blue\n      ),\n      color = styleEqual(\n        c(\"Up to date\", \"Slightly delayed\", \"Delayed\", \"Significantly delayed\", \"No data\", \"Historical\"),\n        c('rgb(46, 125, 50)',     # Darker green text\n          'rgb(198, 140, 0)',     # Darker yellow text\n          'rgb(198, 85, 0)',      # Darker orange text\n          'rgb(183, 28, 28)',     # Darker red text\n          'rgb(66, 66, 66)',      # Darker grey text\n          'rgb(25, 118, 210)')    # Darker blue text\n      ),\n      fontWeight = styleEqual(\n        c(\"Up to date\", \"Slightly delayed\", \"Delayed\", \"Significantly delayed\", \"No data\", \"Historical\"),\n        rep('500', 6)\n      )\n    )\n}\n\nrender_space_weather_table <- function(space_weather_data, input) {\n  req(space_weather_data)\n  \n  # Get the earliest available alert date\n  earliest_alert_date <- min(as.Date(space_weather_data$issue_datetime))\n  \n  # Check if requested dates are before the earliest available alert\n  is_data_available <- if (input$fetch_type == \"last_n\") {\n    TRUE  # Always available for last n hours\n  } else if (input$fetch_type == \"by_date\") {\n    as.Date(input$select_date) >= earliest_alert_date\n  } else if (input$fetch_type == \"date_range\") {\n    as.Date(input$end_date) >= earliest_alert_date\n  } else {\n    TRUE\n  }\n  \n  # If data isn't available for the time period, return appropriate message\n  if (!is_data_available) {\n    return(datatable(\n      data.frame(\n        Message = sprintf(\n          \"Space weather alerts are only available from %s onwards. Historical data is not available through the NOAA SWPC API.\", \n          format(earliest_alert_date, \"%B %d, %Y\")\n        ),\n        DateTime = \"\"\n      ),\n      options = list(\n        dom = 't',  # Only show table, no pagination or search\n        ordering = FALSE\n      ),\n      rownames = FALSE,\n      colnames = c(\"Alert Details\", \"Issue Time\")\n    ))\n  }\n  \n  # Filter data based on user's fetch type\n  filtered_data <- if (input$fetch_type == \"last_n\") {\n    cutoff_time <- Sys.time() - hours(input$num_entries)\n    space_weather_data[space_weather_data$issue_datetime >= cutoff_time, ]\n    \n  } else if (input$fetch_type == \"by_date\") {\n    selected_date <- as.Date(input$select_date)\n    space_weather_data[as.Date(space_weather_data$issue_datetime) == selected_date, ]\n    \n  } else if (input$fetch_type == \"date_range\") {\n    start_date <- as.Date(input$start_date)\n    end_date <- as.Date(input$end_date)\n    space_weather_data[as.Date(space_weather_data$issue_datetime) >= start_date & \n                      as.Date(space_weather_data$issue_datetime) <= end_date, ]\n  } else {\n    space_weather_data\n  }\n  \n  # If no alerts in the time period (but data is available), return no alerts message\n  if (nrow(filtered_data) == 0) {\n    return(datatable(\n      data.frame(\n        Message = \"No space weather alerts during the selected time period\",\n        DateTime = \"\"\n      ),\n      options = list(\n        dom = 't',  # Only show table, no pagination or search\n        ordering = FALSE\n      ),\n      rownames = FALSE,\n      colnames = c(\"Alert Details\", \"Issue Time\")\n    ))\n  }\n  \n  # Function to format the message in HTML\n  format_message <- function(message) {\n    lines <- strsplit(message, \"\\n\")[[1]]\n    html_output <- '<div style=\"font-family: monospace; white-space: pre-wrap; padding: 1rem; background-color: white; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1rem;\">'\n    \n    for (line in lines) {\n      if (grepl(\":\", line) && !grepl(\"www\\\\.\", line)) {\n        parts <- strsplit(line, \":\", 2)[[1]]\n        if (length(parts) == 2) {\n          header <- trimws(parts[1])\n          content <- trimws(parts[2])\n          line <- sprintf('<div><strong>%s:<\/strong> %s<\/div>', header, content)\n        }\n      } else {\n        line <- sprintf('<div>%s<\/div>', line)\n      }\n      html_output <- paste0(html_output, line)\n    }\n    \n    html_output <- paste0(html_output, '<\/div>')\n    return(html_output)\n  }\n  \n  # Create display data frame with formatted messages\n  display_data <- data.frame(\n    Message = sapply(filtered_data$message, format_message),\n    DateTime = format(filtered_data$issue_datetime, \"%Y-%m-%d %H:%M:%S %Z\")\n  )\n  \n  # Create DataTable with formatted HTML\n  datatable(\n    display_data,\n    options = list(\n      pageLength = 2,\n      scrollX = TRUE,\n      order = list(list(1, 'desc')),  # Order by datetime descending\n      language = list(\n        zeroRecords = \"No space weather alerts during the selected time period\"\n      )\n    ),\n    escape = FALSE,  # Allow HTML rendering\n    rownames = FALSE,\n    colnames = c(\"Alert Details\", \"Issue Time\")\n  )\n}\n\n#' Render recent entries output\n#' @param WX_stations List of weather station data\n#' Render recent entries output\n#' @param WX_stations List of weather station data\nrender_recent_entries <- function(WX_stations) {\n  # If no stations data is provided, return a message\n  if (length(WX_stations) == 0) {\n    return(datatable(\n      data.frame(Message = \"No data available\"),\n      options = list(dom = 't'),\n      rownames = FALSE\n    ))\n  }\n  \n  # Initialize empty list to store processed data frames\n  all_data <- list()\n  \n  # Process each station's data\n  for (table in names(WX_stations)) {\n    data <- WX_stations[[table]]\n    \n    # Skip if data is NULL or has 0 rows\n    if (is.null(data) || nrow(data) == 0) {\n      next\n    }\n    \n    # Select only the relevant columns that exist in the data\n    columns_to_include <- c(\"DateTimeNum\", \"Temp\", \"Rh\", \"Rn_1\", \"Dir\", \"Wspd\")\n    columns_existing <- intersect(columns_to_include, names(data))\n    \n    if (length(columns_existing) > 0) {\n      # Create a subset of the data with only existing columns\n      station_data <- data[, columns_existing, drop = FALSE]\n      \n      # Add station name column\n      station_data$Station <- sub(\"^dbo\\\\.\", \"\", table)\n      \n      # Ensure all numeric columns are properly converted\n      numeric_cols <- c(\"Temp\", \"Rh\", \"Rn_1\", \"Dir\", \"Wspd\")\n      for (col in intersect(numeric_cols, names(station_data))) {\n        station_data[[col]] <- as.numeric(station_data[[col]])\n      }\n      \n      # Reorder columns to put Station first\n      col_order <- c(\"Station\", columns_existing)\n      station_data <- station_data[, col_order]\n      \n      # Add to list only if we have data\n      if (nrow(station_data) > 0) {\n        all_data[[table]] <- station_data\n      }\n    }\n  }\n  \n  # If no valid data was collected, return message\n  if (length(all_data) == 0) {\n    return(datatable(\n      data.frame(Message = \"No valid data available for display\"),\n      options = list(dom = 't'),\n      rownames = FALSE\n    ))\n  }\n  \n  # Combine all data frames\n  combined_data <- do.call(rbind, all_data)\n  \n  # Format the datetime column\n  combined_data$DateTimeNum <- format(\n    as.POSIXct(combined_data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\"),\n    \"%Y-%m-%d %H:%M\"\n  )\n  \n  # Create the DataTable\n  datatable(\n    combined_data,\n    options = list(\n      pageLength = 20,\n      order = list(list(0, 'asc'), list(1, 'desc')),\n      scrollX = TRUE,\n      dom = '<\"top\"f>rt<\"bottom\"ip>',\n      columnDefs = list(\n        list(\n          targets = c(\"Temp\", \"Rh\", \"Rn_1\", \"Dir\", \"Wspd\"),\n          render = JS(\"function(data, type, row) {\n            if (type === 'display') {\n              return data === null ? '-' : parseFloat(data).toFixed(1);\n            }\n            return data;\n          }\")\n        ),\n        list(\n          targets = '_all',\n          className = 'dt-nowrap'\n        )\n      )\n    ),\n    rownames = FALSE,\n    colnames = c(\n      \"Station\", \"DateTimeNum\", \"Temp\", \"Rh\", \"Rn_1\",\n      \"Dir\", \"Wspd\"\n    ),\n    class = 'cell-border stripe compact'\n  ) %>%\n    formatStyle(\n      'Station',\n      backgroundColor = styleEqual(\n        unique(combined_data$Station),\n        colorRampPalette(c(\"#f7fbff\", \"#deebf7\"))(length(unique(combined_data$Station)))\n      )\n    ) %>%\n    formatRound(\n      columns = c(\"Temp\", \"Rh\", \"Rn_1\", \"Dir\", \"Wspd\"),\n      digits = 1\n    )\n}\n\n#' Render check for blanks output\n#' @param WX_stations List of weather station data\n# Function to render blank check output\n#' Render check for blanks output\n#' @param WX_stations List of weather station data\nrender_check_for_blanks <- function(wx_stations) {\n  # Check if the input is valid\n  if (is.null(wx_stations) || length(wx_stations) == 0) {\n    return(\"No data available for analysis.\")\n  }\n  \n  # Metadata columns to exclude from analysis\n  exclude_cols <- c(\"site_id\", \"STATION\", \"FIRE_CENTRE\", \"FIRE_ZONE\", \"LATITUDE\", \"LONGITUDE\", \"ELEVATION\", \"DateTimeNum\")\n  \n  # Initialize output text\n  output_text <- \"PARTIAL SENSOR FAILURE ANALYSIS\\n\"\n  output_text <- paste0(output_text, \"Identifying timestamps where some sensors report while others show NA\\n\\n\")\n  \n  # Process each station\n  for (station_name in names(wx_stations)) {\n    station_data <- wx_stations[[station_name]]\n    \n    # Skip if station data is NULL or empty\n    if (is.null(station_data) || nrow(station_data) == 0) {\n      next\n    }\n    \n    # Get list of sensor columns (excluding metadata)\n    sensor_cols <- setdiff(names(station_data), exclude_cols)\n    \n    if (length(sensor_cols) == 0) {\n      next\n    }\n    \n    # Track partial failures by sensor\n    partial_failures <- list()\n    \n    # Check each row (timestamp)\n    for (i in 1:nrow(station_data)) {\n      # Count NA values in this row\n      na_count <- 0\n      non_na_count <- 0\n      \n      for (col in sensor_cols) {\n        if (is.na(station_data[i, col])) {\n          na_count <- na_count + 1\n        } else {\n          non_na_count <- non_na_count + 1\n        }\n      }\n      \n      # If some sensors report while others don't, record the failing sensors\n      if (na_count > 0 && non_na_count > 0) {\n        timestamp <- station_data$DateTimeNum[i]\n        \n        for (col in sensor_cols) {\n          if (is.na(station_data[i, col])) {\n            if (is.null(partial_failures[[col]])) {\n              partial_failures[[col]] <- character(0)\n            }\n            partial_failures[[col]] <- c(partial_failures[[col]], timestamp)\n          }\n        }\n      }\n    }\n    \n    # Report findings for this station\n    if (length(partial_failures) > 0) {\n      output_text <- paste0(output_text, \"=== \", station_name, \" ===\\n\")\n      \n      for (sensor in names(partial_failures)) {\n        failure_count <- length(partial_failures[[sensor]])\n        output_text <- paste0(output_text, sensor, \": \", failure_count, \" partial failures\\n\")\n        \n        # Show up to 5 example timestamps\n        if (failure_count > 0) {\n          show_count <- min(5, failure_count)\n          examples <- partial_failures[[sensor]][1:show_count]\n          \n          output_text <- paste0(output_text, \"  Examples: \", paste(examples, collapse=\", \"))\n          \n          if (failure_count > show_count) {\n            output_text <- paste0(output_text, \" (+ \", failure_count - show_count, \" more)\")\n          }\n          output_text <- paste0(output_text, \"\\n\")\n        }\n      }\n      output_text <- paste0(output_text, \"\\n\")\n    }\n  }\n  \n  # If no issues found across all stations\n  if (output_text == \"PARTIAL SENSOR FAILURE ANALYSIS\\nIdentifying timestamps where some sensors report while others show NA\\n\\n\") {\n    output_text <- paste0(output_text, \"No partial sensor failures detected. When stations report, all sensors are providing data.\\n\")\n  }\n  \n  return(output_text)\n}","type":"text"},{"name":"data/r/power_module/power_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/power_module/power_charts.R\n\ncreate_vbat_waterfall_plot <- function(power_data, selected_station) {\n  if (is.null(power_data) || selected_station == \"All Stations\") {\n    return(plot_ly() %>% \n             layout(title = \"Select a station to view battery voltage changes\"))\n  }\n\n  station_data <- power_data[[selected_station]]$data\n\n  if (is.null(station_data) || \n      !all(c(\"Vbat\", \"Vslr\", \"Temp\") %in% names(station_data)) || \n      nrow(station_data) == 0 ||\n      all(is.na(station_data$Vbat))) {\n    return(plot_ly() %>% \n             layout(title = \"No battery voltage data available for this station\"))\n  }\n\n  # Convert DateTimeNum to POSIXct if needed\n  if (!inherits(station_data$DateTimeNum, \"POSIXct\")) {\n    station_data$DateTimeNum <- as.POSIXct(station_data$DateTimeNum, \n                                          format = \"%Y-%b-%d %H:%M:%S\",\n                                          tz = \"UTC\")\n  }\n\n  # Sort data by time and remove NA values\n  station_data <- station_data[order(station_data$DateTimeNum), ]\n  valid_data <- !is.na(station_data$Vbat) & !is.na(station_data$DateTimeNum)\n  station_data <- station_data[valid_data, ]\n\n  if (nrow(station_data) < 2) {\n    return(plot_ly() %>% \n             layout(title = \"Insufficient valid data points for visualization\"))\n  }\n\n  # Initialize plot data\n  initial_value <- station_data$Vbat[1]\n  plot_data <- data.frame(\n    measure = station_data$DateTimeNum[-1],\n    value = diff(station_data$Vbat),\n    vslr = station_data$Vslr[-1],\n    temp = station_data$Temp[-1]\n  )\n\n  # Add type column for coloring\n  plot_data$type <- ifelse(plot_data$value >= 0, \"charging\", \"discharging\")\n\n  # Calculate cumulative sums starting from initial value\n  plot_data$cumulative <- initial_value + cumsum(plot_data$value)\n\n  # Create text labels for the bars\n  plot_data$bar_text <- sprintf(\"%+.2fV\", plot_data$value)\n\n  # Calculate y-axis ranges for battery voltage\n  battery_values <- c(plot_data$cumulative - plot_data$value, plot_data$cumulative)\n  batt_y_min <- min(battery_values, na.rm = TRUE)\n  batt_y_max <- max(battery_values, na.rm = TRUE)\n  batt_y_range <- batt_y_max - batt_y_min\n  batt_y_padding <- batt_y_range * 0.1\n  \n  # Separate y-axis range for solar voltage\n  solar_y_min <- if(all(is.na(plot_data$vslr))) 0 else min(plot_data$vslr, na.rm = TRUE)\n  solar_y_max <- if(all(is.na(plot_data$vslr))) 20 else max(plot_data$vslr, na.rm = TRUE)\n  solar_y_range <- solar_y_max - solar_y_min\n  solar_y_padding <- solar_y_range * 0.1\n\n  # Create hover text\n  plot_data$hover_text <- sprintf(\n    \"Time: %s\\nBattery Voltage: %.2f V\\nChange: %+.2f V\\nSolar Voltage: %.2f V\",\n    format(plot_data$measure, \"%Y-%m-%d %H:%M:%S\"),\n    plot_data$cumulative,\n    plot_data$value,\n    ifelse(is.na(plot_data$vslr), 0, plot_data$vslr)\n  )\n\n  # Create the plot with dual y-axes\n  p <- plot_ly()\n  \n  # Add 12V reference line using battery voltage axis\n  p <- p %>% add_trace(\n    x = range(plot_data$measure),\n    y = c(12, 12),\n    type = \"scatter\",\n    mode = \"lines\",\n    line = list(\n      color = \"black\",\n      width = 0.5\n    ),\n    showlegend = FALSE,\n    hoverinfo = \"none\",\n    yaxis = \"y\"\n  )\n\n  # Add background shading for solar voltage\n  for(i in 1:(nrow(plot_data) - 1)) {\n    norm_vslr <- if (is.na(plot_data$vslr[i])) {\n      0\n    } else {\n      (plot_data$vslr[i] - solar_y_min) / solar_y_range\n    }\n    \n    color <- if (is.na(norm_vslr)) {\n      \"rgba(200, 200, 200, 0.1)\"\n    } else {\n      r <- round(30 + (255 - 30) * norm_vslr)\n      g <- round(144 + (255 - 144) * norm_vslr)\n      b <- round(255 - 220 * norm_vslr)\n      opacity <- 0.3\n      sprintf(\"rgba(%d, %d, %d, %f)\", r, g, b, opacity)\n    }\n    \n    p <- p %>% add_trace(\n      x = c(plot_data$measure[i], plot_data$measure[i],\n            plot_data$measure[i+1], plot_data$measure[i+1], \n            plot_data$measure[i]),\n      y = c(batt_y_min - batt_y_padding, batt_y_max + batt_y_padding, \n            batt_y_max + batt_y_padding, batt_y_min - batt_y_padding, \n            batt_y_min - batt_y_padding),\n      type = \"scatter\",\n      mode = \"lines\",\n      fill = \"toself\",\n      fillcolor = color,\n      line = list(width = 0, color = \"transparent\"),\n      showlegend = FALSE,\n      hoverinfo = \"none\",\n      name = \"\"\n    )\n  }\n\n  # Add solar voltage trace on secondary y-axis\n  if (!all(is.na(plot_data$vslr))) {\n    p <- p %>% add_trace(\n      data = plot_data,\n      x = ~measure,\n      y = ~vslr,\n      type = \"scatter\",\n      mode = \"lines\",\n      line = list(\n        color = \"rgba(255, 215, 0, 0.8)\",  # Golden yellow for solar\n        width = 2,\n        dash = \"dot\"  \n      ),\n      name = \"Solar Voltage\",\n      yaxis = \"y3\",  # Use separate y-axis for solar voltage\n      hovertemplate = paste0(\n        \"Time: %{x|%Y-%m-%d %H:%M:%S}<br>\",\n        \"Solar Voltage: %{y:.2f}V\",\n        \"<extra><\/extra>\"\n      )\n    )\n  }\n\n  # Add temperature trace if temperature data exists\n  if (!all(is.na(plot_data$temp))) {\n    p <- p %>% add_trace(\n      data = plot_data,\n      x = ~measure,\n      y = ~temp,\n      type = \"scatter\",\n      mode = \"lines\",\n      line = list(\n        color = \"rgba(255, 165, 0, 0.5)\",\n        width = 1,\n        dash = \"dash\"\n      ),\n      name = \"Temperature\",\n      yaxis = \"y2\",\n      hovertemplate = paste0(\n        \"Time: %{x|%Y-%m-%d %H:%M:%S}<br>\",\n        \"Temperature: %{y:.1f}°C<br>\",\n        \"Solar Voltage: \", sprintf(\"%.2f V\", plot_data$vslr),\n        \"<extra><\/extra>\"\n      )\n    )\n  }\n\n  # Add the main voltage change bars\n  p <- p %>% add_trace(\n    data = plot_data,\n    x = ~measure,\n    y = ~value,\n    base = ~cumulative - value,\n    type = \"bar\",\n    marker = list(\n      color = ~case_when(\n        type == \"charging\" ~ \"#00CC00\",\n        type == \"discharging\" ~ \"#FF4444\"\n      ),\n      opacity = 1\n    ),\n    text = ~bar_text,\n    textposition = \"inside\",\n    insidetextanchor = \"middle\",\n    textangle = 0,\n    textfont = list(\n      color = \"white\",\n      size = 10\n    ),\n    hovertext = ~hover_text,\n    hoverinfo = \"text\",\n    name = \"Battery Change\",\n    yaxis = \"y\"\n  )\n\n  # Complete the layout with separate y-axes\n  p <- p %>% layout(\n    title = list(\n      text = paste(\"Battery and Solar Voltage -\", selected_station),\n      font = list(size = 18)\n    ),\n    xaxis = list(\n      title = \"Time\",\n      tickangle = -45,\n      tickformat = \"%Y-%m-%d %H:%M:%S\",\n      showgrid = TRUE,\n      gridcolor = \"#E2E2E2\"\n    ),\n    yaxis = list(\n      title = \"Battery Voltage (V)\",\n      zeroline = FALSE,\n      showgrid = TRUE,\n      gridcolor = \"#E2E2E2\",\n      range = c(batt_y_min - batt_y_padding, batt_y_max + batt_y_padding)\n    ),\n    yaxis2 = list(\n      title = \"Temperature (°C)\",\n      overlaying = \"y\",\n      side = \"right\",\n      showgrid = FALSE,\n      zeroline = FALSE\n    ),\n    yaxis3 = list(\n      title = \"Solar Voltage (V)\",\n      overlaying = \"y\",\n      side = \"right\",\n      position = 0.85,  # Position the axis slightly left of the temperature axis\n      showgrid = FALSE,\n      zeroline = FALSE,\n      range = c(solar_y_min - solar_y_padding, solar_y_max + solar_y_padding)\n    ),\n    showlegend = TRUE,\n    plot_bgcolor = \"white\",\n    paper_bgcolor = \"white\",\n    margin = list(b = 120, l = 80, r = 120),\n    legend = list(\n      orientation = \"h\",\n      x = 0.5,\n      y = -0.2,\n      xanchor = \"center\",\n      yanchor = \"top\"\n    )\n  )\n\n  return(p)\n}\n\n# Function to create normalized voltage trends plot\ncreate_vbat_trends_plot <- function(trend_data, selected_stations = NULL) {\n  if (is.null(trend_data) || length(trend_data) == 0) {\n    return(plot_ly() %>%\n             layout(title = \"No trend data available\",\n                    xaxis = list(title = \"Time\"),\n                    yaxis = list(title = \"Battery Voltage (V)\"),\n                    plot_bgcolor = \"#f8f8f8\",\n                    paper_bgcolor = \"#f8f8f8\"))\n  }\n  \n  # Handle station selection\n  plot_stations <- if (is.null(selected_stations) || \"All Stations\" %in% selected_stations) {\n    names(trend_data)\n  } else {\n    intersect(selected_stations, names(trend_data))\n  }\n  \n  if (length(plot_stations) == 0) {\n    return(plot_ly() %>%\n             layout(title = \"No stations selected\",\n                    xaxis = list(title = \"Time\"),\n                    yaxis = list(title = \"Battery Voltage (V)\"),\n                    plot_bgcolor = \"#f8f8f8\",\n                    paper_bgcolor = \"#f8f8f8\"))\n  }\n  \n  # Initialize plot\n  p <- plot_ly()\n  \n  # Enhanced color palette with better contrast\n  colors <- c(\"#1f77b4\", \"#d62728\", \"#2ca02c\", \"#ff7f0e\", \"#9467bd\",\n              \"#8c564b\", \"#e377c2\", \"#17becf\", \"#bcbd22\", \"#7f7f7f\")\n  \n  # Find overall time range for all data\n  all_times <- vector(\"list\", length(plot_stations))\n  for (station_idx in seq_along(plot_stations)) {\n    station <- plot_stations[station_idx]\n    station_data <- trend_data[[station]]\n    \n    if (!is.null(station_data) && nrow(station_data) > 0) {\n      times <- if (!inherits(station_data$DateTimeNum, \"POSIXct\")) {\n        as.POSIXct(station_data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n      } else {\n        station_data$DateTimeNum\n      }\n      all_times[[station_idx]] <- times\n    }\n  }\n  \n  # Calculate overall time range\n  all_times <- do.call(c, all_times)\n  time_range <- range(all_times, na.rm = TRUE)\n  \n  # Add critical voltage reference line with proper time range but hidden from legend\n  p <- p %>% add_trace(\n    x = time_range,\n    y = c(12, 12),\n    type = \"scatter\",\n    mode = \"lines\",\n    line = list(color = \"red\", width = 1, dash = \"dash\"),\n    showlegend = FALSE,\n    hoverinfo = \"skip\"\n  )\n  \n  # Process and plot data for each station\n  for (station_idx in seq_along(plot_stations)) {\n    station <- plot_stations[station_idx]\n    station_data <- trend_data[[station]]\n    \n    if (!is.null(station_data) && nrow(station_data) > 0) {\n      # Split data by trend_id\n      trend_splits <- split(station_data, station_data$trend_id)\n      \n      for (trend_id in names(trend_splits)) {\n        trend_subset <- trend_splits[[trend_id]]\n        \n        if (nrow(trend_subset) < 2) next\n        \n        # Ensure proper datetime format\n        if (!inherits(trend_subset$DateTimeNum, \"POSIXct\")) {\n          trend_subset$plot_time <- as.POSIXct(trend_subset$DateTimeNum, \n                                              format = \"%Y-%b-%d %H:%M:%S\",\n                                              tz = \"UTC\")\n        } else {\n          trend_subset$plot_time <- trend_subset$DateTimeNum\n        }\n        \n        # Sort by time\n        trend_subset <- trend_subset[order(trend_subset$plot_time), ]\n        \n        # Calculate metrics for the trend\n        initial_voltage <- trend_subset$Vbat[1]\n        final_voltage <- trend_subset$Vbat[nrow(trend_subset)]\n        time_diff_hours <- as.numeric(difftime(max(trend_subset$plot_time), \n                                             min(trend_subset$plot_time), \n                                             units = \"hours\"))\n        voltage_change <- final_voltage - initial_voltage\n        rate_of_change <- if(time_diff_hours > 0) voltage_change / time_diff_hours else 0\n        \n        # Calculate line width based on rate of change\n        normalized_rate <- abs(rate_of_change) / 0.5  # Normalize against 0.5V/hr\n        line_width <- 1 + (normalized_rate * 2)  # Scale from 1 to 3 pixels\n        \n        # Create hover text with original information\n        hover_text <- sprintf(\n          \"Station: %s<br>Start Time: %s<br>End Time: %s<br>Initial Voltage: %.2f V<br>Final Voltage: %.2f V<br>Total Change: %.1f%%<br>Rate: %.3f V/hr\",\n          station,\n          format(min(trend_subset$plot_time), \"%Y-%m-%d %H:%M\"),\n          format(max(trend_subset$plot_time), \"%Y-%m-%d %H:%M\"),\n          initial_voltage,\n          final_voltage,\n          (voltage_change / initial_voltage) * 100,\n          rate_of_change\n        )\n        \n        # Add trace for this trend with enhanced styling\n        color_index <- ((station_idx - 1) %% length(colors)) + 1\n        p <- p %>% add_trace(\n          data = trend_subset,\n          x = ~plot_time,\n          y = ~Vbat,\n          type = 'scatter',\n          mode = 'lines+markers',\n          name = sprintf(\"%s - Trend %s (%.3f V/hr)\", station, trend_id, rate_of_change),\n          text = hover_text,\n          hoverinfo = 'text',\n          line = list(\n            color = colors[color_index],\n            width = line_width,\n            shape = 'spline'\n          ),\n          marker = list(\n            size = 6,\n            color = colors[color_index]\n          ),\n          showlegend = TRUE\n        )\n      }\n    }\n  }\n  \n  # Calculate time padding (5% of total range)\n  time_padding <- as.numeric(difftime(time_range[2], time_range[1], units = \"secs\")) * 0.05\n  x_min <- time_range[1] - time_padding\n  x_max <- time_range[2] + time_padding\n  \n  # Enhanced layout with proper time range\n  p %>% layout(\n    title = list(\n      text = \"Decreasing Vbat Trends\",\n      font = list(size = 18)\n    ),\n    xaxis = list(\n      title = \"Time\",\n      gridcolor = '#E2E2E2',\n      showgrid = TRUE,\n      zeroline = FALSE,\n      tickformat = \"%Y-%m-%d %H:%M\",\n      tickangle = -45,\n      range = c(x_min, x_max)\n    ),\n    yaxis = list(\n      title = \"Battery Voltage (V)\",\n      gridcolor = '#E2E2E2',\n      showgrid = TRUE,\n      zeroline = TRUE,\n      zerolinecolor = '#969696'\n    ),\n    showlegend = TRUE,\n    hovermode = \"closest\",\n    legend = list(\n      orientation = \"v\",\n      x = 1.02,\n      y = 1,\n      xanchor = \"left\",\n      yanchor = \"top\",\n      bgcolor = \"rgba(255, 255, 255, 0.9)\",\n      bordercolor = \"rgba(0, 0, 0, 0.2)\",\n      borderwidth = 1\n    ),\n    plot_bgcolor = \"#f8f8f8\",\n    paper_bgcolor = \"#f8f8f8\",\n    margin = list(t = 50, b = 50, l = 60, r = 150)\n  )\n}\n","type":"text"},{"name":"data/r/power_module/power_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/power_module/power_functions.R\n\n# Function to identify decreasing Vbat trends\nidentify_decreasing_vbat_trends <- function(station_data, min_duration = 3, threshold = -0.5) {\n  # Initial data validation\n  if (is.null(station_data) || \n      !all(c(\"DateTimeNum\", \"Vbat\", \"Temp\") %in% names(station_data)) ||\n      nrow(station_data) < min_duration) {\n    return(NULL)\n  }\n  \n  # Ensure Vbat is numeric\n  station_data$Vbat <- as.numeric(station_data$Vbat)\n  \n  # Remove NA values - keep original order (newest to oldest)\n  valid_data <- !is.na(station_data$Vbat) & !is.na(station_data$Temp)\n  if (sum(valid_data) < min_duration) {\n    return(NULL)\n  }\n  \n  station_data <- station_data[valid_data, ]\n  n <- nrow(station_data)\n  \n  # Initialize variables for trend detection\n  trends <- data.frame(\n    start_idx = integer(),\n    end_idx = integer(),\n    duration = integer(),\n    start_voltage = numeric(),\n    end_voltage = numeric(),\n    voltage_change = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  current_trend_start <- 1\n  \n  if (n < min_duration) {\n    return(trends)\n  }\n  \n  for (i in 2:n) {\n    if (is.na(station_data$Vbat[i]) || is.na(station_data$Vbat[i-1])) {\n      current_trend_start <- i\n      next\n    }\n    \n    # Convert Vbat values to numeric explicitly before comparison\n    current_voltage <- as.numeric(station_data$Vbat[i])\n    prev_voltage <- as.numeric(station_data$Vbat[i-1])\n    \n    if (is.na(current_voltage) || is.na(prev_voltage)) {\n      current_trend_start <- i\n      next\n    }\n    \n    # Since data is newest to oldest, we reverse the comparison\n    voltage_change <- current_voltage - prev_voltage\n    \n    # If voltage decreases or stays same, end current trend\n    if (voltage_change <= 0) {\n      duration <- i - current_trend_start\n      if (duration >= min_duration) {\n        # Switch start and end points since we're going backwards in time\n        start_v <- as.numeric(station_data$Vbat[i-1])\n        end_v <- as.numeric(station_data$Vbat[current_trend_start])\n        total_change <- end_v - start_v\n        \n        if (!is.na(total_change) && total_change <= threshold) {\n          trends <- rbind(trends, data.frame(\n            start_idx = i-1,  # This is actually the earlier time\n            end_idx = current_trend_start,  # This is the later time\n            duration = duration,\n            start_voltage = start_v,  # Earlier voltage\n            end_voltage = end_v,  # Later voltage\n            voltage_change = total_change,\n            stringsAsFactors = FALSE\n          ))\n        }\n      }\n      current_trend_start <- i\n    }\n  }\n  \n  # Check final trend\n  duration <- n - current_trend_start + 1\n  if (duration >= min_duration) {\n    start_v <- as.numeric(station_data$Vbat[n])\n    end_v <- as.numeric(station_data$Vbat[current_trend_start])\n    total_change <- end_v - start_v\n    \n    if (!is.na(total_change) && total_change <= threshold) {\n      trends <- rbind(trends, data.frame(\n        start_idx = n,  # Earlier time\n        end_idx = current_trend_start,  # Later time\n        start_voltage = start_v,  # Earlier voltage\n        end_voltage = end_v,  # Later voltage\n        duration = duration,\n        voltage_change = total_change,\n        stringsAsFactors = FALSE\n      ))\n    }\n  }\n  \n  return(trends)\n}\n\n# Function to format the trend output\nformat_vbat_trend_output <- function(station_name, station_data, trends) {\n  if (is.null(trends) || nrow(trends) == 0) {\n    return(NULL)\n  }\n  \n  output_text <- sprintf(\"\\nDecreasing Battery Voltage Trends for %s\\n\", station_name)\n  output_text <- paste0(output_text, \n                       paste(rep(\"=\", nchar(sprintf(\"Decreasing Battery Voltage Trends for %s\", station_name))), \n                             collapse = \"\"), \"\\n\")\n  \n  for (i in 1:nrow(trends)) {\n    trend <- trends[i,]\n    start_time <- station_data$DateTimeNum[trend$start_idx]\n    end_time <- station_data$DateTimeNum[trend$end_idx]\n    \n    # Safely get temperature values with error handling\n    start_temp <- tryCatch({\n      temp <- station_data$Temp[trend$start_idx]\n      if (is.null(temp) || is.na(temp)) NA else temp\n    }, error = function(e) NA)\n    \n    end_temp <- tryCatch({\n      temp <- station_data$Temp[trend$end_idx]\n      if (is.null(temp) || is.na(temp)) NA else temp\n    }, error = function(e) NA)\n    \n    # Build output text with conditional temperature information\n    output_text <- paste0(output_text,\n      sprintf(\"\\nTrend Period %d:\\n\", i),\n      sprintf(\"Start Time: %s\\n\", start_time),\n      sprintf(\"End Time: %s\\n\", end_time),\n      sprintf(\"Duration: %d hours\\n\", trend$duration),\n      sprintf(\"Start Voltage: %.2f V\\n\", trend$start_voltage),\n      sprintf(\"End Voltage: %.2f V\\n\", trend$end_voltage),\n      sprintf(\"Total Change: %.2f V\\n\", trend$voltage_change)\n    )\n    \n    # Add temperature information only if valid temperatures are available\n    if (!any(is.na(c(start_temp, end_temp)))) {\n      output_text <- paste0(output_text,\n        sprintf(\"Temperature Range: %.1f°C to %.1f°C\\n\", start_temp, end_temp)\n      )\n    }\n    \n    output_text <- paste0(output_text, \"----------------------------------------\\n\")\n  }\n  \n  return(output_text)\n}\n\n# Main function to analyze all stations\nanalyze_vbat_trends <- function(power_data) {\n  if (is.null(power_data) || length(power_data) == 0) {\n    return(\"No power data available\")\n  }\n  \n  output_text <- \"Battery Voltage Analysis\\n\\n\"\n  output_text <- paste0(output_text, \n                       \"Identifies battery voltage drops that decrease > 0.5V over at least 3 consecutive readings.\\n\\n\")\n  output_text <- paste0(output_text, \"============================\\n\")\n  \n  found_trends <- FALSE\n  \n  for (station_name in names(power_data)) {\n    if (is.null(power_data[[station_name]]) || \n        is.null(power_data[[station_name]]$data)) {\n      next\n    }\n    \n    station_data <- power_data[[station_name]]$data\n    \n    if (!all(c(\"Vbat\", \"Temp\") %in% names(station_data))) {\n      next\n    }\n    \n    trends <- identify_decreasing_vbat_trends(station_data)\n    \n    if (!is.null(trends) && nrow(trends) > 0) {\n      found_trends <- TRUE\n      trend_output <- format_vbat_trend_output(station_name, station_data, trends)\n      if (!is.null(trend_output)) {\n        output_text <- paste0(output_text, trend_output)\n      }\n    }\n  }\n  \n  if (!found_trends) {\n    output_text <- paste0(output_text, \"\\nNo significant decreasing voltage trends detected in selected stations.\")\n  }\n  \n  return(output_text)\n}\n\n# Function to identify decreasing trends and prepare data\nprepare_trend_data <- function(power_data) {\n  if (is.null(power_data) || length(power_data) == 0) {\n    return(NULL)\n  }\n  \n  all_trends <- list()\n  \n  for (station_name in names(power_data)) {\n    if (is.null(power_data[[station_name]]) || \n        is.null(power_data[[station_name]]$data)) {\n      next\n    }\n    \n    station_data <- power_data[[station_name]]$data\n    \n    if (!all(c(\"Vbat\", \"Temp\") %in% names(station_data))) {\n      next\n    }\n    \n    trends <- identify_decreasing_vbat_trends(station_data)\n    \n    if (!is.null(trends) && nrow(trends) > 0) {\n      station_trends <- list()\n      \n      for (i in 1:nrow(trends)) {\n        trend <- trends[i,]\n        trend_points <- station_data[seq(trend$end_idx, trend$start_idx), ]\n        trend_points$trend_id <- i\n        trend_points$station <- station_name\n        station_trends[[i]] <- trend_points\n      }\n      \n      if (length(station_trends) > 0) {\n        all_trends[[station_name]] <- do.call(rbind, station_trends)\n      }\n    }\n  }\n  \n  return(all_trends)\n}\n\n\n# LOW VBAT FUNCTION\n# Function to monitor battery voltage and generate alerts\nmonitor_battery_voltage <- function(power_data) {\n  output_text <- \"\"\n  \n  for (station_name in names(power_data)) {\n    station_data <- power_data[[station_name]]$data\n    \n    if (!all(c(\"Vbat\", \"Ibat\", \"Vslr\", \"Islr\", \"Temp\") %in% names(station_data))) {\n      next\n    }\n    \n    # Find instances where Vbat < 12\n    low_voltage_instances <- which(station_data$Vbat < 12)\n    \n    if (length(low_voltage_instances) > 0) {\n      # Calculate summary statistics\n      vbat_stats <- list(\n        min_voltage = min(station_data$Vbat[low_voltage_instances], na.rm = TRUE),\n        max_voltage = max(station_data$Vbat[low_voltage_instances], na.rm = TRUE),\n        mean_voltage = mean(station_data$Vbat[low_voltage_instances], na.rm = TRUE),\n        min_temp = min(station_data$Temp[low_voltage_instances], na.rm = TRUE),\n        max_temp = max(station_data$Temp[low_voltage_instances], na.rm = TRUE)\n      )\n      \n      # Get timestamps for first and last occurrence\n      first_occurrence <- station_data$DateTimeNum[low_voltage_instances[length(low_voltage_instances)]]\n      last_occurrence <- station_data$DateTimeNum[low_voltage_instances[1]]\n      \n      output_text <- paste0(output_text, \n                           \"\\nLow Battery Voltage Alert for \", station_name, \"\\n\",\n                           \"=============================================\\n\",\n                           sprintf(\"Number of Alerts: %d\\n\", length(low_voltage_instances)),\n                           sprintf(\"Time Period: %s to %s\\n\", first_occurrence, last_occurrence),\n                           sprintf(\"Voltage Range: %.2f V to %.2f V (avg: %.2f V)\\n\", \n                                 vbat_stats$min_voltage, vbat_stats$max_voltage, vbat_stats$mean_voltage),\n                           sprintf(\"Temperature Range: %.1f°C to %.1f°C\\n\\n\", \n                                 vbat_stats$min_temp, vbat_stats$max_temp))\n    }\n  }\n  \n  if (output_text == \"\") {\n    return(\"No low battery voltage alerts (all stations reporting Vbat ≥ 12V)\")\n  }\n  \n  return(output_text)\n}\n","type":"text"},{"name":"data/r/power_module/power_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/power_module/power_output.R\n\n#' Render power status output\n#' @param input Shiny input object\n#' @param all_power_data Reactive expression containing power data\nrender_power_status_output <- function(input, all_power_data) {\n  req(input$power_station_select)\n  power_data <- all_power_data()\n  \n  if (input$power_station_select == \"All Stations\") {\n    cat(\"Select a station to view power status details\\n\")\n    return(invisible())\n  }\n  \n  station_data <- power_data[[input$power_station_select]]\n  \n  # Basic validation\n  if (is.null(station_data) || is.null(station_data$data) || nrow(station_data$data) == 0) {\n    cat(\"No power data available for this station\\n\")\n    return(invisible())\n  }\n  \n  data <- station_data$data\n  \n  # Validate required columns exist\n  required_columns <- c(\"Vbat\", \"Ibat\", \"Vslr\", \"Islr\")\n  missing_columns <- required_columns[!required_columns %in% names(data)]\n  \n  if (length(missing_columns) > 0) {\n    cat(sprintf(\"Missing required power measurements: %s\\n\", \n                paste(missing_columns, collapse = \", \")))\n    return(invisible())\n  }\n  \n  # Check for valid data in required columns\n  all_na <- sapply(required_columns, function(col) all(is.na(data[[col]])))\n  if (any(all_na)) {\n    cat(sprintf(\"No valid measurements for: %s\\n\", \n                paste(names(all_na)[all_na], collapse = \", \")))\n    return(invisible())\n  }\n  \n  # Have valid data to process\n  cat(sprintf(\"%s\\n\", input$power_station_select))\n\nsafe_stats <- function(x, fn, non_zero_only = FALSE) {\n  if (all(is.na(x))) return(NA)\n  \n  if (non_zero_only) {\n    x <- x[!is.na(x) & x != 0]\n    if (length(x) == 0) return(NA)\n  }\n  \n  fn(x, na.rm = TRUE)\n}\n  \n  # Calculate statistics - note the non_zero_only parameter for solar voltage\n  stats <- list(\n    battery = list(\n      mean_voltage = safe_stats(data$Vbat, mean),\n      median_voltage = safe_stats(data$Vbat, median),\n      min_voltage = safe_stats(data$Vbat, min),\n      max_voltage = safe_stats(data$Vbat, max),\n      mean_current = safe_stats(data$Ibat, mean),\n      median_current = safe_stats(data$Ibat, median),\n      min_current = safe_stats(data$Ibat, min),\n      max_current = safe_stats(data$Ibat, max)\n    ),\n    solar = list(\n      mean_voltage = safe_stats(data$Vslr, mean, non_zero_only = TRUE),\n      median_voltage = safe_stats(data$Vslr, median, non_zero_only = TRUE),\n      max_voltage = safe_stats(data$Vslr, max),\n      mean_current = safe_stats(data$Islr, mean),\n      median_current = safe_stats(data$Islr, median),\n      max_current = safe_stats(data$Islr, max)\n    )\n  )\n  \n  # Find timestamps for min/max values\n  if (!all(is.na(data$Vbat))) {\n    min_v_idx <- which.min(data$Vbat)\n    max_v_idx <- which.max(data$Vbat)\n    stats$battery$min_voltage_time <- data$DateTimeNum[min_v_idx]\n    stats$battery$max_voltage_time <- data$DateTimeNum[max_v_idx]\n  }\n  \n  if (!all(is.na(data$Ibat))) {\n    min_i_idx <- which.min(data$Ibat)\n    max_i_idx <- which.max(data$Ibat)\n    stats$battery$min_current_time <- data$DateTimeNum[min_i_idx]\n    stats$battery$max_current_time <- data$DateTimeNum[max_i_idx]\n  }\n  \n  # Output formatted statistics\n  cat(\"\\nBattery Info:\\n\")\n  cat(\"-------------\\n\")\n  cat(sprintf(\"Voltage:\\n\"))\n  cat(sprintf(\"  Average: %.2f V\\n\", stats$battery$mean_voltage))\n  cat(sprintf(\"  Median:  %.2f V\\n\", stats$battery$median_voltage))\n  if (!is.na(stats$battery$min_voltage)) {\n    cat(sprintf(\"  Minimum: %.2f V at %s\\n\", \n                stats$battery$min_voltage, \n                stats$battery$min_voltage_time))\n    cat(sprintf(\"  Maximum: %.2f V at %s\\n\", \n                stats$battery$max_voltage,\n                stats$battery$max_voltage_time))\n  }\n  \n  cat(sprintf(\"\\nCurrent:\\n\"))\n  cat(sprintf(\"  Average: %.2f A\\n\", stats$battery$mean_current))\n  cat(sprintf(\"  Median:  %.2f A\\n\", stats$battery$median_current))\n  if (!is.na(stats$battery$min_current)) {\n    cat(sprintf(\"  Minimum: %.2f A at %s\\n\", \n                stats$battery$min_current,\n                stats$battery$min_current_time))\n    cat(sprintf(\"  Maximum: %.2f A at %s\\n\", \n                stats$battery$max_current,\n                stats$battery$max_current_time))\n  }\n  \n  cat(\"\\nSolar Panel Status:\\n\")\n  cat(\"-----------------\\n\")\n  cat(sprintf(\"Voltage:\\n\"))\n  cat(sprintf(\"  Average (non-zero): %.2f V\\n\", stats$solar$mean_voltage))\n  cat(sprintf(\"  Median (non-zero):  %.2f V\\n\", stats$solar$median_voltage))\n  if (!is.na(stats$solar$max_voltage)) {\n    cat(sprintf(\"  Maximum: %.2f V\\n\", stats$solar$max_voltage))\n  }\n  \n  cat(sprintf(\"\\nCurrent:\\n\"))\n  cat(sprintf(\"  Average: %.2f A\\n\", stats$solar$mean_current))\n  cat(sprintf(\"  Median:  %.2f A\\n\", stats$solar$median_current))\n  if (!is.na(stats$solar$max_current)) {\n    cat(sprintf(\"  Maximum: %.2f A\\n\", stats$solar$max_current))\n  }\n  \n  return(invisible())\n}\n\n#' Render battery voltage alerts\n#' @param all_power_data Reactive expression containing power data\nrender_battery_voltage_alerts <- function(all_power_data) {\n  cat(\"Checks for Vbat readings < 12 V\\n\")  \n\n  req(all_power_data)\n  power_data <- all_power_data\n  \n  if (length(power_data) == 0) {\n    cat(\"No power data available\")\n    invisible()  # Return invisibly to prevent NULL from being printed\n    return()\n  }\n  \n  cat(monitor_battery_voltage(power_data))\n  invisible()  # Return invisibly to prevent NULL from being printed\n}\n","type":"text"},{"name":"data/r/precipitation_module/precipitation_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/precipitation_module/precipitation_charts.R\n\ncreate_rn1_outliers_plot <- function(WX_stations, all_rn1_outliers, selected_station) {\n  # Handle edge case: No station selected\n  if (is.null(selected_station) || selected_station == \"All Stations\") {\n    return(\n      plot_ly() %>%\n        add_annotations(\n          text = \"Please select a specific station to view outliers\",\n          x = 0.5,\n          y = 0.5,\n          xref = \"paper\",\n          yref = \"paper\",\n          showarrow = FALSE,\n          font = list(size = 16)\n        ) %>%\n        layout(\n          xaxis = list(visible = FALSE),\n          yaxis = list(visible = FALSE)\n        )\n    )\n  }\n  \n  # Handle edge case: No data for the selected station\n  if (!selected_station %in% names(WX_stations) || \n      is.null(WX_stations[[selected_station]]) || \n      nrow(WX_stations[[selected_station]]) == 0) {\n    return(\n      plot_ly() %>%\n        add_annotations(\n          text = paste(\"No data available for\", selected_station),\n          x = 0.5,\n          y = 0.5,\n          xref = \"paper\",\n          yref = \"paper\",\n          showarrow = FALSE,\n          font = list(size = 16)\n        ) %>%\n        layout(\n          xaxis = list(visible = FALSE),\n          yaxis = list(visible = FALSE)\n        )\n    )\n  }\n  \n  # Get data for the selected station\n  station_data <- WX_stations[[selected_station]]\n  \n  # Check if we have the required columns\n  required_cols <- c(\"DateTimeNum\", \"Rn_1\", \"Temp\", \"Rh\")\n  if (!all(required_cols %in% colnames(station_data))) {\n    missing_cols <- required_cols[!required_cols %in% colnames(station_data)]\n    return(\n      plot_ly() %>%\n        add_annotations(\n          text = paste(\"Missing required columns:\", paste(missing_cols, collapse = \", \")),\n          x = 0.5,\n          y = 0.5,\n          xref = \"paper\",\n          yref = \"paper\",\n          showarrow = FALSE,\n          font = list(size = 16)\n        ) %>%\n        layout(\n          xaxis = list(visible = FALSE),\n          yaxis = list(visible = FALSE)\n        )\n    )\n  }\n  \n  # Ensure data is properly formatted\n  station_data <- station_data %>%\n    arrange(DateTimeNum) %>%\n    mutate(\n      Rn_1 = as.numeric(Rn_1),\n      Temp = as.numeric(Temp),\n      Rh = as.numeric(Rh),\n      DateTimeNum = as.POSIXct(DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\")\n    )\n  \n  # Handle edge case: No outliers for the selected station\n  has_outliers <- FALSE\n  if (selected_station %in% names(all_rn1_outliers) && \n      !is.null(all_rn1_outliers[[selected_station]]) && \n      nrow(all_rn1_outliers[[selected_station]]) > 0) {\n    outliers_data <- all_rn1_outliers[[selected_station]]\n    outliers_data$DateTimeNum <- as.POSIXct(outliers_data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\")\n    has_outliers <- TRUE\n  }\n  \n  # Define colors from viridis palette\n  colors <- viridis(3, begin = 0, end = 0.8)\n  \n  # Create the plot\n  p <- plot_ly() %>%\n    # Add temperature line\n    add_trace(\n      data = station_data,\n      x = ~DateTimeNum,\n      y = ~Temp,\n      type = \"scatter\",\n      mode = \"lines\",\n      name = \"Temperature (°C)\",\n      line = list(color = colors[1], width = 2),\n      hoverinfo = \"text\",\n      text = ~paste(\n        \"Time: \", format(DateTimeNum, \"%Y-%m-%d %H:%M\"),\n        \"<br>Temp: \", round(Temp, 1), \"°C\",\n        \"<br>RH: \", round(Rh, 1), \"%\",\n        \"<br>Precip: \", round(Rn_1, 2), \"mm\"\n      ),\n      yaxis = \"y\"\n    ) %>%\n    # Add RH line\n    add_trace(\n      data = station_data,\n      x = ~DateTimeNum,\n      y = ~Rh,\n      type = \"scatter\",\n      mode = \"lines\",\n      name = \"Relative Humidity (%)\",\n      line = list(color = colors[2], width = 2),\n      hoverinfo = \"text\",\n      text = ~paste(\n        \"Time: \", format(DateTimeNum, \"%Y-%m-%d %H:%M\"),\n        \"<br>Temp: \", round(Temp, 1), \"°C\",\n        \"<br>RH: \", round(Rh, 1), \"%\",\n        \"<br>Precip: \", round(Rn_1, 2), \"mm\"\n      ),\n      yaxis = \"y2\"\n    ) %>%\n    # Add precipitation line\n    add_trace(\n      data = station_data,\n      x = ~DateTimeNum,\n      y = ~Rn_1,\n      type = \"scatter\",\n      mode = \"lines\",\n      name = \"Precipitation (mm)\",\n      line = list(color = colors[3], width = 2),\n      hoverinfo = \"text\",\n      text = ~paste(\n        \"Time: \", format(DateTimeNum, \"%Y-%m-%d %H:%M\"),\n        \"<br>Temp: \", round(Temp, 1), \"°C\",\n        \"<br>RH: \", round(Rh, 1), \"%\",\n        \"<br>Precip: \", round(Rn_1, 2), \"mm\"\n      ),\n      yaxis = \"y3\"\n    )\n  \n  # Add outliers if they exist\n  if (has_outliers) {\n    p <- p %>%\n      add_trace(\n        data = outliers_data,\n        x = ~DateTimeNum,\n        y = ~Rn_1,\n        type = \"scatter\",\n        mode = \"markers\",\n        name = \"Outliers\",\n        marker = list(\n          color = \"red\",\n          size = 10,\n          symbol = \"diamond\"\n        ),\n        hoverinfo = \"text\",\n        text = ~paste(\n          \"OUTLIER\",\n          \"<br>Time: \", format(DateTimeNum, \"%Y-%m-%d %H:%M\"),\n          \"<br>Value: \", round(Rn_1, 2), \"mm\",\n          \"<br>Avg: \", round(RunningAvg, 2), \"mm\",\n          \"<br>Temp: \", round(Temp, 1), \"°C\",\n          \"<br>RH: \", round(Rh, 1), \"%\"\n        ),\n        yaxis = \"y3\"\n      )\n  }\n  \n  # Create layout with multiple axes\n  p <- p %>%\n    layout(\n      title = paste(\"Precipitation Analysis with Outliers -\", selected_station),\n      xaxis = list(\n        title = \"Time\",\n        gridcolor = \"rgba(0,0,0,0.1)\",\n        zeroline = FALSE\n      ),\n      yaxis = list(\n        title = \"Temperature (°C)\",\n        side = \"left\",\n        gridcolor = \"rgba(0,0,0,0.1)\",\n        zeroline = FALSE\n      ),\n      yaxis2 = list(\n        title = \"Relative Humidity (%)\",\n        side = \"right\",\n        overlaying = \"y\",\n        gridcolor = \"rgba(0,0,0,0)\",\n        rangemode = \"tozero\",\n        zeroline = FALSE,\n        range = c(0, 100)\n      ),\n      yaxis3 = list(\n        title = \"Precipitation (mm)\",\n        side = \"right\",\n        overlaying = \"y\",\n        anchor = \"free\",\n        position = 0.95,\n        gridcolor = \"rgba(0,0,0,0)\",\n        rangemode = \"tozero\",\n        zeroline = FALSE\n      ),\n      legend = list(\n        orientation = \"h\",\n        x = 0.5,\n        y = -0.2,\n        xanchor = \"center\"\n      ),\n      margin = list(\n        r = 100,  # Extra right margin for second y-axis\n        t = 60,   # Top margin for title\n        b = 100   # Bottom margin for legend\n      ),\n      hovermode = \"closest\"\n    )\n  \n  return(p)\n}","type":"text"},{"name":"data/r/precipitation_module/precipitation_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/precipitation_module/precipitation_functions.R\n\n#RN_1 OUTLIERS FUNCTION\nidentify_outliers <- function(data, k = 6, threshold_multiplier = 4) {\n  if (!\"Rn_1\" %in% colnames(data)) {\n    return(NULL)\n  }\n  \n  # Ensure data is properly formatted\n  data <- tryCatch({\n    data %>%\n      arrange(DateTimeNum) %>%\n      mutate(\n        Rn_1 = as.numeric(Rn_1),\n        Rh = as.numeric(Rh),\n        Temp = as.numeric(Temp)\n      )\n  }, error = function(e) {\n    warning(\"Error converting data types: \", e$message)\n    return(NULL)\n  })\n  \n  if (is.null(data)) return(NULL)\n  \n  # Calculate running average and identify outliers\n  result <- tryCatch({\n    data %>%\n      mutate(\n        RunningAvg = zoo::rollmean(Rn_1, k = k, fill = NA),\n        Outlier = abs(Rn_1 - RunningAvg) > (threshold_multiplier * sd(Rn_1, na.rm = TRUE))\n      ) %>%\n      filter(Outlier == TRUE) %>%\n      select(DateTimeNum, Rn_1, RunningAvg, Rh, Temp) %>%\n      arrange(desc(DateTimeNum))\n  }, error = function(e) {\n    warning(\"Error calculating outliers: \", e$message)\n    return(NULL)\n  })\n  \n  return(result)\n}\n# Temperature trends analysis\nidentify_temp_trends <- function(data, \n                               min_rh = 99,         \n                               min_hours = 3,       \n                               min_total_drop = 3.0) { \n    \n  if(nrow(data) < 2) return(list())\n  \n  # Ensure data is chronologically ordered and filter for high RH\n  processed_data <- data %>%\n    arrange(DateTimeNum) %>%\n    mutate(DateTimeNum = as.POSIXct(DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")) %>%\n    filter(Rh >= min_rh)\n  \n  if(nrow(processed_data) < min_hours) return(list())\n\n  trends <- list()\n  current_trend <- NULL\n  \n  for(i in 2:nrow(processed_data)) {\n    # Check if this is a consecutive hour and cooling\n    time_diff <- as.numeric(difftime(processed_data$DateTimeNum[i], \n                                   processed_data$DateTimeNum[i-1], \n                                   units=\"hours\"))\n    is_consecutive_hour <- abs(time_diff - 1) < 0.1  # Allow slight deviation from exactly 1 hour\n    is_cooling <- processed_data$Temp[i] < processed_data$Temp[i-1]\n    \n    if(is_consecutive_hour && is_cooling) {\n      if(is.null(current_trend)) {\n        # Start new trend with both points\n        current_trend <- processed_data[(i-1):i,]\n      } else {\n        # Add point to existing trend\n        current_trend <- rbind(current_trend, processed_data[i,])\n      }\n    } else {\n      # End current trend if we have one and evaluate it\n      if(!is.null(current_trend) && nrow(current_trend) >= min_hours) {\n        total_temp_drop <- max(current_trend$Temp) - min(current_trend$Temp)\n        \n        # Only keep trends with total temperature drop >= min_total_drop\n        if(total_temp_drop >= min_total_drop) {\n          # Check data coverage after trend\n          trend_end_time <- max(current_trend$DateTimeNum)\n          data_coverage <- check_data_coverage(data, trend_end_time)\n          \n          trend_stats <- list(\n            start_time = min(current_trend$DateTimeNum),\n            end_time = max(current_trend$DateTimeNum),\n            duration = nrow(current_trend) - 1,  # Number of hourly decreases\n            total_temp_change = total_temp_drop,\n            avg_rate = total_temp_drop / (nrow(current_trend) - 1),\n            min_temp = min(current_trend$Temp),\n            max_temp = max(current_trend$Temp),\n            avg_rh = mean(current_trend$Rh),\n            data_coverage = data_coverage  # Add data coverage information\n          )\n          \n          trends[[length(trends) + 1]] <- list(\n            data = current_trend,\n            stats = trend_stats\n          )\n        }\n      }\n      current_trend <- NULL\n    }\n  }\n  \n  # Check final trend\n  if(!is.null(current_trend) && nrow(current_trend) >= min_hours) {\n    total_temp_drop <- max(current_trend$Temp) - min(current_trend$Temp)\n    \n    if(total_temp_drop >= min_total_drop) {\n      trend_end_time <- max(current_trend$DateTimeNum)\n      data_coverage <- check_data_coverage(data, trend_end_time)\n      \n      trend_stats <- list(\n        start_time = min(current_trend$DateTimeNum),\n        end_time = max(current_trend$DateTimeNum),\n        duration = nrow(current_trend) - 1,\n        total_temp_change = total_temp_drop,\n        avg_rate = total_temp_drop / (nrow(current_trend) - 1),\n        min_temp = min(current_trend$Temp),\n        max_temp = max(current_trend$Temp),\n        avg_rh = mean(current_trend$Rh),\n        data_coverage = data_coverage  # Add data coverage information\n      )\n      \n      trends[[length(trends) + 1]] <- list(\n        data = current_trend,\n        stats = trend_stats\n      )\n    }\n  }\n  \n  return(trends)\n}\n\n# New helper function to check data coverage\ncheck_data_coverage <- function(data, trend_end_time) {\n  # Convert trend_end_time to POSIXct if it isn't already\n  if(!inherits(trend_end_time, \"POSIXct\")) {\n    trend_end_time <- as.POSIXct(trend_end_time, format=\"%Y-%b-%d %H:%M:%S\", tz=\"UTC\")\n  }\n  \n  # Get the last timestamp in the dataset\n  last_timestamp <- max(as.POSIXct(data$DateTimeNum, format=\"%Y-%b-%d %H:%M:%S\", tz=\"UTC\"))\n  \n  # Calculate time difference in hours\n  hours_after_trend <- as.numeric(difftime(last_timestamp, trend_end_time, units=\"hours\"))\n  \n  # Return coverage information\n  list(\n    hours_after_trend = hours_after_trend,\n    last_timestamp = last_timestamp,\n    has_full_coverage = hours_after_trend >= 24  # Assuming we want at least 24 hours of data after the trend\n  )\n}\n#RECENT RN_1 FUNCTION\nget_most_recent_rn1 <- function(data) {\n  recent_entry <- data %>%\n    filter(Rn_1 > 0) %>%\n    arrange(desc(DateTimeNum)) %>%\n    slice(1)\n  \n  if (nrow(recent_entry) == 0) {\n    return(data.frame(Message = \"No precip recorded in fetched data\"))\n  } else {\n    return(recent_entry)\n  }\n}\n\n#RECENT RN_1 FUNCTION\nget_most_recent_rn1 <- function(data) {\n  recent_entry <- data %>%\n    filter(Rn_1 > 0) %>%\n    arrange(desc(DateTimeNum)) %>%\n    slice(1)\n  \n  if (nrow(recent_entry) == 0) {\n    return(data.frame(Message = \"No precip recorded in fetched data\"))\n  } else {\n    return(recent_entry)\n  }\n}\n\ncalculate_station_rainfall_totals <- function(stations_data) {\n  results <- data.frame(\n    Fire_Zone = character(),\n    Station = character(),\n    Total_Rn_1 = numeric(),\n    First_Reading = character(),\n    Last_Reading = character(),\n    Num_Readings = integer(),\n    Mean_Rn_1 = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  if (is.null(stations_data) || length(stations_data) == 0) {\n    return(results)\n  }\n\n  # Create a lookup table for station to zone mapping with underscores\n  station_zone_lookup <- list()\n  for (zone_name in names(fire_zone_mapping)) {\n    for (station in fire_zone_mapping[[zone_name]]) {\n      # Convert space-separated names to underscore format\n      lookup_name <- gsub(\" \", \"_\", station)\n      station_zone_lookup[[lookup_name]] <- zone_name\n    }\n  }\n\n  for (station_name in names(stations_data)) {\n    data <- stations_data[[station_name]]\n    \n    if (is.null(data) || \n        !is.data.frame(data) || \n        nrow(data) == 0 || \n        !all(c(\"Rn_1\", \"DateTimeNum\") %in% colnames(data))) {\n      next\n    }\n    \n    data$Rn_1 <- as.numeric(data$Rn_1)\n    valid_rows <- !is.na(data$DateTimeNum) & !is.na(data$Rn_1)\n    \n    if (sum(valid_rows) > 0) {\n      total_rn_1 <- sum(data$Rn_1[valid_rows], na.rm = TRUE)\n      first_reading <- min(data$DateTimeNum[valid_rows])\n      last_reading <- max(data$DateTimeNum[valid_rows])\n      mean_rn_1 <- mean(data$Rn_1[valid_rows], na.rm = TRUE)\n      \n      clean_station_name <- gsub(\"dbo.\", \"\", station_name)\n      lookup_name <- toupper(clean_station_name)\n      \n      # Find the zone using the lookup table\n      fire_zone <- station_zone_lookup[[lookup_name]]\n      if (is.null(fire_zone)) {\n        fire_zone <- \"Unassigned Zone\"\n      }\n      \n      results <- rbind(results, data.frame(\n        Fire_Zone = fire_zone,\n        Station = clean_station_name,\n        Total_Rn_1 = round(total_rn_1, 1),\n        First_Reading = first_reading,\n        Last_Reading = last_reading,\n        Num_Readings = sum(valid_rows),\n        Mean_Rn_1 = round(mean_rn_1, 3),\n        stringsAsFactors = FALSE\n      ))\n    }\n  }\n  \n  if (nrow(results) > 0) {\n    results <- results[order(results$Fire_Zone, -results$Total_Rn_1), ]\n  }\n  \n  return(results)\n}\n","type":"text"},{"name":"data/r/precipitation_module/precipitation_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/precipitation_module/precipitation_output.R\n\n#' Render decreasing temperature trends output\n#' @param WX_stations List of weather station data frames\n#' @return Rendered output of decreasing temperature trends with high RH\nrender_decreasing_trends_output <- function(WX_stations, selected_station = \"All Stations\") {\n  cat(\"Finds consecutive hourly temperature drops of 3.0°C or more over at least 3 hours when relative humidity is at least 99%.\\n\")\n  cat(\"Flags trend with all positive temperatures and no precipitation.\\n\\n\")\n  \n  flagged_stations <- list()\n  unflagged_stations <- list()\n  \n  for (table_name in names(WX_stations)) {\n    if(selected_station != \"All Stations\" && \n       gsub(\"^dbo\\\\.\", \"\", table_name) != selected_station) next\n    \n    data <- WX_stations[[table_name]]\n    \n    if (!is.null(data) && nrow(data) > 0) {\n      data$DateTimeNum <- as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n      trends <- identify_temp_trends(data)\n      \n      if (length(trends) > 0) {\n        station_has_flag <- FALSE\n        station_trends <- list(\n          name = gsub(\"^dbo\\\\.\", \"\", table_name),\n          data = data,\n          trends = trends\n        )\n        \n        for (trend in trends) {\n          all_positive_temps <- all(trend$data$Temp > 0)\n          trend_precip <- data %>%\n            filter(DateTimeNum >= trend$stats$start_time,\n                   DateTimeNum <= trend$stats$end_time,\n                   Rn_1 > 0) %>%\n            summarize(total_rn = sum(Rn_1, na.rm = TRUE)) %>%\n            pull(total_rn)\n          \n          if (all_positive_temps && trend_precip == 0) {\n            station_has_flag <- TRUE\n            break\n          }\n        }\n        \n        if (station_has_flag) {\n          flagged_stations[[table_name]] <- station_trends\n        } else {\n          unflagged_stations[[table_name]] <- station_trends\n        }\n      }\n    }\n  }\n  \n  print_station_trends <- function(station_info) {\n    cat(\"\\n\",station_info$name, \"\\n\")\n    cat(\"----------------------------------------\\n\\n\")\n    \n    for (i in seq_along(station_info$trends)) {\n      stats <- station_info$trends[[i]]$stats\n      trend_data <- station_info$trends[[i]]$data\n      \n      all_positive_temps <- all(trend_data$Temp > 0)\n      trend_precip <- station_info$data %>%\n        filter(DateTimeNum >= stats$start_time,\n               DateTimeNum <= stats$end_time,\n               Rn_1 > 0) %>%\n        summarize(total_rn = sum(Rn_1, na.rm = TRUE)) %>%\n        pull(total_rn)\n      \n      if (all_positive_temps && trend_precip == 0) {\n        cat(\"FLAGGED: All positive temperatures with no precipitation\\n\")\n      }\n      \n      cat(sprintf(\"Trend %d: %d consecutive cooling hours\\n\", i, stats$duration))\n      cat(sprintf(\"Time: %s to %s\\n\", \n          format(stats$start_time, \"%Y-%m-%d %H:%M\"),\n          format(stats$end_time, \"%Y-%m-%d %H:%M\")))\n      cat(sprintf(\"Total Temperature Drop: %.1f°C (%.2f°C/hr average)\\n\", \n          abs(stats$total_temp_change), abs(stats$avg_rate)))\n      \n      has_vslr <- \"Vslr\" %in% names(station_info$data)\n      if (has_vslr) {\n        valid_vslr <- station_info$data %>%\n          filter(DateTimeNum >= stats$start_time,\n                 DateTimeNum <= stats$end_time) %>%\n          pull(Vslr) %>%\n          as.numeric()\n        \n        if (length(valid_vslr) > 0 && !all(is.na(valid_vslr))) {\n          min_vslr <- min(valid_vslr, na.rm = TRUE)\n          max_vslr <- max(valid_vslr, na.rm = TRUE)\n          \n          if (is.finite(min_vslr) && is.finite(max_vslr)) {\n            cat(sprintf(\"Solar Voltage Range: %.1fV to %.1fV\\n\",\n                min_vslr, max_vslr))\n          } else {\n            cat(\"Solar Voltage Range: Not available\\n\")\n          }\n        } else {\n          cat(\"Solar Voltage Range: Not available\\n\")\n        }\n      } else {\n        cat(\"Solar Voltage Range: No solar voltage data available for this station\\n\")\n      }\n      \n      cat(sprintf(\"Temperature Range: %.1f°C to %.1f°C\\n\", \n          stats$max_temp, stats$min_temp))\n      cat(sprintf(\"Average RH: %.1f%%\\n\", stats$avg_rh))\n      \n      if (trend_precip > 0) {\n        cat(sprintf(\"Precipitation during trend: %.2f mm\\n\", trend_precip))\n      } else {\n        cat(\"No precipitation recorded during trend.\\n\")\n      }\n      \n      trend_end_time <- max(trend_data$DateTimeNum)\n      next_precip <- station_info$data %>%\n        filter(DateTimeNum > trend_end_time, Rn_1 > 0) %>%\n        arrange(DateTimeNum) %>%\n        slice(1)\n      \n      if(nrow(next_precip) > 0) {\n        cat(sprintf(\"\\nMost recent precipitation after trend: %.2f mm at %s\\n\",\n            next_precip$Rn_1, \n            format(next_precip$DateTimeNum, \"%Y-%m-%d %H:%M\")))\n      } else {\n        cat(\"\\nNo precipitation recorded after this trend in the fetched data.\\n\")\n      }\n      \n      cat(\"\\n\")\n    }\n  }\n  \n  if (length(flagged_stations) > 0) {\n    if (length(flagged_stations) == 1) {\n      cat(\"Found 1 station with flagged trends:\\n\")\n    } else {\n      cat(sprintf(\"Found %d stations with flagged trends:\\n\", length(flagged_stations)))\n    }\n    for (station in flagged_stations) {\n      print_station_trends(station)\n    }\n  }\n  \n  if (length(unflagged_stations) > 0) {\n    if (length(flagged_stations) > 0) {\n      cat(\"\\nOther stations with cooling trends:\\n\")\n    }\n    for (station in unflagged_stations) {\n      print_station_trends(station)\n    }\n  }\n  \n  if (length(flagged_stations) == 0 && length(unflagged_stations) == 0) {\n    cat(\"No consecutive hourly cooling trends found for the selected station(s).\\n\")\n  }\n}\n#' Render Rn_1 outliers output\n#' @param input Shiny input object\n#' @param all_rn1_outliers Reactive expression containing Rn_1 outlier data\nrender_rn1_outliers_output <- function(input, all_rn1_outliers) {\n  rn1_outliers <- all_rn1_outliers\n  \n  cat(\"Flags Rn_1 values that exceed 4x standard deviation from their 6-hour running average.\\n\\n\")\n  \n  selected_station <- input$rn1_outliers_station_select\n  \n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    rn1_outliers <- rn1_outliers[selected_station]\n  }\n  \n  if (length(rn1_outliers) == 0 || all(sapply(rn1_outliers, is.null))) {\n    cat(\"No outliers detected.\")\n  } else {\n    for (station in names(rn1_outliers)) {\n      if (!is.null(rn1_outliers[[station]]) && nrow(rn1_outliers[[station]]) > 0) {\n        station_name <- sub(\"^dbo\\\\.\", \"\", station)\n        cat(\"\\n\", station_name, \"\\n\", sep = \"\")\n        print(rn1_outliers[[station]], row.names = FALSE)\n      }\n    }\n  }\n}\n\n\nrender_station_rainfall_output <- function(wx_data, station_select = NULL) {\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    cat(\"No data available for analysis.\")\n    return(invisible(NULL))\n  }\n\n  results <- data.frame(\n    Fire_Zone = character(),\n    Station = character(),\n    Total_Rn_1 = numeric(),\n    stringsAsFactors = FALSE\n  )\n\n  for (table_name in names(wx_data)) {\n    station_data <- wx_data[[table_name]]\n    if (!is.null(station_data) && \"Rn_1\" %in% names(station_data)) {\n      # Extract zone directly from the station data\n      station_fire_zone <- if (\"FIRE_ZONE\" %in% names(station_data)) {\n        unique_zones <- unique(station_data$FIRE_ZONE)\n        if (length(unique_zones) > 0 && !all(is.na(unique_zones))) {\n          unique_zones[1]  # Use the first non-NA zone if multiple exist\n        } else {\n          \"Unassigned Zone\"\n        }\n      } else {\n        \"Unassigned Zone\"\n      }\n      \n      # Convert Rn_1 to numeric before summing\n      station_data$Rn_1 <- as.numeric(as.character(station_data$Rn_1))\n      \n      # Clean station name\n      clean_station_name <- gsub(\"^dbo\\\\.\", \"\", table_name)\n      \n      # Sum only if conversion was successful\n      if (!all(is.na(station_data$Rn_1))) {\n        total_rn1 <- sum(station_data$Rn_1, na.rm = TRUE)\n        \n        results <- rbind(results, data.frame(\n          Fire_Zone = station_fire_zone,\n          Station = clean_station_name,\n          Total_Rn_1 = round(total_rn1, 1),\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n  }\n\n  if (!is.null(station_select) && station_select != \"All Stations\") {\n    results <- results[results$Station == station_select, ]\n  }\n\n  results <- results[order(results$Fire_Zone, -results$Total_Rn_1), ]\n\n  if (nrow(results) == 0) {\n    cat(\"No rainfall data available.\")\n    return(invisible(NULL))\n  }\n\n  current_zone <- \"\"\n  max_station_width <- max(nchar(results$Station))\n  line_width <- max_station_width + 20\n\n  for (i in 1:nrow(results)) {\n    if (results$Fire_Zone[i] != current_zone) {\n      if (current_zone != \"\") cat(\"\\n\")\n      current_zone <- results$Fire_Zone[i]\n      cat(sprintf(\"\\n%s\\n%s\\n\", current_zone, strrep(\"═\", nchar(current_zone))))\n    }\n\n    cat(sprintf(\" %-*s │ %6.1f mm\\n\", \n                max_station_width,\n                results$Station[i],\n                results$Total_Rn_1[i]))\n\n    if (i == nrow(results) || results$Fire_Zone[i] != results$Fire_Zone[i + 1]) {\n      zone_total <- sum(results$Total_Rn_1[results$Fire_Zone == current_zone])\n      cat(sprintf(\"%s\\n\", strrep(\"─\", line_width)))\n      cat(sprintf(\" %-*s │ %6.1f mm\\n\", \n                  max_station_width,\n                  \"Zone Total\",\n                  zone_total))\n    }\n  }\n\n  invisible(results)\n}","type":"text"},{"name":"data/r/rh_module/rh_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/rh_module/rh_charts.R\n\ncreate_consecutive_rh_plot <- function(wx_stations, selected_station = \"All Stations\") {\n  consecutive_rh_results <- check_consecutive_rh(wx_stations)\n  \n  if (!is.data.frame(consecutive_rh_results) || nrow(consecutive_rh_results) == 0) {\n    return(plot_ly(height = 400) %>%\n      add_annotations(\n        text = \"No stations found with 12 or more consecutive hourly RH 100% readings\",\n        showarrow = FALSE,\n        font = list(size = 14)\n      ) %>%\n      layout(margin = list(l = 60, r = 60, b = 100, t = 60, pad = 4)))\n  }\n  \n  if (selected_station != \"All Stations\") {\n    consecutive_rh_results <- consecutive_rh_results[consecutive_rh_results$Station == selected_station, ]\n    if (nrow(consecutive_rh_results) == 0) {\n      return(plot_ly(height = 400) %>%\n        add_annotations(\n          text = paste(\"No consecutive RH 100 readings found for station:\", selected_station),\n          showarrow = FALSE,\n          font = list(size = 14)\n        ))\n    }\n  }\n  \n  consecutive_rh_results$duration_hrs <- consecutive_rh_results$Consecutive_Count / 1\n  \n  # Create datasets for different conditions\n  red_points <- consecutive_rh_results[consecutive_rh_results$Min_Temp > 0 & consecutive_rh_results$Total_Rn_1 == 0, ]\n  orange_points <- consecutive_rh_results[consecutive_rh_results$Total_Rn_1 == 0 & consecutive_rh_results$Min_Temp <= 0, ]\n  blue_points <- consecutive_rh_results[consecutive_rh_results$Total_Rn_1 > 0, ]\n  \n  # Calculate plot ranges\n  max_duration <- max(consecutive_rh_results$duration_hrs, na.rm = TRUE)\n  max_rain <- max(consecutive_rh_results$Total_Rn_1, na.rm = TRUE)\n  \n  if (!is.finite(max_duration)) max_duration <- 24\n  if (!is.finite(max_rain)) max_rain <- 10\n  \n  y_range_min <- -max_rain * 0.1\n  y_range_max <- max_rain * 1.1\n  \n  plot <- plot_ly(height = 400)\n  \n  # Function to add points with proper legend entries\n  add_category_points <- function(plot, data, color, name) {\n    if (nrow(data) > 0) {\n      plot %>% add_trace(\n        data = data,\n        x = ~duration_hrs,\n        y = ~Total_Rn_1,\n        type = 'scatter',\n        mode = 'markers+text',\n        marker = list(size = 12, color = color),\n        text = ~Station,\n        textposition = \"top center\",\n        name = name,\n        hovertext = ~sprintf(\n          \"Station: %s<br>Min Temp: %.1f°C<br>Avg Temp: %.1f°C<br>Max Temp: %.1f°C<br>Total Rain: %.1f mm<br>Start Time: %s<br>End Time: %s\",\n          Station, Min_Temp, Avg_Temp, Max_Temp, Total_Rn_1, Start_Time, End_Time\n        ),\n        hoverinfo = \"text\",\n        showlegend = TRUE,\n        legendgroup = name\n      )\n    } else {\n      # Add an invisible trace for legend when no points exist\n      plot %>% add_trace(\n        x = numeric(0),\n        y = numeric(0),\n        type = 'scatter',\n        mode = 'markers',\n        marker = list(size = 12, color = color),\n        name = name,\n        showlegend = TRUE,\n        legendgroup = name\n      )\n    }\n  }\n  \n  # Add all categories with proper legend entries\n  plot <- plot %>%\n    add_category_points(red_points, 'red', \"Continuous positive temps (>0°C), no Rn_1\") %>%\n    add_category_points(orange_points, 'orange', \"Mixed or negative temps, no Rn_1\") %>%\n    add_category_points(blue_points, 'blue', \"Rn_1 recorded\")\n  \n  # Configure layout with legend\n  plot %>% layout(\n    title = \"100% RH Duration vs Rn_1\",\n    xaxis = list(\n      title = \"Duration of 100% RH (hours)\",\n      zeroline = TRUE,\n      zerolinecolor = 'black',\n      zerolinewidth = 2,\n      range = c(0, max_duration * 1.1)\n    ),\n    yaxis = list(\n      title = \"Total Precipitation (mm)\",\n      zeroline = TRUE,\n      zerolinecolor = 'black',\n      zerolinewidth = 2,\n      range = c(y_range_min, y_range_max)\n    ),\n    showlegend = TRUE,\n    legend = list(\n      x = 1.02,\n      y = 1,\n      xanchor = 'left',\n      yanchor = 'top',\n      bgcolor = 'rgba(255, 255, 255, 0.9)',\n      bordercolor = 'rgba(0, 0, 0, 0.5)',\n      borderwidth = 1\n    ),\n    margin = list(r = 150)  # Add right margin to accommodate legend\n  )\n}\n","type":"text"},{"name":"data/r/rh_module/rh_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/rh_module/rh_functions.R\n\n# Function to find 0% RH\ncheck_low_rh_values <- function(data_list) {\n  low_rh_info <- data.frame(\n    Table = character(),\n    Row = integer(),\n    Rh = numeric(),\n    DateTime = character(),\n    stringsAsFactors = FALSE\n  )\n  \n  for (table_name in names(data_list)) {\n    data <- data_list[[table_name]]\n    \n    if (\"Rh\" %in% colnames(data)) {\n      low_rh_rows <- which(data$Rh == 0)\n      \n      if (length(low_rh_rows) > 0) {\n        low_rh_info <- rbind(low_rh_info, data.frame(\n          Table = table_name,\n          Row = low_rh_rows,\n          Rh = data[low_rh_rows, \"Rh\"],\n          DateTime = as.character(data[low_rh_rows, \"DateTimeNum\"]),\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n  }\n  \n  if (nrow(low_rh_info) > 0) low_rh_info else \"No Rh values = 0% detected.\"\n}\n#Function to find RH 100\ncheck_consecutive_rh <- function(stations_data) {\n  # Initialize results dataframe\n  results <- data.frame(\n    Station = character(),\n    Consecutive_Count = numeric(),\n    Start_Time = character(),\n    End_Time = character(),\n    Total_Rn_1 = numeric(),\n    Avg_Temp = numeric(),\n    Max_Temp = numeric(),\n    Min_Temp = numeric(),\n    Has_Positive_Temp = logical(),\n    stringsAsFactors = FALSE\n  )\n  \n  if (is.null(stations_data) || length(stations_data) == 0) {\n    return(\"No station data provided.\")\n  }\n  \n  for (station_name in names(stations_data)) {\n    data <- stations_data[[station_name]]\n    \n    # Skip invalid station data\n    if (is.null(data) || nrow(data) == 0 || \n        !all(c(\"DateTimeNum\", \"Rh\", \"Rn_1\", \"Temp\") %in% names(data))) {\n      next\n    }\n    \n    tryCatch({\n      # Convert DateTimeNum to POSIXct if needed\n      if (!inherits(data$DateTimeNum, \"POSIXct\")) {\n        data$DateTimeNum <- as.POSIXct(data$DateTimeNum, \n                                      format = \"%Y-%b-%d %H:%M:%S\", \n                                      tz = \"America/Los_Angeles\")\n      }\n      \n      # Sort data by time\n      data <- data[order(data$DateTimeNum), ]\n      \n      # Convert columns to numeric\n      data$Rh <- as.numeric(data$Rh)\n      data$Rn_1 <- as.numeric(data$Rn_1)\n      data$Temp <- as.numeric(data$Temp)\n      \n      # Initialize tracking variables\n      consecutive_count <- 0\n      current_start <- NULL\n      current_rn_1_sum <- 0\n      temp_values <- numeric()\n      spans <- list()\n      \n      # Process each row\n      for (i in seq_len(nrow(data))) {\n        if (!is.na(data$Rh[i]) && data$Rh[i] == 100) {\n          # Continue or start new consecutive span\n          consecutive_count <- consecutive_count + 1\n          if (consecutive_count == 1) {\n            current_start <- data$DateTimeNum[i]\n            temp_values <- numeric()\n          }\n          current_rn_1_sum <- current_rn_1_sum + ifelse(is.na(data$Rn_1[i]), 0, data$Rn_1[i])\n          temp_values <- c(temp_values, data$Temp[i])\n        } else {\n          # Process completed sequence if it meets threshold\n          if (consecutive_count >= 12) {\n            spans[[length(spans) + 1]] <- list(\n              start_time = current_start,\n              end_time = data$DateTimeNum[i-1],\n              count = consecutive_count,\n              total_rn_1 = current_rn_1_sum,\n              temp_values = temp_values\n            )\n          }\n          # Reset counters\n          consecutive_count <- 0\n          current_rn_1_sum <- 0\n          temp_values <- numeric()\n        }\n      }\n      \n      # Handle case where sequence ends with 100s\n      if (consecutive_count >= 12) {\n        spans[[length(spans) + 1]] <- list(\n          start_time = current_start,\n          end_time = tail(data$DateTimeNum, 1),\n          count = consecutive_count,\n          total_rn_1 = current_rn_1_sum,\n          temp_values = temp_values\n        )\n      }\n      \n      # Process all spans into results dataframe\n      for (span in spans) {\n        if (length(span$temp_values) > 0) {\n          avg_temp <- mean(span$temp_values, na.rm = TRUE)\n          max_temp <- max(span$temp_values, na.rm = TRUE)\n          min_temp <- min(span$temp_values, na.rm = TRUE)\n          has_positive_temp <- any(span$temp_values > 0, na.rm = TRUE)\n          \n          results <- rbind(results, data.frame(\n            Station = gsub(\"dbo\\\\.\", \"\", station_name),\n            Consecutive_Count = span$count,\n            Start_Time = format(span$start_time, \"%Y-%b-%d %H:%M:%S\"),\n            End_Time = format(span$end_time, \"%Y-%b-%d %H:%M:%S\"),\n            Total_Rn_1 = span$total_rn_1,\n            Avg_Temp = avg_temp,\n            Max_Temp = max_temp,\n            Min_Temp = min_temp,\n            Has_Positive_Temp = has_positive_temp,\n            stringsAsFactors = FALSE\n          ))\n        }\n      }\n    }, error = function(e) {\n      warning(sprintf(\"Error processing station %s: %s\", station_name, e$message))\n      next\n    })\n  }\n  \n  # Return results\n  if (nrow(results) > 0) {\n    return(results[order(results$Station, results$Start_Time), ])\n  } else {\n    return(\"No stations found with 12 or more consecutive hourly RH 100% readings.\")\n  }\n}\n\n# Function to calculate percentage of RH 100% readings\ncalculate_rh_percentage <- function(data) {\n  if (is.null(data) || nrow(data) == 0 || !\"Rh\" %in% names(data)) {\n    return(0)\n  }\n  \n  # Ensure Rh column is numeric and handle any conversion issues\n  data$Rh <- suppressWarnings(as.numeric(as.character(data$Rh)))\n  \n  # Remove any invalid values (NA, NaN, Inf)\n  valid_rh <- data$Rh[!is.na(data$Rh) & is.finite(data$Rh)]\n  if (length(valid_rh) == 0) return(0)\n  \n  # Count exact matches to 100 (using near() for floating point comparison)\n  rh_100_count <- sum(abs(valid_rh - 100) < 1e-10)\n  total_entries <- length(valid_rh)\n  \n  # Calculate percentage\n  percentage <- (rh_100_count / total_entries) * 100\n  \n  return(percentage)\n}\n","type":"text"},{"name":"data/r/rh_module/rh_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/rh_module/rh_output.R\n\n#' Render the low RH values output\n#' @param WX_stations List of weather station data\nrender_low_rh_output <- function(WX_stations) {\n  low_rh_results <- check_low_rh_values(WX_stations)\n  if (is.data.frame(low_rh_results)) {\n    cat(\"Low Rh values detected in the following details:\\n\")\n    print(low_rh_results)\n  } else {\n    cat(low_rh_results, \"\\n\")\n  }\n}\n\n#' Render the consecutive RH 100% output\n#' @param WX_stations List of weather station data\n#' @param selected_station Selected station name or \"All Stations\"\n# Function to print section header with consistent formatting\n# Print section header with consistent formatting\nprint_section_header <- function(text, is_subsection = FALSE) {\n  if (!is_subsection) {\n    cat(\"\\n\", paste0(rep(\"=\", 80), collapse=\"\"), \"\\n\")\n    cat(sprintf(\"%s\\n\", toupper(text)))\n    cat(paste0(rep(\"=\", 80), collapse=\"\"), \"\\n\\n\")\n  } else {\n    cat(\"\\n\")\n    cat(sprintf(\"%s\\n\", text))\n    cat(paste0(rep(\"-\", 40), collapse=\"\"), \"\\n\\n\")\n  }\n}\n\nrender_consecutive_rh_output <- function(stations_data, selected_station = \"All Stations\") {\n  consecutive_rh_results <- check_consecutive_rh(stations_data)\n  \n  cat(\"Identifies occurrences where RH remains at 100% for 12 or more consecutive hours and flags spans with minimum temperature > 0°C and Rn_1 = 0.\\n\\n\")\n  \n  if (!is.data.frame(consecutive_rh_results)) {\n    cat(consecutive_rh_results, \"\\n\")\n    return()\n  }\n  \n  if (selected_station != \"All Stations\") {\n    consecutive_rh_results <- consecutive_rh_results[consecutive_rh_results$Station == selected_station, ]\n    if (nrow(consecutive_rh_results) == 0) {\n      cat(\"No consecutive RH 100% readings found for the selected station.\\n\")\n      return()\n    }\n  }\n  \n  # Calculate summary statistics with percentages for all stations\n  station_summary <- data.frame(\n    station = names(stations_data),\n    stringsAsFactors = FALSE\n  )\n  \n  # Add percentage calculations\n  station_summary$rh_percentage <- sapply(station_summary$station, function(station) {\n    calculate_rh_percentage(stations_data[[station]])\n  })\n  \n  # Add counts and flagged counts\n  station_counts <- table(consecutive_rh_results$Station)\n  station_summary$count <- 0\n  station_summary$count[match(names(station_counts), gsub(\"dbo\\\\.\", \"\", station_summary$station))] <- as.numeric(station_counts)\n  \n  station_summary$flagged_count <- sapply(gsub(\"dbo\\\\.\", \"\", station_summary$station), function(station) {\n    station_data <- consecutive_rh_results[consecutive_rh_results$Station == station, ]\n    sum(station_data$Min_Temp > 0 & station_data$Total_Rn_1 == 0)\n  })\n  \n  # Clean up station names and filter\n  station_summary$station <- gsub(\"dbo\\\\.\", \"\", station_summary$station)\n  station_summary <- station_summary[station_summary$count > 0, ]\n  \n  # Sort stations\n  flagged_stations <- station_summary[station_summary$flagged_count > 0, ]\n  non_flagged_stations <- station_summary[station_summary$flagged_count == 0, ]\n  flagged_stations <- flagged_stations[order(-flagged_stations$flagged_count, -flagged_stations$count), ]\n  non_flagged_stations <- non_flagged_stations[order(-non_flagged_stations$rh_percentage), ]\n  station_summary <- rbind(flagged_stations, non_flagged_stations)\n  \n  # Store the order for later use\n  station_order <- station_summary$station\n  \n  # Print Overview section\n  print_section_header(\"Overview\")\n  cat(sprintf(\"Total stations with extended RH 100%% periods: %d\\n\\n\", nrow(station_summary)))\n  \n  cat(\"Breakdown by station:\\n\")\n  \n  # Only add line break if there are both flagged and non-flagged stations\n  has_flagged <- any(station_summary$flagged_count > 0)\n  last_flagged <- if(has_flagged) max(which(station_summary$flagged_count > 0)) else 0\n  \n  for (i in 1:nrow(station_summary)) {\n    if (has_flagged && i == last_flagged + 1) cat(\"\\n\")\n    \n    station_name <- paste0(station_summary$station[i], \":\")\n    spans_info <- if (station_summary$flagged_count[i] > 0) {\n      sprintf(\"%d (%d flagged)\", \n              station_summary$count[i],\n              station_summary$flagged_count[i])\n    } else {\n      sprintf(\"%d\", \n              station_summary$count[i])\n    }\n    \n    cat(sprintf(\"%-20s %-25s • RH=100%% for %.1f%% of available data\\n\",\n               station_name,\n               spans_info,\n               station_summary$rh_percentage[i]))\n  }\n  \n  # Create separate mappings for flagged and non-flagged span numbers\n  flagged_span_numbers <- list()\n  non_flagged_span_numbers <- list()\n  \n  # Print Flagged Events section first\n  flagged_results <- consecutive_rh_results[consecutive_rh_results$Min_Temp > 0 & consecutive_rh_results$Total_Rn_1 == 0, ]\n  if (nrow(flagged_results) > 0) {\n    print_section_header(\"Flagged Spans\")\n    \n    # Sort flagged results by station order and then by start time\n    flagged_results$start_time_posix <- as.POSIXct(flagged_results$Start_Time, format=\"%Y-%b-%d %H:%M:%S\")\n    flagged_results <- flagged_results[order(\n      match(flagged_results$Station, station_order),\n      flagged_results$start_time_posix\n    ), ]\n    \n    current_station <- \"\"\n    for (i in 1:nrow(flagged_results)) {\n      if (current_station != flagged_results$Station[i]) {\n        if (current_station != \"\") cat(\"\\n\")\n        current_station <- flagged_results$Station[i]\n        print_section_header(current_station, TRUE)\n        # Initialize flagged span counter for this station\n        if (is.null(flagged_span_numbers[[current_station]])) {\n          flagged_span_numbers[[current_station]] <- 1\n        }\n      }\n      \n      span_num <- flagged_span_numbers[[current_station]]\n      flagged_span_numbers[[current_station]] <- span_num + 1\n      \n      if (span_num > 1) cat(\"\\n\")\n      cat(sprintf(\"Span %d (FLAGGED)\\n\", span_num))\n      \n      cat(sprintf(\"Start Time: %s\\nEnd Time: %s\\nDuration: %d hours\\nTotal Rain: %.1f mm\\nAvg Temp: %.1f°C\\nMax Temp: %.1f°C\\nMin Temp: %.1f°C\\n\",\n                flagged_results$Start_Time[i],\n                flagged_results$End_Time[i],\n                flagged_results$Consecutive_Count[i],\n                flagged_results$Total_Rn_1[i],\n                flagged_results$Avg_Temp[i],\n                flagged_results$Max_Temp[i],\n                flagged_results$Min_Temp[i]))\n    }\n  }\n  \n  # Print Non-Flagged Records section\n  non_flagged <- consecutive_rh_results[!(consecutive_rh_results$Min_Temp > 0 & consecutive_rh_results$Total_Rn_1 == 0), ]\n  if (nrow(non_flagged) > 0) {\n    print_section_header(\"All Other Extended RH 100% Periods\")\n    \n    # Sort non-flagged results by station order and start time\n    non_flagged$start_time_posix <- as.POSIXct(non_flagged$Start_Time, format=\"%Y-%b-%d %H:%M:%S\")\n    non_flagged <- non_flagged[order(\n      match(non_flagged$Station, station_order),\n      non_flagged$start_time_posix\n    ), ]\n    \n    current_station <- \"\"\n    for (i in 1:nrow(non_flagged)) {\n      if (current_station != non_flagged$Station[i]) {\n        if (current_station != \"\") cat(\"\\n\")\n        current_station <- non_flagged$Station[i]\n        print_section_header(current_station, TRUE)\n        # Initialize non-flagged span counter for this station\n        if (is.null(non_flagged_span_numbers[[current_station]])) {\n          non_flagged_span_numbers[[current_station]] <- 1\n        }\n      }\n      \n      span_num <- non_flagged_span_numbers[[current_station]]\n      non_flagged_span_numbers[[current_station]] <- span_num + 1\n      \n      if (span_num > 1) cat(\"\\n\")\n      cat(sprintf(\"Span %d\\n\", span_num))\n      \n      cat(sprintf(\"Start Time: %s\\nEnd Time: %s\\nDuration: %d hours\\nTotal Rain: %.1f mm\\nAvg Temp: %.1f°C\\nMax Temp: %.1f°C\\nMin Temp: %.1f°C\\n\",\n                non_flagged$Start_Time[i],\n                non_flagged$End_Time[i],\n                non_flagged$Consecutive_Count[i],\n                non_flagged$Total_Rn_1[i],\n                non_flagged$Avg_Temp[i],\n                non_flagged$Max_Temp[i],\n                non_flagged$Min_Temp[i]))\n    }\n  }\n}\n","type":"text"},{"name":"data/r/temperature_module/temperature_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# temperature_module/temperature_charts.R\n\ncreate_temp_change_heatmap <- function(wx_data, selected_station = NULL) {\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    return(plot_ly() %>% layout(title = \"No temperature data available\"))\n  }\n  \n  # Process data for all stations or selected station\n  temp_changes <- data.frame()\n  station_start_times <- data.frame(station = character(),\n                                  start_time = as.POSIXct(character()),\n                                  reading_count = numeric())\n  \n  stations_to_process <- if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    selected_station\n  } else {\n    names(wx_data)\n  }\n  \n  for (station_name in stations_to_process) {\n    station_data <- wx_data[[station_name]]\n    \n    if (!is.null(station_data) && \"Temp\" %in% names(station_data) && nrow(station_data) > 0) {\n      # Convert DateTimeNum to POSIXct if it's character\n      if (is.character(station_data$DateTimeNum)) {\n        station_data$DateTimeNum <- as.POSIXct(station_data$DateTimeNum, \n                                              format = \"%Y-%b-%d %H:%M:%S\", \n                                              tz = \"UTC\")\n      }\n      \n      # Store station start time and reading count\n      station_start_times <- rbind(station_start_times, data.frame(\n        station = station_name,\n        start_time = min(station_data$DateTimeNum, na.rm = TRUE),\n        reading_count = nrow(station_data)\n      ))\n      \n      changes <- station_data %>%\n        arrange(DateTimeNum) %>%\n        mutate(\n          OriginalDateTime = DateTimeNum,\n          DateTimeNum = ceiling_date(DateTimeNum, unit = \"minute\"),\n          Temp = as.numeric(Temp),\n          temp_change = lead(Temp) - Temp,\n          Station = sub(\"^dbo\\\\.\", \"\", station_name)\n        ) %>%\n        select(Station, DateTimeNum, OriginalDateTime, temp_change, Temp) %>%\n        filter(!is.na(temp_change))\n      \n      temp_changes <- rbind(temp_changes, changes)\n    }\n  }\n  \n  if (nrow(temp_changes) == 0) {\n    return(plot_ly() %>% layout(title = \"No temperature change data available\"))\n  }\n  \n  # Sort stations in reverse alphabetical order (A at top)\n  station_levels <- sort(unique(temp_changes$Station), decreasing = TRUE)\n  temp_changes$Station <- factor(temp_changes$Station, levels = station_levels)\n  \n  # Calculate weighted average start time based on number of readings\n  total_readings <- sum(station_start_times$reading_count)\n  weighted_start_time <- sum(as.numeric(station_start_times$start_time) * \n                           (station_start_times$reading_count / total_readings))\n  common_start_date <- as.POSIXct(weighted_start_time, origin = \"1970-01-01\", tz = \"UTC\")\n  \n  # Round to nearest hour\n  common_start_date <- ceiling_date(common_start_date, unit = \"hour\")\n  \n  # Create custom diverging color scale\n  colors <- colorRampPalette(c(\"#313695\", \"#4575B4\", \"#74ADD1\", \"#ABD9E9\", \n                              \"#FFFFFF\",\n                              \"#FDAE61\", \"#F46D43\", \"#D73027\", \"#A50026\"))(100)\n  \n  max_abs_change <- max(abs(temp_changes$temp_change), na.rm = TRUE)\n  \n  # Create the heatmap\n  p <- plot_ly(\n    x = ~DateTimeNum,\n    y = ~Station,\n    z = ~temp_change,\n    data = temp_changes,\n    type = \"heatmap\",\n    colors = colors,\n    zmin = -max_abs_change,\n    zmax = max_abs_change,\n    hoverongaps = FALSE,\n    hovertemplate = paste(\n      \"Station: %{y}<br>\",\n      \"Time: %{customdata}<br>\",\n      \"Temperature: %{text}°C<br>\",\n      \"Change: %{z:.1f}°C<br>\",\n      \"<extra><\/extra>\"\n    ),\n    customdata = ~format(OriginalDateTime, \"%Y-%b-%d %H:%M:%S\"),\n    text = ~sprintf(\"%.1f\", Temp)\n  ) %>%\n    layout(\n      title = list(\n        text = \"Hourly Temperature Changes by Station\",\n        font = list(size = 16)\n      ),\n      xaxis = list(\n        title = \"Time\",\n        tickfont = list(size = 10),\n        tickangle = -45,\n        range = c(common_start_date, max(temp_changes$DateTimeNum)),\n        rangemode = \"tozero\"\n      ),\n      yaxis = list(\n        title = \"Station\",\n        tickfont = list(size = 10)\n      ),\n      margin = list(t = 50, b = 80, l = 120, r = 50),\n      paper_bgcolor = \"#FFFFFF\",\n      plot_bgcolor = \"#FFFFFF\"\n    )\n  \n  return(p)\n}\ncreate_temp_range_plot <- function(temp_data) {\n  if (is.null(temp_data) || nrow(temp_data) == 0) {\n    return(plot_ly() %>% \n           layout(title = \"No temperature data available\"))\n  }\n  \n  # Set fixed temperature range\n  x_min <- -40\n  x_max <- 50\n  \n  # Calculate station statistics with timestamps\n  station_stats <- temp_data %>%\n    group_by(Station) %>%\n    filter(complete.cases(Temp)) %>%  # Only include rows where Temp is not NA\n    summarise(\n      mean_temp = if(n() > 0) mean(Temp, na.rm = TRUE) else NA,\n      max_temp = if(n() > 0) max(Temp, na.rm = TRUE) else NA,\n      min_temp = if(n() > 0) min(Temp, na.rm = TRUE) else NA,\n      sd_temp = if(n() > 0) sd(Temp, na.rm = TRUE) else NA,\n      max_temp_time = if(n() > 0) DateTimeNum[which.max(Temp)] else NA,\n      min_temp_time = if(n() > 0) DateTimeNum[which.min(Temp)] else NA,\n      data_count = n()\n    ) %>%\n    filter(data_count > 0) %>%  # Only include stations with valid readings\n    arrange(desc(mean_temp))\n  \n  station_order <- station_stats$Station\n  \n  # Initialize plot\n  p <- plot_ly()\n  \n  # Enhanced spacing parameters\n  y_step <- 5\n  station_positions <- seq_along(station_order)\n  names(station_positions) <- rev(station_order)\n  \n  # Create color scale based on mean temperatures\n  mean_temp_range <- range(station_stats$mean_temp, na.rm = TRUE)\n  \n  # Custom color palette for mean temperature gradient\n  temp_colors <- colorRampPalette(c(\n    \"#313695\", # Deep blue (coldest)\n    \"#4575B4\", # Blue\n    \"#74ADD1\", # Light blue\n    \"#ABD9E9\", # Very light blue\n    \"#E0F3F8\", # Pale blue\n    \"#FFFFBF\", # Pale yellow\n    \"#FEE090\", # Light orange\n    \"#FDAE61\", # Orange\n    \"#F46D43\", # Dark orange\n    \"#D73027\"  # Deep red (warmest)\n  ))(100)\n  \n  # Process each station's data\n  for (i in seq_along(station_order)) {\n    station_name <- station_order[i]\n    station_data <- temp_data %>% \n      filter(Station == station_name) %>%\n      filter(complete.cases(Temp))  # Filter out NA values\n    \n    base_y <- station_positions[station_name] * y_step\n    \n    if (nrow(station_data) > 0) {\n      clean_temps <- station_data$Temp\n      \n      if (length(clean_temps) > 0) {\n        adjust_factor <- 0.8\n        \n        dens <- try(density(clean_temps,\n                       adjust = adjust_factor,\n                       n = 1024,\n                       kernel = \"gaussian\",\n                       from = x_min,\n                       to = x_max), silent = TRUE)\n        \n        if (!inherits(dens, \"try-error\")) {\n          scale_factor <- 1.8\n          normalized_density <- dens$y / max(dens$y) * scale_factor\n          \n          y_values <- base_y + normalized_density * y_step\n          y_baseline <- rep(base_y, length(dens$x))\n          \n          stats <- station_stats %>% filter(Station == station_name)\n          \n          # Calculate color index based on mean temperature\n          color_pos <- (stats$mean_temp - mean_temp_range[1]) / \n                      (mean_temp_range[2] - mean_temp_range[1])\n          color_index <- 1 + floor(color_pos * 99)\n          station_color <- temp_colors[color_index]\n          \n          # Create semi-transparent version for fill\n          fill_color <- sprintf(\"rgba(%d, %d, %d, 0.3)\",\n                              col2rgb(station_color)[1],\n                              col2rgb(station_color)[2],\n                              col2rgb(station_color)[3])\n          \n          # Simplified hover text without valid readings count\n          hover_text <- sprintf(\n            \"Station: %s<br>Mean: %.1f°C<br>Max: %.1f°C at %s<br>Min: %.1f°C at %s<br>Std Dev: %.1f°C\",\n            station_name, \n            stats$mean_temp,\n            stats$max_temp,\n            stats$max_temp_time,\n            stats$min_temp,\n            stats$min_temp_time,\n            stats$sd_temp\n          )\n          \n          p <- p %>% add_trace(\n            x = dens$x,\n            y = y_baseline,\n            type = 'scatter',\n            mode = 'lines',\n            line = list(\n              width = 0.25,\n              color = sprintf(\"rgba(%d, %d, %d, 0.05)\",\n                            col2rgb(station_color)[1],\n                            col2rgb(station_color)[2],\n                            col2rgb(station_color)[3])\n            ),\n            showlegend = FALSE,\n            hoverinfo = 'skip'\n          )\n          \n          p <- p %>% add_trace(\n            x = dens$x,\n            y = y_values,\n            type = 'scatter',\n            mode = 'lines',\n            fill = 'tonexty',\n            fillcolor = fill_color,\n            line = list(\n              color = station_color,\n              width = 2,\n              shape = 'spline'\n            ),\n            showlegend = FALSE,\n            text = hover_text,\n            hoverinfo = 'text'\n          )\n        }\n      }\n    }\n  }\n  \n  # Add a colorbar to show temperature scale\n  p <- p %>% add_trace(\n    x = c(x_min),\n    y = c(0),\n    type = \"scatter\",\n    mode = \"markers\",\n    marker = list(\n      colorscale = list(\n        list(0, temp_colors[1]),\n        list(1, temp_colors[length(temp_colors)])\n      ),\n      showscale = TRUE,\n      colorbar = list(\n        title = \"Mean Temperature (°C)\",\n        len = 0.5,\n        y = 0.5\n      ),\n      cmin = mean_temp_range[1],\n      cmax = mean_temp_range[2]\n    ),\n    showlegend = FALSE,\n    hoverinfo = \"none\",\n    visible = FALSE\n  )\n  \n  p %>% layout(\n    title = list(\n      text = \"Temperature Distribution by Station\",\n      font = list(size = 18)\n    ),\n    xaxis = list(\n      title = \"Temperature (°C)\",\n      range = c(x_min, x_max),\n      gridcolor = '#E2E2E2',\n      showgrid = TRUE,\n      zeroline = FALSE,\n      tickfont = list(size = 12),\n      dtick = 10\n    ),\n    yaxis = list(\n      title = \"\",\n      showgrid = FALSE,\n      zeroline = FALSE,\n      ticktext = rev(station_order),\n      tickvals = seq_along(station_order) * y_step,\n      tickmode = \"array\",\n      tickfont = list(size = 12)\n    ),\n    showlegend = FALSE,\n    hovermode = \"closest\",\n    plot_bgcolor = \"#f8f8f8\",\n    paper_bgcolor = \"#f8f8f8\",\n    margin = list(t = 50, b = 50, l = 120, r = 50)\n  )\n}\n# Create summary bar chart for constant temperature periods\ncreate_constant_temp_summary <- function(constant_temp_data, selected_station = NULL) {\n  if (is.null(constant_temp_data) || length(constant_temp_data) == 0) {\n    return(plot_ly() %>% layout(title = \"No temperature data available\"))\n  }\n  \n  # Filter data based on selected station\n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    if (!selected_station %in% names(constant_temp_data)) {\n      return(plot_ly() %>% layout(title = \"No data available for selected station\"))\n    }\n    constant_temp_data <- constant_temp_data[selected_station]\n  }\n  \n  # Calculate summary statistics for each station and each constant temperature span\n  summary_data <- lapply(names(constant_temp_data), function(station_name) {\n    results <- constant_temp_data[[station_name]]\n    if (!is.null(results) && nrow(results) > 0) {\n      clean_station_name <- sub(\"^dbo\\\\.\", \"\", station_name)\n      \n      # Create a data frame with individual spans\n      spans <- data.frame(\n        Station = clean_station_name,\n        Temperature = results$temp,\n        Percentage = results$percentage_constant\n      )\n      \n      # Sort by percentage contribution (descending)\n      spans <- spans[order(-spans$Percentage), ]\n      \n      # Add cumulative sum for stacking\n      spans$cumsum <- cumsum(spans$Percentage)\n      spans$cumsum_prev <- c(0, head(spans$cumsum, -1))\n      \n      return(spans)\n    }\n  })\n  \n  # Remove NULL entries and combine all summaries\n  summary_df <- do.call(rbind, summary_data[!sapply(summary_data, is.null)])\n  \n  if (is.null(summary_df) || nrow(summary_df) == 0) {\n    return(plot_ly() %>% layout(title = \"No temperature data available\"))\n  }\n  \n  # Sort stations by total constant temperature percentage\n  station_totals <- aggregate(Percentage ~ Station, summary_df, sum)\n  station_order <- station_totals$Station[order(-station_totals$Percentage)]\n  summary_df$Station <- factor(summary_df$Station, levels = station_order)\n  \n  # Create the horizontal stacked bar chart\n  p <- plot_ly(height = 400) %>%\n    add_trace(\n      data = summary_df,\n      y = ~Station,\n      x = ~Percentage,\n      customdata = ~Temperature,\n      type = \"bar\",\n      orientation = 'h',\n      marker = list(\n        color = ~Temperature,\n        colorscale = 'Viridis',\n        showscale = TRUE,\n        colorbar = list(\n          title = \"Temperature (°C)\",\n          len = 0.5,\n          y = 0.5\n        )\n      ),\n      text = ~sprintf(\"%.1f°C (%.1f%%)\", Temperature, Percentage),\n      textposition = \"auto\",\n      hovertemplate = paste(\n        \"Station: %{y}<br>\",\n        \"Temperature: %{customdata}°C<br>\",\n        \"Contribution: %{x:.1f}%<br>\",\n        \"<extra><\/extra>\"\n      )\n    ) %>%\n    layout(\n      barmode = \"stack\",\n      showlegend = FALSE,\n      margin = list(t = 50, b = 80, l = 120, r = 20),\n      xaxis = list(\n        title = list(\n          text = \"Percentage of Time (%)\",\n          standoff = 25\n        ),\n        range = c(0, 100)\n      ),\n      yaxis = list(\n        title = \"\",\n        automargin = TRUE\n      ),\n      title = list(\n        text = \"Constant Temperature Spans by Station\",\n        font = list(size = 14)\n      ),\n      paper_bgcolor = \"#FFFFFF\",\n      plot_bgcolor = \"#FFFFFF\"\n    )\n  \n  return(p)\n}\n\n\ncreate_constant_temp_plot <- function(constant_temp_data, selected_station) {\n  # Input validation\n  if (is.null(constant_temp_data) || length(constant_temp_data) == 0) {\n    return(plot_ly() %>% layout(title = \"No temperature data available\"))\n  }\n  \n  # Filter data based on selected station\n  temp_data <- constant_temp_data\n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    if (!selected_station %in% names(temp_data)) {\n      return(plot_ly() %>% layout(title = \"No data available for selected station\"))\n    }\n    temp_data <- temp_data[selected_station]\n  }\n  \n  # Initialize data frame for plot data\n  plot_data <- data.frame(\n    station = character(),\n    start_time = as.POSIXct(character()),\n    datetime_str = character(),\n    percentage = numeric(),\n    temperature = numeric(),\n    duration = numeric(),\n    angle = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  # Process data for each station\n  for (table_name in names(temp_data)) {\n    results <- temp_data[[table_name]]\n    if (!is.null(results) && nrow(results) > 0) {\n      clean_table_name <- sub(\"^dbo\\\\.\", \"\", table_name)\n      \n      for (i in seq_len(nrow(results))) {\n        # Convert start time safely\n        start_time <- if (inherits(results$period_start[i], \"POSIXct\")) {\n          results$period_start[i]\n        } else {\n          as.POSIXct(results$period_start[i], format = \"%Y-%m-%d %H:%M:%S\", tz = \"UTC\")\n        }\n        \n        if (!is.na(start_time)) {\n          # Calculate angle for polar plot (24-hour clock)\n          hour <- as.numeric(format(start_time, \"%H\"))\n          minute <- as.numeric(format(start_time, \"%M\"))\n          angle <- (90 - (hour + minute/60) * 360 / 24) %% 360\n          \n          # Add row to plot data\n          new_row <- data.frame(\n            station = clean_table_name,\n            start_time = start_time,\n            datetime_str = format(start_time, \"%Y-%b-%d %H:%M:%S\"),\n            percentage = results$percentage_constant[i],\n            temperature = results$temp[i],\n            duration = results$duration_entries[i],\n            angle = angle,\n            stringsAsFactors = FALSE\n          )\n          plot_data <- rbind(plot_data, new_row)\n        }\n      }\n    }\n  }\n  \n  # Check if we have any data to plot\n  if (nrow(plot_data) == 0) {\n    return(plot_ly(height = 400) %>% \n           layout(title = \"No constant temperature periods found\"))\n  }\n  \n  # Create hover text\n  plot_data$hover_text <- with(plot_data, \n    sprintf(\n      \"Station: %s<br>Start Time: %s<br>Temperature: %.2f°C<br>Duration: %d entries<br>Percentage: %.1f%%\",\n      station, datetime_str, temperature, duration, percentage\n    )\n  )\n  \n  # Create the polar plot\n  p <- plot_ly(\n    data = plot_data,\n    r = ~percentage,\n    theta = ~angle,\n    type = \"scatterpolar\",\n    mode = \"markers\",\n    text = ~hover_text,\n    hoverinfo = \"text\",\n    marker = list(\n      color = ~temperature,\n      colorscale = \"Viridis\",\n      colorbar = list(\n        title = \"Temperature (°C)\",\n        len = 0.5,\n        y = 0.5\n      ),\n      showscale = TRUE,\n      size = 12,\n      symbol = \"circle\",\n      line = list(\n        color = '#000000',\n        width = 1\n      )\n    )\n  ) %>%\n    layout(\n      polar = list(\n        radialaxis = list(\n          title = \"Percentage of Total Readings\",\n          range = c(0, max(plot_data$percentage, na.rm = TRUE) * 1.1),\n          ticksuffix = \"%\",\n          gridcolor = '#E2E2E2',\n          tickfont = list(size = 10)\n        ),\n        angularaxis = list(\n          ticktext = c(\"00:00\", \"06:00\", \"12:00\", \"18:00\"),\n          tickvals = c(90, 0, 270, 180),\n          direction = \"counterclockwise\",\n          rotation = 0,\n          gridcolor = '#E2E2E2',\n          tickfont = list(size = 10)\n        )\n      ),\n      showlegend = FALSE,\n      title = list(\n        text = \"Constant Temperature Periods by Time of Day\",\n        font = list(size = 16)\n      ),\n      paper_bgcolor = \"#FFFFFF\",\n      plot_bgcolor = \"#FFFFFF\",\n      margin = list(t = 50, b = 50, l = 50, r = 50)\n    )\n  \n  return(p)\n}\n","type":"text"},{"name":"data/r/temperature_module/temperature_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/temperature_module/temperature_functions.R\n\ndetect_extreme_temps <- function(wx_data, high_threshold = 40, low_threshold = -40) {\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    return(NULL)\n  }\n  \n  extreme_temps <- list()\n  \n  for (station_name in names(wx_data)) {\n    station_data <- wx_data[[station_name]]\n    \n    if (!is.null(station_data) && \"Temp\" %in% names(station_data) && nrow(station_data) > 0) {\n      station_data$Temp <- as.numeric(station_data$Temp)\n      \n      high_temps <- station_data[station_data$Temp >= high_threshold, ]\n      low_temps <- station_data[station_data$Temp <= low_threshold, ]\n      \n      if (nrow(high_temps) > 0 || nrow(low_temps) > 0) {\n        clean_station_name <- sub(\"^dbo\\\\.\", \"\", station_name)\n        extreme_temps[[clean_station_name]] <- list(\n          high_temps = if(nrow(high_temps) > 0) {\n            data.frame(\n              time = high_temps$DateTimeNum,\n              temp = high_temps$Temp,\n              stringsAsFactors = FALSE\n            )\n          } else NULL,\n          low_temps = if(nrow(low_temps) > 0) {\n            data.frame(\n              time = low_temps$DateTimeNum,\n              temp = low_temps$Temp,\n              stringsAsFactors = FALSE\n            )\n          } else NULL\n        )\n      }\n    }\n  }\n  \n  return(extreme_temps)\n}\n\n\nanalyze_temp_patterns <- function(temp_changes, change_threshold = 5, variability_window = 3, sd_threshold = 4) {\n  if (is.null(temp_changes) || nrow(temp_changes) == 0) {\n    return(NULL)\n  }\n  \n  stations <- unique(temp_changes$Station)\n  results <- list()\n  \n  for (station in stations) {\n    station_data <- temp_changes %>%\n      filter(Station == station) %>%\n      arrange(DateTimeNum)\n    \n    if (nrow(station_data) < variability_window) {\n      next\n    }\n    \n    # Identify rapid changes\n    rapid_changes <- station_data %>%\n      filter(abs(temp_change) >= change_threshold) %>%\n      mutate(\n        change_type = ifelse(temp_change > 0, \"Warming\", \"Cooling\")\n      ) %>%\n      arrange(desc(abs(temp_change)))\n    \n    # Calculate rolling standard deviation for variability\n    station_data <- station_data %>%\n      mutate(\n        rolling_sd = rollapply(temp_change, width = variability_window, \n                             FUN = sd, fill = NA, align = \"right\")\n      )\n    \n    variable_periods <- station_data %>%\n      filter(rolling_sd >= sd_threshold) %>%\n      arrange(desc(rolling_sd))\n    \n    results[[station]] <- list(\n      rapid_changes = rapid_changes,\n      variable_periods = variable_periods\n    )\n    \n    # Add summary statistics\n    if (nrow(rapid_changes) > 0 || nrow(variable_periods) > 0) {\n      attr(results[[station]], \"summary\") <- list(\n        total_rapid_changes = nrow(rapid_changes),\n        max_change = if(nrow(rapid_changes) > 0) max(abs(rapid_changes$temp_change)) else 0,\n        mean_change = if(nrow(rapid_changes) > 0) mean(abs(rapid_changes$temp_change)) else 0,\n        warming_count = if(nrow(rapid_changes) > 0) sum(rapid_changes$temp_change > 0) else 0,\n        cooling_count = if(nrow(rapid_changes) > 0) sum(rapid_changes$temp_change < 0) else 0,\n        variable_periods = nrow(variable_periods),\n        max_variability = if(nrow(variable_periods) > 0) max(variable_periods$rolling_sd, na.rm = TRUE) else 0\n      )\n    }\n  }\n  \n  return(results)\n}\ncalculate_hourly_temp_changes <- function(wx_data) {\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    return(NULL)\n  }\n  \n  # Initialize empty data frame for results\n  all_changes <- data.frame()\n  \n  # Process each station\n  for (station_name in names(wx_data)) {\n    station_data <- wx_data[[station_name]]\n    \n    if (!is.null(station_data) && \"Temp\" %in% names(station_data) && nrow(station_data) > 0) {\n      # Convert DateTimeNum to POSIXct if it's character\n      if (is.character(station_data$DateTimeNum)) {\n        station_data$DateTimeNum <- as.POSIXct(station_data$DateTimeNum, \n                                              format = \"%Y-%b-%d %H:%M:%S\", \n                                              tz = \"UTC\")\n      }\n      \n      # Calculate temperature changes\n      changes <- station_data %>%\n        arrange(DateTimeNum) %>%\n        mutate(\n          Temp = as.numeric(Temp),\n          temp_change = lead(Temp) - Temp,\n          Station = sub(\"^dbo\\\\.\", \"\", station_name)\n        ) %>%\n        select(Station, DateTimeNum, temp_change) %>%\n        filter(!is.na(temp_change))\n      \n      all_changes <- rbind(all_changes, changes)\n    }\n  }\n  \n  return(all_changes)\n}\n\n#Function to find contant temp periods\nfind_constant_temp_periods <- function(data, min_entries = 4) {\n  # Check if data is empty or NULL\n  if (is.null(data) || nrow(data) == 0) {\n    return(data.frame(\n      period_id = integer(0),\n      period_start = as.POSIXct(character(0)),\n      period_end = as.POSIXct(character(0)),\n      duration_entries = integer(0),\n      temp = numeric(0),\n      percentage_constant = numeric(0)\n    ))\n  }\n  \n  # Convert DateTimeNum to POSIXct if it's character\n  data$DateTimeNum <- if(is.character(data$DateTimeNum)) {\n    as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n  } else {\n    data$DateTimeNum\n  }\n  \n  # Handle NA values and create groups\n  result <- data %>%\n    arrange(DateTimeNum) %>%\n    mutate(\n      temp_change = Temp != lag(Temp, default = first(Temp)),\n      period_id = cumsum(temp_change)\n    ) %>%\n    group_by(period_id) %>%\n    summarize(\n      period_start = first(DateTimeNum),\n      period_end = last(DateTimeNum),\n      duration_entries = n(),\n      temp = first(Temp),\n      .groups = 'drop'  # Explicitly drop grouping\n    ) %>%\n    filter(duration_entries >= min_entries)\n  \n  # Calculate percentage of entries that are constant\n  if (nrow(result) > 0) {\n    total_entries <- nrow(data)\n    total_constant_entries <- sum(result$duration_entries)\n    result$percentage_constant <- (result$duration_entries / total_entries) * 100\n    \n    # Add overall percentage as an attribute\n    attr(result, \"overall_percentage\") <- (total_constant_entries / total_entries) * 100\n  } else {\n    result$percentage_constant <- numeric(0)\n    attr(result, \"overall_percentage\") <- 0\n  }\n  \n  return(result)\n}\n#Function to find rapid temp changes\nfind_rapid_temp_changes <- function(data, threshold = 8) {\n        data %>%\n          arrange(DateTimeNum) %>%\n          mutate(\n            Temp = as.numeric(as.character(Temp)),\n            temp_diff = abs(lead(Temp) - Temp),\n            rapid_change = temp_diff >= threshold,\n            change_type = ifelse(lead(Temp) > Temp, \"Warming\", \"Cooling\")\n          ) %>%\n          filter(rapid_change) %>%\n          select(DateTimeNum, Temp, temp_diff, change_type) %>%\n          arrange(DateTimeNum)\n      }\n","type":"text"},{"name":"data/r/temperature_module/temperature_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/temperature_module/temperature_output.R\n\nrender_extreme_temp_output <- function(wx_data) {\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    cat(\"No data available for analysis.\\n\")\n    return(invisible())\n  }\n  \n  extreme_temps <- detect_extreme_temps(wx_data)\n  \n  cat(\"Identifies temperatures >= 40°C or <= -40°C\\n\")\n  cat(\"----------------------------------------\\n\\n\")\n  \n  if (is.null(extreme_temps) || length(extreme_temps) == 0) {\n    cat(\"No extreme temperatures detected in any station.\\n\")\n    return(invisible())\n  }\n  \n  # Process high temperatures first\n  has_high_temps <- FALSE\n  for (station_name in names(extreme_temps)) {\n    if (!is.null(extreme_temps[[station_name]]$high_temps) && \n        nrow(extreme_temps[[station_name]]$high_temps) > 0) {\n      \n      # Filter out NA values\n      high_temps <- extreme_temps[[station_name]]$high_temps\n      high_temps <- high_temps[!is.na(high_temps$temp), ]\n      \n      if (nrow(high_temps) > 0) {\n        if (!has_high_temps) {\n          cat(\"High Temperature Events (>= 40°C):\\n\")\n          has_high_temps <- TRUE\n        }\n        cat(sprintf(\"\\n%s:\\n\", station_name))\n        for (i in 1:nrow(high_temps)) {\n          cat(sprintf(\"  %s: %.1f°C\\n\",\n                     high_temps$time[i],\n                     high_temps$temp[i]))\n        }\n      }\n    }\n  }\n  \n  # Process low temperatures\n  has_low_temps <- FALSE\n  for (station_name in names(extreme_temps)) {\n    if (!is.null(extreme_temps[[station_name]]$low_temps) && \n        nrow(extreme_temps[[station_name]]$low_temps) > 0) {\n      \n      # Filter out NA values\n      low_temps <- extreme_temps[[station_name]]$low_temps\n      low_temps <- low_temps[!is.na(low_temps$temp), ]\n      \n      if (nrow(low_temps) > 0) {\n        if (!has_low_temps) {\n          if (has_high_temps) cat(\"\\n\") # Add spacing between sections\n          cat(\"Low Temperature Events (<= -40°C):\\n\")\n          has_low_temps <- TRUE\n        }\n        cat(sprintf(\"\\n%s:\\n\", station_name))\n        for (i in 1:nrow(low_temps)) {\n          cat(sprintf(\"  %s: %.1f°C\\n\",\n                     low_temps$time[i],\n                     low_temps$temp[i]))\n        }\n      }\n    }\n  }\n  \n  if (!has_high_temps && !has_low_temps) {\n    cat(\"No extreme temperatures found.\\n\")\n  }\n  \n  invisible()\n}\n#' Render constant temperature output\n#' @param input Shiny input object\n#' @param constant_temp_data Reactive expression containing constant temperature data\nrender_temp_check <- function(input, constant_temp_data) {\n\ncat(\"Detects constant temperature spans > 3 consecutive hours.\\n\")\n\n  if (is.null(constant_temp_data) || length(constant_temp_data) == 0) {\n    cat(\"No temperature data available.\")\n    return()\n  }\n  \n  constant_temp <- constant_temp_data\n  selected_station <- input$constant_temp_station_select\n  \n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    if (!selected_station %in% names(constant_temp)) {\n      cat(\"No data available for selected station.\")\n      return()\n    }\n    constant_temp <- constant_temp[selected_station]\n  }  \n  for (table_name in names(constant_temp)) {\n    results <- constant_temp[[table_name]]\n    if (nrow(results) > 0) {\n      clean_table_name <- sub(\"^dbo\\\\.\", \"\", table_name)\n      overall_percentage <- attr(results, \"overall_percentage\")\n      \n      cat(\"\\n\", clean_table_name, \"\\n\", sep = \"\")\n      cat(sprintf(\"Overall %.1f%% of hourly readings contribute to constant temperature spans > 4 consecutive hours\\n\", overall_percentage))\n      \n      for (i in seq_len(nrow(results))) {\n        row <- results[i, ]\n        cat(\"\\nConstant Temperature Period\\n\")\n        cat(sprintf(\"Start Time: %s\\n\", format(row$period_start, \"%Y-%m-%d %H:%M:%S\")))\n        cat(sprintf(\"End Time: %s\\n\", format(row$period_end, \"%Y-%m-%d %H:%M:%S\")))\n        cat(sprintf(\"Entries: %d (%.1f%% of total readings)\\n\", \n                   row$duration_entries, row$percentage_constant))\n        cat(sprintf(\"Temperature: %.2f°C\\n\", row$temp))\n      }\n      cat(paste(rep(\"=\", 80), collapse = \"\"), \"\\n\")\n    }\n  }\n}\n#' Render rapid temperature changes output\n#' @param WX_stations List of weather station data\nrender_rapid_temp_changes_output <- function(WX_stations) {\n  results_list <- list()\n  \n  for (table_name in names(WX_stations)) {\n    data <- WX_stations[[table_name]]\n    \n    rapid_changes <- find_rapid_temp_changes(data)\n    \n    if (nrow(rapid_changes) > 0) {\n      results_list[[table_name]] <- rapid_changes\n    }\n  }\n  \n  if (length(results_list) > 0) {\n    cat(\"\\nRapid Temperature Changes Detected, 8°C threshold:\\n\")\n    cat(\"--------------------------\\n\")\n    \n    for (table_name in names(results_list)) {\n      clean_table_name <- sub(\"^dbo\\\\.\", \"\", table_name)\n      \n      cat(\"\\n\", clean_table_name, \"\\n\", sep = \"\")\n      \n      rapid_changes <- results_list[[table_name]]\n      \n      apply(rapid_changes, 1, function(row) {\n        cat(sprintf(\"%s | Temp: %.2f°C | Change: %.2f°C | %s\\n\",\n                    row[\"DateTimeNum\"], \n                    as.numeric(row[\"Temp\"]), \n                    as.numeric(row[\"temp_diff\"]),\n                    row[\"change_type\"]))\n      })\n    }\n  } else {\n    cat(\"No rapid temperature changes (≥8°C/hour) found\\n\")\n  }\n}\n\nrender_erratic_temp_output <- function(wx_data, selected_station = NULL) {\n  # Initial data validation\n  if (is.null(wx_data) || length(wx_data) == 0) {\n    cat(\"No data available for analysis.\\n\")\n    return(invisible(NULL))\n  }\n  \n  # Filter data based on selected station\n  if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    wx_data <- wx_data[selected_station]\n  }\n  \n  temp_changes <- calculate_hourly_temp_changes(wx_data)\n  \n  if (is.null(temp_changes) || nrow(temp_changes) == 0) {\n    cat(\"No temperature change data available for analysis.\\n\")\n    return(invisible(NULL))\n  }\n  \n  results <- analyze_temp_patterns(temp_changes, \n                                 change_threshold = 5, \n                                 variability_window = 3, \n                                 sd_threshold = 4)\n  \n  if (is.null(results) || length(results) == 0) {\n    # Print analysis criteria even when no results are found\n    cat(\"Temperature Change Analysis\\n\")\n    cat(\"Identifies:\\n\")\n    cat(\"1. Temperature changes of 5°C or more between consecutive hourly readings\\n\")\n    cat(\"2. Periods of high variability (SD > 4°C over 3 consecutive hours)\\n\\n\")\n    cat(\"No significant temperature patterns detected in any stations.\\n\")\n    return(invisible(NULL))\n  }\n  \n  # Check if any station has actual results\n  has_results <- FALSE\n  for (station in names(results)) {\n    station_results <- results[[station]]\n    if (!is.null(station_results)) {\n      summary_stats <- attr(station_results, \"summary\")\n      if (!is.null(summary_stats) && \n          ((!is.null(summary_stats$total_rapid_changes) && summary_stats$total_rapid_changes > 0) ||\n           (!is.null(summary_stats$variable_periods) && summary_stats$variable_periods > 0))) {\n        has_results <- TRUE\n        break\n      }\n    }\n  }\n  \n  if (!has_results) {\n    cat(\"Temperature Change Analysis\\n\")\n    cat(\"Identifies:\\n\")\n    cat(\"1. Temperature changes of 5°C or more between consecutive hourly readings\\n\")\n    cat(\"2. Periods of high variability (SD > 4°C over 3 consecutive hours)\\n\\n\")\n    cat(\"No significant temperature patterns detected in any stations.\\n\")\n    return(invisible(NULL))\n  }\n  \n  # Print analysis header\n  cat(\"Temperature Change Analysis\\n\")\n  cat(\"Identifies:\\n\")\n  cat(\"1. Temperature changes of 5°C or more between consecutive hourly readings\\n\")\n  cat(\"2. Periods of high variability (SD > 4°C over 3 consecutive hours)\\n\\n\")\n  \n  # Process each station\n  for (station in names(results)) {\n    station_results <- results[[station]]\n    if (is.null(station_results)) next\n    \n    summary_stats <- attr(station_results, \"summary\")\n    if (is.null(summary_stats)) next\n    \n    # Skip stations with no significant patterns\n    if ((!is.null(summary_stats$total_rapid_changes) && summary_stats$total_rapid_changes == 0) &&\n        (!is.null(summary_stats$variable_periods) && summary_stats$variable_periods == 0)) {\n      next\n    }\n    \n    cat(sprintf(\"=== %s ===\\n\", station))\n    \n    # Rapid changes section\n    if (!is.null(summary_stats$total_rapid_changes) && summary_stats$total_rapid_changes > 0) {\n      cat(\"\\nRapid Changes:\\n\")\n      cat(sprintf(\"Total rapid changes: %d (%d warming, %d cooling)\\n\", \n                 summary_stats$total_rapid_changes,\n                 summary_stats$warming_count,\n                 summary_stats$cooling_count))\n      cat(sprintf(\"Maximum change: %.1f°C\\n\", summary_stats$max_change))\n      \n      if (!is.null(station_results$rapid_changes) && nrow(station_results$rapid_changes) > 0) {\n        cat(\"\\nLargest temperature changes:\\n\")\n        top_changes <- head(station_results$rapid_changes, 3)\n        for (i in seq_len(nrow(top_changes))) {\n          cat(sprintf(\n            \"%s - %s of %.1f°C\\n\",\n            format(top_changes$DateTimeNum[i], \"%Y-%b-%d %H:%M:%S\"),\n            top_changes$change_type[i],\n            abs(top_changes$temp_change[i])\n          ))\n        }\n      }\n    }\n    \n    # Variable periods section\n    if (!is.null(summary_stats$variable_periods) && summary_stats$variable_periods > 0) {\n      cat(\"\\nPeriods of High Variability:\\n\")\n      cat(sprintf(\"Number of variable periods: %d\\n\", summary_stats$variable_periods))\n      cat(sprintf(\"Maximum variability (SD): %.1f°C\\n\", summary_stats$max_variability))\n      \n      if (!is.null(station_results$variable_periods) && nrow(station_results$variable_periods) > 0) {\n        cat(\"\\nMost variable periods:\\n\")\n        top_variable <- head(station_results$variable_periods, 3)\n        for (i in seq_len(nrow(top_variable))) {\n          cat(sprintf(\n            \"%s - SD: %.1f°C\\n\",\n            format(top_variable$DateTimeNum[i], \"%Y-%b-%d %H:%M:%S\"),\n            top_variable$rolling_sd[i]\n          ))\n        }\n      }\n    }\n    \n    if (station != tail(names(results), 1)) {\n      cat(\"\\n\", paste(rep(\"-\", 50), collapse = \"\"), \"\\n\")\n    }\n  }\n}\n","type":"text"},{"name":"data/r/wind_module/wind_charts.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# r/wind_module/wind_charts.R\n\ncreate_zero_wspd_plot <- function(zero_wspd_data, selected_station) {\n  # Return empty plot if no data is available\n  if (is.null(zero_wspd_data)) {\n    return(plot_ly() %>% \n           layout(title = \"No data available - please fetch data first\",\n                 xaxis = list(title = \"Date and Time\"),\n                 yaxis = list(title = \"Station\")))\n  }\n  \n  # Filter stations based on selection\n  stations_to_display <- if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    selected_station\n  } else {\n    names(zero_wspd_data)\n  }\n  \n  # Handle case where no stations are available\n  if (length(stations_to_display) == 0) {\n    return(plot_ly() %>% \n           layout(title = \"No stations available\",\n                 xaxis = list(title = \"Date and Time\"),\n                 yaxis = list(title = \"Station\")))\n  }\n  \n  # Combine data from selected stations\n  plot_data <- do.call(rbind, lapply(stations_to_display, function(station) {\n    if (is.null(zero_wspd_data[[station]])) return(NULL)\n    results <- zero_wspd_data[[station]]\n    if (nrow(results) > 0) {\n      results$Station <- sub(\"dbo\\\\.\", \"\", station)\n      return(results)\n    }\n    return(NULL)\n  }))\n  \n  if (is.null(plot_data) || nrow(plot_data) == 0) {\n    return(plot_ly() %>% \n           layout(title = \"No hourly zero Wspd blocks detected\",\n                 xaxis = list(title = \"Date and Time\"),\n                 yaxis = list(title = \"Station\")))\n  }\n  \n  # Check if each period is ongoing\n  current_time <- Sys.time()\n  plot_data$is_ongoing <- abs(difftime(plot_data$period_end, current_time, units=\"mins\")) < 60\n  \n  # Calculate dynamic color scale range based on filtered data\n  color_range <- range(plot_data$dir_changes, na.rm = TRUE)\n  \n  p <- plot_ly() %>%\n    add_trace(\n      data = plot_data,\n      x = ~period_start,\n      y = ~Station,\n      type = 'scatter',\n      mode = 'markers',\n      marker = list(\n        size = ~count_consecutive/2 + 7,\n        color = ~dir_changes,\n        colorscale = 'Viridis',\n        colorbar = list(\n          title = \"Direction Changes\",\n          # Set dynamic range for color scale\n          cmin = color_range[1],\n          cmax = color_range[2]\n        )\n      ),\n      name = \"Zero Wind Speed Periods\",\n      text = ~paste(\n        \"Station:\", Station,\n        \"<br>Start:\", format(period_start, \"%Y-%m-%d %H:%M\"),\n        \"<br>End:\", ifelse(is_ongoing, \"Currently ongoing\", format(period_end, \"%Y-%m-%d %H:%M\")),\n        \"<br>Duration:\", count_consecutive, \"hours\",\n        \"<br>Direction Changes:\", dir_changes,\n        \"<br>Max Dir Change:\", round(max_dir_change, 1), \"°\",\n        ifelse(anomalous, \"<br>*** Flagged ***\", \"\")\n      ),\n      hoverinfo = 'text'\n    ) %>%\n    layout(\n      title = paste0(\n        \"Hourly Zero Wspd with Dir Changes\",\n        if (!is.null(selected_station) && selected_station != \"All Stations\") \n          paste0(\" - \", sub(\"dbo\\\\.\", \"\", selected_station))\n        else \"\"\n      ),\n      xaxis = list(title = \"Date and Time\"),\n      yaxis = list(title = \"Station\"),\n      showlegend = FALSE,\n      hoverlabel = list(bgcolor = \"white\")\n    )\n  \n  if (any(plot_data$anomalous)) {\n    anomalous_data <- plot_data[plot_data$anomalous, ]\n    p <- p %>%\n      add_trace(\n        data = anomalous_data,\n        x = ~period_start,\n        y = ~Station,\n        type = 'scatter',\n        mode = 'markers',\n        marker = list(\n          size = ~count_consecutive/2 + 10,\n          line = list(color = 'red', width = 2),\n          symbol = 'circle-open'\n        ),\n        name = \"Flagged\",\n        showlegend = FALSE\n      )\n  }\n  \n  return(p)\n}\n","type":"text"},{"name":"data/r/wind_module/wind_functions.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#r/wind_module/wind_functions.R\n\nget_most_recent_non_zero_wspd <- function(data) {\n  # Early returns if data is invalid\n  if (is.null(data) || nrow(data) == 0 || !\"Wspd\" %in% names(data)) {\n    return(NULL)\n  }\n  \n  # Handle date conversion\n  data$DateTimeNum <- if(is.character(data$DateTimeNum)) {\n    as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n  } else {\n    data$DateTimeNum\n  }\n  \n  # Find first non-zero, non-NA wind speed\n  valid_data <- data[!is.na(data$Wspd) & data$Wspd > 0, ]\n  \n  # Sort by date in descending order\n  valid_data <- valid_data[order(valid_data$DateTimeNum, decreasing = TRUE), ]\n  \n  # Return NULL if no valid entries found\n  if (nrow(valid_data) == 0) {\n    return(NULL)\n  }\n  \n  # Get the most recent entry\n  most_recent <- valid_data[1, ]\n  \n  return(list(\n    wind_speed = most_recent$Wspd,\n    date_time = most_recent$DateTimeNum\n  ))\n}\ncheck_high_wspd <- function(data, threshold = 60) {\n  high_wspd_info <- data.frame(\n    Table = character(),\n    DateTime = character(),\n    Type = character(),\n    Value = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  for (table_name in names(data)) {\n    df <- data[[table_name]]\n    \n    if (\"Wspd\" %in% colnames(df)) {\n      high_wspd_rows <- df[df$Wspd > threshold, ]\n      \n      if (nrow(high_wspd_rows) > 0) {\n        high_wspd_info <- rbind(high_wspd_info, data.frame(\n          Table = table_name,\n          DateTime = high_wspd_rows$DateTimeNum,\n          Type = \"Wspd\",\n          Value = high_wspd_rows$Wspd,\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n    \n    if (\"Mx_Spd\" %in% colnames(df)) {\n      high_mx_spd_rows <- df[df$Mx_Spd > threshold, ]\n      \n      if (nrow(high_mx_spd_rows) > 0) {\n        high_wspd_info <- rbind(high_wspd_info, data.frame(\n          Table = table_name,\n          DateTime = high_mx_spd_rows$DateTimeNum,\n          Type = \"Mx_Spd\",\n          Value = high_mx_spd_rows$Mx_Spd,\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n  }\n  \n  if (nrow(high_wspd_info) > 0) high_wspd_info else \"No Wspd or Mx_Spd values greater than 30 detected.\"\n}\n\n#HIGH WSPD CHECK FUNCTION\ncheck_high_wspd <- function(data, threshold = 60) {\n  high_wspd_info <- data.frame(\n    Table = character(),\n    DateTime = character(),\n    Type = character(),  \n    Value = numeric(),   \n    stringsAsFactors = FALSE\n  )\n  \n  for (table_name in names(data)) {\n    df <- data[[table_name]]\n    \n    # Check Wspd\n    if (\"Wspd\" %in% colnames(df)) {\n      high_wspd_rows <- df[df$Wspd > threshold, ]\n      \n      if (nrow(high_wspd_rows) > 0) {\n        high_wspd_info <- rbind(high_wspd_info, data.frame(\n          Table = table_name,\n          DateTime = high_wspd_rows$DateTimeNum,\n          Type = \"Wspd\",\n          Value = high_wspd_rows$Wspd,\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n    \n    # Check Mx_Spd\n    if (\"Mx_Spd\" %in% colnames(df)) {\n      high_mx_spd_rows <- df[df$Mx_Spd > threshold, ]\n      \n      if (nrow(high_mx_spd_rows) > 0) {\n        high_wspd_info <- rbind(high_wspd_info, data.frame(\n          Table = table_name,\n          DateTime = high_mx_spd_rows$DateTimeNum,\n          Type = \"Mx_Spd\",\n          Value = high_mx_spd_rows$Mx_Spd,\n          stringsAsFactors = FALSE\n        ))\n      }\n    }\n  }\n  \n  if (nrow(high_wspd_info) > 0) high_wspd_info else \"No Wspd or Mx_Spd values greater than 30 detected.\"\n}\n\n# Function to find zero wind speed periods with Mx_Spd range\nfind_zero_wspd_periods <- function(data, threshold = 12) {\n  if (is.null(data) || nrow(data) == 0) {\n    return(data.frame(\n      period_id = numeric(0),\n      period_start = as.POSIXct(character(0)),\n      period_end = as.POSIXct(character(0)),\n      count_consecutive = numeric(0),\n      dir_changes = numeric(0),\n      max_dir_change = numeric(0),\n      min_mx_spd = numeric(0),\n      max_mx_spd = numeric(0),\n      anomalous = logical(0)\n    ))\n  }\n  \n  data$DateTimeNum <- if(is.character(data$DateTimeNum)) {\n    as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n  } else {\n    data$DateTimeNum\n  }\n  \n  # Check if Mx_Spd column exists and has any non-NA values\n  has_mx_spd <- \"Mx_Spd\" %in% names(data) && any(!is.na(data$Mx_Spd))\n  \n  # First, ensure Dir column exists and handle missing values\n  if (!\"Dir\" %in% names(data)) {\n    data$Dir <- NA_real_\n  }\n  \n  result <- data %>%\n    arrange(DateTimeNum) %>%\n    mutate(\n      zero_wspd = ifelse(is.na(Wspd), FALSE, Wspd == 0),\n      shift_zero_wspd = lag(zero_wspd, default = FALSE),\n      change = zero_wspd != shift_zero_wspd,\n      period_id = cumsum(change),\n      # Calculate direction change only when both current and previous directions are valid\n      dir_change = case_when(\n        is.na(Dir) | is.na(lag(Dir)) ~ 0,\n        TRUE ~ abs(Dir - lag(Dir))\n      )\n    ) %>%\n    group_by(period_id) %>%\n    summarize(\n      period_start = min(DateTimeNum, na.rm = TRUE),\n      period_end = max(DateTimeNum, na.rm = TRUE),\n      count_consecutive = sum(zero_wspd, na.rm = TRUE),\n      # Only count significant direction changes (> 10 degrees)\n      dir_changes = sum(dir_change > 10, na.rm = TRUE),\n      # Handle case where all direction changes are NA\n      max_dir_change = ifelse(all(is.na(dir_change)), 0, max(dir_change, na.rm = TRUE)),\n      # Only calculate Mx_Spd statistics if the column exists and has valid data\n      min_mx_spd = if(has_mx_spd) {\n        mx_spd_values <- Mx_Spd[!is.na(Mx_Spd)]\n        if(length(mx_spd_values) > 0) min(mx_spd_values) else NA_real_\n      } else NA_real_,\n      max_mx_spd = if(has_mx_spd) {\n        mx_spd_values <- Mx_Spd[!is.na(Mx_Spd)]\n        if(length(mx_spd_values) > 0) max(mx_spd_values) else NA_real_\n      } else NA_real_,\n      .groups = 'drop'\n    ) %>%\n    mutate(\n      anomalous = count_consecutive >= threshold & dir_changes > 2\n    ) %>%\n    filter(count_consecutive >= threshold)\n  \n  return(result)\n}\n# Function to check current zero wind speed block\ncheck_current_zero_wspd_block <- function(data, zero_wspd_periods) {\n  data$DateTimeNum <- as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n  most_recent_entry <- data %>%\n    arrange(desc(DateTimeNum)) %>%\n    slice_head(n = 1)\n  \n  if (nrow(most_recent_entry) > 0) {\n    latest_time <- most_recent_entry$DateTimeNum\n    latest_wspd <- most_recent_entry$Wspd\n    \n    still_in_block <- any(zero_wspd_periods$period_start <= latest_time & \n                         zero_wspd_periods$period_end >= latest_time)\n    \n    return(list(\n      still_in_block = still_in_block,\n      most_recent_time = latest_time,\n      most_recent_wspd = latest_wspd\n    ))\n  }\n  \n  return(list(\n    still_in_block = FALSE,\n    most_recent_time = NULL,\n    most_recent_wspd = NULL\n  ))\n}\n\n# Function to find periods of constant wind direction with detailed wind analysis\nfind_constant_dir_periods <- function(data, min_entries = 4) {\n  # Return empty dataframe if data is invalid\n  if (is.null(data) || nrow(data) == 0 || !\"Dir\" %in% names(data)) {\n    return(data.frame(\n      period_id = integer(0),\n      period_start = character(0),\n      period_end = character(0),\n      duration_entries = integer(0),\n      dir = numeric(0),\n      before_dir = numeric(0),\n      before_time = character(0),\n      after_dir = numeric(0),\n      after_time = character(0),\n      avg_wspd = numeric(0),\n      max_wspd = numeric(0),\n      max_gust = numeric(0),\n      sustained_wind_count = numeric(0),\n      total_entries = numeric(0),\n      suspicious = logical(0)\n    ))\n  }\n\n  # Ensure datetime is in correct format\n  data$DateTimeNum <- if(is.character(data$DateTimeNum)) {\n    as.POSIXct(data$DateTimeNum, format = \"%Y-%b-%d %H:%M:%S\", tz = \"UTC\")\n  } else {\n    data$DateTimeNum\n  }\n\n  # Sort data chronologically\n  data <- data %>% arrange(DateTimeNum)\n\n  # Find periods of constant direction\n  result <- data %>%\n    mutate(\n      dir_change = Dir != lag(Dir, default = first(Dir)),\n      period_id = cumsum(dir_change),\n      wind_over_threshold = Wspd >= 5  # Track readings above threshold\n    ) %>%\n    group_by(period_id) %>%\n    summarize(\n      period_start = first(DateTimeNum),\n      period_end = last(DateTimeNum),\n      duration_entries = n(),\n      dir = first(Dir),\n      avg_wspd = mean(Wspd, na.rm = TRUE),\n      max_wspd = max(Wspd, na.rm = TRUE),\n      max_gust = if(\"Mx_Spd\" %in% names(data)) max(Mx_Spd, na.rm = TRUE) else NA,\n      sustained_wind_count = sum(wind_over_threshold, na.rm = TRUE),\n      total_entries = sum(!is.na(Wspd)),\n      .groups = 'drop'\n    ) %>%\n    filter(duration_entries >= min_entries)\n\n  # Add before/after information\n  result$before_dir <- NA_real_\n  result$before_time <- NA_character_\n  result$after_dir <- NA_real_\n  result$after_time <- NA_character_\n\n  # Process each row to add before/after information\n  for(i in seq_len(nrow(result))) {\n    period_start_time <- result$period_start[i]\n    period_end_time <- result$period_end[i]\n    \n    start_idx <- which(data$DateTimeNum == period_start_time)\n    end_idx <- which(data$DateTimeNum == period_end_time)\n    \n    if(start_idx > 1) {\n      result$before_dir[i] <- data$Dir[start_idx - 1]\n      result$before_time[i] <- format(data$DateTimeNum[start_idx - 1], \"%Y-%b-%d %H:%M:%S\")\n    }\n    \n    if(end_idx < nrow(data)) {\n      result$after_dir[i] <- data$Dir[end_idx + 1]\n      result$after_time[i] <- format(data$DateTimeNum[end_idx + 1], \"%Y-%b-%d %H:%M:%S\")\n    }\n  }\n\n  # Flag periods based on wind conditions\n  result <- result %>%\n    mutate(\n      suspicious = !is.na(avg_wspd) & !is.na(max_wspd) & (\n        # Flag if majority of readings show wind >= 5 km/h\n        (sustained_wind_count >= total_entries * 0.75 & duration_entries >= 6) |\n        # Flag if max wind speed or gust is high during constant direction\n        (max_wspd >= 10) |\n        (!is.na(max_gust) & max_gust >= 15)\n      )\n    )\n\n  return(result)\n}\n\n# Helper function to display period information with wind details\ndisplay_period <- function(row, flagged = FALSE) {\n  cat(\"\\nConstant Direction Period\", if(flagged) \" *** FLAGGED ***\" else \"\", \"\\n\")\n  cat(sprintf(\"Start Time:    %s\\n\", format(row$period_start, \"%Y-%b-%d %H:%M:%S\")))\n  cat(sprintf(\"End Time:      %s\\n\", format(row$period_end, \"%Y-%b-%d %H:%M:%S\")))\n  cat(sprintf(\"Entries:       %d\\n\", row$duration_entries))\n  cat(sprintf(\"Direction:     %.2f°\\n\", row$dir))\n  cat(sprintf(\"Avg Wspd:      %.1f km/h\\n\", row$avg_wspd))\n  cat(sprintf(\"Max Wspd:      %.1f km/h\\n\", row$max_wspd))\n  \n  # Add wind persistence information\n  if (!is.na(row$sustained_wind_count) && !is.na(row$total_entries)) {\n    wind_persistence <- (row$sustained_wind_count / row$total_entries) * 100\n    cat(sprintf(\"Wind ≥ 5 km/h: %d of %d readings (%.1f%%)\\n\", \n                row$sustained_wind_count, row$total_entries, wind_persistence))\n  }\n  \n  if (!is.na(row$max_gust)) {\n    cat(sprintf(\"Mx_Spd:        %.1f km/h\\n\", row$max_gust))\n  }\n  \n  if (!is.na(row$before_dir)) {\n    cat(sprintf(\"Dir Before:    %.2f° at %s\\n\", row$before_dir, row$before_time))\n  } else {\n    cat(\"Dir Before:    No prior direction available\\n\")\n  }\n  \n  if (!is.na(row$after_dir)) {\n    cat(sprintf(\"Dir After:     %.2f° at %s\\n\", row$after_dir, row$after_time))\n  } else {\n    cat(\"Dir After:     No subsequent direction available\\n\")\n  }\n  \n  if (flagged) {\n    cat(\"\\nFlagged due to:\\n\")\n    if (!is.na(row$sustained_wind_count) && !is.na(row$total_entries) &&\n        (row$sustained_wind_count >= row$total_entries * 0.75) && row$duration_entries >= 6) {\n      cat(sprintf(\"- Sustained winds ≥ 5 km/h for %.1f%% of period\\n\", \n                 (row$sustained_wind_count / row$total_entries) * 100))\n    }\n    if (!is.na(row$max_wspd) && row$max_wspd >= 10) {\n      cat(\"- High maximum wind speed (≥ 10 km/h)\\n\")\n    }\n    if (!is.na(row$max_gust) && row$max_gust >= 15) {\n      cat(\"- Strong gusts (≥ 15 km/h)\\n\")\n    }\n  }\n  cat(\"\\n\")\n}\n","type":"text"},{"name":"data/r/wind_module/wind_output.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#r/wind_module/wind_output.R\n\nrender_high_wspd_output <- function(WX_stations) {\n  high_wspd_results <- check_high_wspd(WX_stations)\n  \n  cat(\"Checks for Wspd or Mx_Spd over 50 km/h.\\n\")\n  \n  if (is.data.frame(high_wspd_results) && nrow(high_wspd_results) > 0) {\n    print(high_wspd_results)\n  } else {\n    cat(\"No Wspd or Mx_Spd values > 50 km/h found.\\n\")\n  }\n}\n\nrender_dir_check_output <- function(WX_stations) {\n  any_constant_periods <- FALSE\n  all_station_results <- list()\n  flagged_periods <- list()\n\n  for (table_name in names(WX_stations)) {\n    data <- WX_stations[[table_name]]\n    results <- find_constant_dir_periods(data)\n    \n    if (!is.null(results) && nrow(results) > 0) {\n      any_constant_periods <- TRUE\n      station_name <- sub(\"^dbo\\\\.\", \"\", table_name)\n      \n      # Separate flagged periods\n      if (any(results$suspicious)) {\n        flagged_results <- results[results$suspicious, ]\n        flagged_periods[[station_name]] <- flagged_results\n      }\n      \n      all_station_results[[table_name]] <- list(\n        data = data,\n        results = results,\n        max_duration = max(results$duration_entries),\n        flagged_count = sum(results$suspicious, na.rm = TRUE)\n      )\n    }\n  }\n\n  cat(\"Analysis of constant wind direction periods (> 3 hours)\\n\")\n  \n  if (any_constant_periods) {\n    # First display flagged periods if any exist\n    if (length(flagged_periods) > 0) {\n      cat(\"\\n=== FLAGGED PERIODS ===\\n\")\n      for (station_name in names(flagged_periods)) {\n        cat(\"\\n\", station_name, \"\\n\", sep = \"\")\n        flagged_results <- flagged_periods[[station_name]]\n        \n        for (i in seq_len(nrow(flagged_results))) {\n          row <- flagged_results[i, ]\n          display_period(row, flagged = TRUE)\n        }\n        cat(paste(rep(\"=\", 30), collapse = \"\"), \"\\n\")\n      }\n      cat(\"\\n=== ALL CONSTANT DIRECTION PERIODS ===\\n\")\n    }\n    \n    # Sort stations by number of flagged periods first, then by max duration\n    sorted_stations <- names(all_station_results)[order(\n      sapply(all_station_results, function(x) x$flagged_count),\n      sapply(all_station_results, function(x) x$max_duration),\n      decreasing = TRUE\n    )]\n    \n    for (table_name in sorted_stations) {\n      station_info <- all_station_results[[table_name]]\n      results <- station_info$results\n      \n      clean_table_name <- sub(\"^dbo\\\\.\", \"\", table_name)\n      cat(\"\\n\", clean_table_name, \"\\n\", sep = \"\")\n      \n      results <- results[order(results$suspicious, results$duration_entries, decreasing = TRUE), ]\n      \n      for (i in seq_len(nrow(results))) {\n        row <- results[i, ]\n        display_period(row, flagged = row$suspicious)\n      }\n      cat(paste(rep(\"=\", 30), collapse = \"\"), \"\\n\")\n    }\n  } else {\n    cat(\"No constant direction periods detected.\\n\")\n  }\n}\nrender_zero_wspd_output <- function(WX_stations, selected_station) {\n  any_results <- FALSE\n\n  cat(\"Flags hourly zero wspd blocks of at least 12 hours with concurrent dir changes.\\n\\n\")\n  \n  \n  stations_to_display <- if (!is.null(selected_station) && selected_station != \"All Stations\") {\n    c(selected_station)\n  } else {\n    names(WX_stations)\n  }\n  \n  # Create a list to store all results for sorting\n  all_results <- list()\n  \n  for (table_name in stations_to_display) {\n    data <- WX_stations[[table_name]]\n    \n    diagnostic_results <- find_zero_wspd_periods(data)\n    recent_non_zero <- get_most_recent_non_zero_wspd(data)\n    \n    if (nrow(diagnostic_results) > 0) {\n      any_results <- TRUE\n      max_consecutive <- max(diagnostic_results$count_consecutive)\n      all_results[[table_name]] <- list(\n        table_name = table_name,\n        diagnostic_results = diagnostic_results,\n        recent_non_zero = recent_non_zero,\n        max_consecutive = max_consecutive\n      )\n    }\n  }\n  \n  # Sort stations by maximum consecutive hours\n  if (length(all_results) > 0) {\n    sorted_stations <- names(all_results)[order(sapply(all_results, function(x) x$max_consecutive), decreasing = TRUE)]\n    \n    for (table_name in sorted_stations) {\n      result <- all_results[[table_name]]\n      diagnostic_results <- result$diagnostic_results\n      recent_non_zero <- result$recent_non_zero\n      \n      clean_table_name <- sub(\"dbo\\\\.\", \"\", table_name)\n      cat(\"\\nStation:\", clean_table_name, \"\\n\")\n      cat(rep(\"-\", 50), \"\\n\")\n      \n      anomaly_count <- sum(diagnostic_results$anomalous)\n      if (anomaly_count > 0) {\n        cat(sprintf(\"Found %d block(s) with wspd/dir inconsistencies\\n\", anomaly_count))\n      }\n      \n      for (i in seq_len(nrow(diagnostic_results))) {\n        period <- diagnostic_results[i, ]\n        \n        cat(sprintf(\"\\nBlock %d %s\\n\", i, \n            if(period$anomalous) \"*** Hourly Wspd/Dir Flagged ***\" else \"\"))\n        cat(sprintf(\"Start Time:           %s\\n\", format(period$period_start, \"%Y-%m-%d %H:%M:%S\")))\n        cat(sprintf(\"End Time:             %s\\n\", format(period$period_end, \"%Y-%m-%d %H:%M:%S\")))\n        cat(sprintf(\"Consecutive Hourly Zero Wspd:    %d\\n\", period$count_consecutive))\n        cat(sprintf(\"Direction Changes:    %d\\n\", period$dir_changes))\n        cat(sprintf(\"Max Direction Change: %.1f degrees\\n\", period$max_dir_change))\n        \n        if (!is.na(period$min_mx_spd) && !is.na(period$max_mx_spd)) {\n          cat(sprintf(\"Mx_Spd Range:         %.1f to %.1f\\n\", \n                     period$min_mx_spd, period$max_mx_spd))\n        }\n        \n        if (period$anomalous) {\n          cat(\"\\nZero hourly wspd detected with concurrent direction changes\\n\")\n        }\n      }\n      \n      if (!is.null(recent_non_zero)) {\n        cat(sprintf(\"\\nMost recent non-zero hourly wspd in fetched data: %.1f at %s\\n\",\n                   recent_non_zero$wind_speed,\n                   format(recent_non_zero$date_time, \"%Y-%m-%d %H:%M:%S\")))\n      } else {\n        cat(\"\\nNo non-zero hourly wspd values found in the fetched data\\n\")\n      }\n      \n      cat(strrep(\"=\", 50), \"\\n\")\n    }\n  }\n  \n  if (!any_results) {\n    cat(\"No hourly zero wind speed blocks detected.\\n\")\n  }\n}\n","type":"text"},{"name":"data/static_data/STATION_METADATA.csv","content":"STATION,STATION_CODE,DATA_SOURCE,SITE_TYPE,OWNER,FIRE_CENTRE,FIRE_ZONE,LATITUDE,LONGITUDE,ELEVATION,or_site_id,site_id,client_id,system_id\n14G (CRD),1142,Capital Regional District,External,Capital Regional District,Coastal Fire Centre,South Island Zone,48.4944,-123.6139,485,NA,NA,NA,NA\n31N (CRD),543,Capital Regional District,External,Capital Regional District,Coastal Fire Centre,South Island Zone,48.5297,-123.6375,600,NA,NA,NA,NA\n4RW6 (CRD),1143,Capital Regional District,External,Capital Regional District,Coastal Fire Centre,South Island Zone,48.5861,-123.7494,665,NA,NA,NA,NA\nAFTON,322,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.6727,-120.4822,693,395,96.1.70.251:48006;0x0141-0x0142,f123a2e6-fdcf-460a-bfd1-409f859bb62d,27\nAKOKLI CREEK,838,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.4358,-116.7464,821,NA,NA,NA,NA\nALEXIS CREEK,209,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,52.0838,-123.2733,791,NA,NA,NA,NA\nALLISON PASS,317,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.0625,-120.7668,1174,NA,NA,NA,NA\nANAHIM LAKE,213,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,52.4606,-125.307,1097,NA,NA,NA,NA\nANDERSON CREEK,977,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.6551,-121.3576,655,NA,NA,NA,NA\nAPE LAKE,1275,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),52.1346,-126.2627,1414,NA,NA,NA,NA\nASHCROFT (EC),1173,Environment Canada,External,Environment Canada,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.7084,-121.2812,327,NA,NA,NA,NA\nASHNOLA,331,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.1391,-120.1844,1683,NA,NA,NA,NA\nASPEN GROVE,302,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.9481,-120.6211,1065,NA,NA,NA,NA\nATLIN,111,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,59.5845,-133.6643,719,NA,NA,NA,NA\nATTACHIE PLATEAU,1243,Non-Reporting,External,NA,Prince George Fire Centre,Fort St. John Zone,56.2327,-121.4664,646,NA,NA,NA,NA\nAUGIER LAKE,167,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Lakes),54.3619,-125.5253,927,NA,NA,NA,NA\nAUGUST LAKE,836,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.4335,-120.4571,855,NA,NA,NA,NA\nBAKER,503,Auto-Caller,Hub Station,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.4589,-115.6303,2262,NA,NA,NA,NA\nBALDFACE,221,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,52.7101,-124.4822,1666,NA,NA,NA,NA\nBEAR FLAT,1244,Non-Reporting,External,NA,Prince George Fire Centre,Fort St. John Zone,56.2751,-121.2127,474,NA,NA,NA,NA\nBEAR LAKE,149,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,54.4824,-122.6829,715,NA,NA,NA,NA\nBEAVER CREEK,37,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.3776,-124.9337,121,NA,NA,NA,NA\nBEAVERDELL,390,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Boundary Zone,49.4564,-119.0886,807,NA,NA,NA,NA\nBEDNESTI,175,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.8654,-123.3232,858,NA,NA,NA,NA\nBEGBIE DL,509,Non-Reporting,Download,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.4733,-121.36,1276,NA,NA,NA,NA\nBELL-IRVING,432,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),56.3486,-129.2928,391,595,66ad65d299a271067ca51c21,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nBELLA BELLA (EC),1851,Environment Canada,External,Environment Canada,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),52.3619,-128.88,43,NA,NA,NA,NA\nBENSON,228,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,52.91,-122.065,1006,NA,NA,NA,NA\nBERRY,267,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.9788,-119.4134,1469,NA,NA,NA,NA\nBIG MOUTH 2,868,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.8533,-118.5914,1091,NA,NA,NA,NA\nBIG SILVER 2,1040,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.7234,-121.8366,570,NA,NA,NA,NA\nBIG VALLEY,262,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,53.2617,-121.7617,1355,NA,NA,NA,NA\nBIGATTINI,2450,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.4539,-115.9872,1540,NA,NA,NA,NA\nBLACKPINE,148,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,56.3188,-125.368,1126,NA,NA,NA,NA\nBLAEBERRY,866,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.4357,-117.0571,861,NA,NA,NA,NA\nBLOWDOWN PASS PROJECT,3730,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.4388,-122.2422,1366,NA,NA,NA,NA\nBLUE RIVER 2,1108,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.1223,-119.2936,684,NA,NA,NA,NA\nBLUEBERRY,4352,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,53.3159,-119.6007,1088,NA,NA,NA,NA\nBOB QUINN LAKE,113,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,56.9809,-130.251,605,NA,NA,NA,NA\nBOOTHROYD,1339,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.9754,-121.4892,361,NA,NA,NA,NA\nBOULDER CREEK,1240,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.3664,-116.5264,1275,NA,NA,NA,NA\nBOWRON HAGGEN,193,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.463,-121.5603,927,NA,NA,NA,NA\nBOWSER,56,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.4368,-124.7022,108,NA,NA,NA,NA\nBOYA LAKE,445,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,59.3673,-129.111,742,NA,NA,NA,NA\nBRENDA MINES,283,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.8684,-119.9925,1463,NA,NA,NA,NA\nBRISCO,865,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.8193,-116.2449,930,NA,NA,NA,NA\nBURNS LAKE 850M,181,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Lakes),54.2591,-125.7598,824,NA,NA,NA,NA\nCAHILTY,253,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.8879,-119.8383,1543,NA,NA,NA,NA\nCALLAGHAN VALLEY (EC),896,Environment Canada,External,Environment Canada,Coastal Fire Centre,Pemberton Zone,50.1443,-123.1093,869,NA,NA,NA,NA\nCAMPBELL RIVER AP (EC),26,Environment Canada,External,Environment Canada,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50,-125.3,106,NA,NA,NA,NA\nCAPILANO GVRD,554,Auto-Caller,Weather Station - GOES,Greater Vancouver Water District,Coastal Fire Centre,Fraser Zone,49.44,-123.097,400,NA,NA,NA,NA\nCARIBOO  SF,510,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,52.8517,-121.6633,1933,NA,NA,NA,NA\nCARIBOO CREEK,1790,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,51.1753,-117.1757,1529,NA,NA,NA,NA\nCARIBOU CORNER,1262,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.0253,-118.1514,1561,NA,NA,NA,NA\nCASEY SF,1076,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.2514,-115.4133,1640,NA,NA,NA,NA\nCASTLE   SF,493,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,51.05,-116.4692,485,NA,NA,NA,NA\nCASTLEGAR (EC),395,Environment Canada,External,Environment Canada,Southeast Fire Centre,Arrow Zone,49.3,-117.6,495,NA,NA,NA,NA\nCATFISH,199,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.5764,-120.8585,871,NA,NA,NA,NA\nCEDAR,59,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.0476,-123.8747,31,NA,NA,NA,NA\nCEDARVALE,429,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone (Kispiox),55.0301,-128.3115,174,618,66bf960b00e01a5a0ce7919e,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nCHEAKAMUS,1283,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Pemberton Zone,50.0835,-123.0475,592,NA,NA,NA,NA\nCHEF CREEK TEST,1383,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.4041,-124.7584,669,NA,NA,NA,NA\nCHERRY LAKE,791,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.1878,-115.5417,1372,NA,NA,NA,NA\nCHETWYND (NC),122,Environment Canada,External,Environment Canada,Prince George Fire Centre,Dawson Creek Zone,55.7,-121.6,610,NA,NA,NA,NA\nCHETWYND FB,4270,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,55.6907,-121.6137,616,NA,NA,NA,NA\nCHILAKO,189,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.4937,-123.6088,807,NA,NA,NA,NA\nCHURN CREEK,832,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),51.4027,-122.3202,1100,NA,NA,NA,NA\nCLAYTON FALLS,1199,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),52.2799,-126.8902,1275,NA,NA,NA,NA\nCLEARWATER HUB,239,Auto-Caller,Hub Station,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.6289,-120.0946,440,NA,NA,NA,NA\nCOLDSCAUR LAKE,232,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.7238,-120.3899,1122,NA,NA,NA,NA\nCOQUITLAM GVRD,556,Auto-Caller,Weather Station - GOES,Greater Vancouver Water District,Coastal Fire Centre,Fraser Zone,49.386,-122.77,430,NA,NA,NA,NA\nCRANBERRY,433,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone (Kispiox),55.5768,-128.7048,496,NA,NA,NA,NA\nCRANBROOK,426,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.6673,-115.8483,996,NA,NA,NA,NA\nCRAWFORD,873,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,50.765,-117.9578,887,NA,NA,NA,NA\nCURWEN CREEK,352,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.6022,-118.4229,1286,NA,NA,NA,NA\nDARCY,292,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Pemberton Zone,50.5217,-122.4978,334,NA,NA,NA,NA\nDARKWOODS,1203,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.3576,-116.9502,1657,NA,NA,NA,NA\nDAWSON CREEK (NC),435,Environment Canada,External,Environment Canada,Prince George Fire Centre,Dawson Creek Zone,55.8,-120.2,655,NA,NA,NA,NA\nDEASE LAKE FS,108,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,58.4258,-130.0187,797,NA,NA,NA,NA\nDECEPTION,251,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.967,-120.608,1170,NA,NA,NA,NA\nDEWAR CREEK,421,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.7845,-116.383,1608,NA,NA,NA,NA\nDOWNIE,905,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.5154,-118.2721,757,NA,NA,NA,NA\nDOWNTON SF,515,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,52.71,-124.855,2365,NA,NA,NA,NA\nDUNCAN,385,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,50.7808,-117.1805,1376,NA,NA,NA,NA\nEAST BARRIERE,243,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.2531,-119.8817,631,NA,NA,NA,NA\nEAST OOTSA,170,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Lakes),53.5025,-125.7793,1086,NA,NA,NA,NA\nEIGHT MILE,391,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Boundary Zone,49.4328,-118.5783,1338,NA,NA,NA,NA\nELK MOUNTAIN,438,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,59.3336,-125.5114,437,NA,NA,NA,NA\nELKO,412,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.2876,-115.1545,876,NA,NA,NA,NA\nEMILY CREEK,425,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.1451,-115.9772,1190,NA,NA,NA,NA\nFALLS CREEK,383,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,50.383,-117.8799,790,NA,NA,NA,NA\nFIDELITY,1263,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.2344,-117.681,1308,NA,NA,NA,NA\nFINTRY,298,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.2062,-119.4804,526,NA,NA,NA,NA\nFIRESIDE,440,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,59.7226,-127.335,735,NA,NA,NA,NA\nFIVE MILE,1029,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.9109,-122.6889,875,NA,NA,NA,NA\nFLATHEAD 2,418,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.0791,-114.5373,1311,NA,NA,NA,NA\nFOGHORN  SF,473,Non-Reporting,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.5015,-119.9323,2241,NA,NA,NA,NA\nFORD MOUNTAIN,1144,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.1039,-121.6376,372,NA,NA,NA,NA\nFORRESTKERR,1377,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,56.7116,-130.6784,276,NA,NA,NA,NA\nFORT NELSON FS,599,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,58.8418,-122.5736,375,NA,NA,NA,NA\nFORT ST JAMES,146,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),54.3942,-124.2611,720,NA,NA,NA,NA\nFORT ST JOHN (NC),434,Environment Canada,External,Environment Canada,Prince George Fire Centre,Fort St. John Zone,56.3,-120.7,695,NA,NA,NA,NA\nFRANK CREEK,1375,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.8747,-122.2816,308,NA,NA,NA,NA\nFRENCH BAR,306,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,51.1775,-122.2489,1320,NA,NA,NA,NA\nFROTH-WIND,474,Auto-Caller,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),52.0105,-119.255,2149,NA,NA,NA,NA\nGANOKWA,182,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone,54.8013,-126.9484,855,NA,NA,NA,NA\nGASPARD,222,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),51.4517,-122.6617,1675,NA,NA,NA,NA\nGAVIN,227,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Horsefly),52.47,-121.7417,1081,NA,NA,NA,NA\nGLIMPSE,291,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,50.2704,-120.2883,1372,NA,NA,NA,NA\nGOATFELL,401,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.1253,-116.1638,1098,NA,NA,NA,NA\nGOATHAVEN,886,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.6673,-115.2144,1063,NA,NA,NA,NA\nGOATLICK,3191,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.5074,-118.7743,957,NA,NA,NA,NA\nGOLD HILL,379,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,50.3658,-117.0645,800,NA,NA,NA,NA\nGOLDSTREAM 2,919,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.6694,-118.4871,1333,NA,NA,NA,NA\nGOSNEL,270,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.4526,-119.1753,1873,NA,NA,NA,NA\nGRAHAM,124,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,56.4346,-122.4576,759,NA,NA,NA,NA\nGRAND FORKS,392,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Boundary Zone,49.0307,-118.4156,630,NA,NA,NA,NA\nGRASSY PLAINS HUB,161,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Lakes),53.9454,-125.8761,938,NA,NA,NA,NA\nGREENSTONE HUB,321,Auto-Caller,Hub Station,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.6112,-120.6415,1780,NA,NA,NA,NA\nGRIZZLY EXT,1332,Auto-Caller,External,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.27,-119.2203,1534,NA,NA,NA,NA\nGWYNETH LAKE,309,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.7963,-122.8805,1191,NA,NA,NA,NA\nHAGENSBORG 2,904,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),52.3873,-126.5897,47,NA,NA,NA,NA\nHAIG CAMP,67,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.3806,-121.5259,42,NA,NA,NA,NA\nHAINES JUNCTION YFS,964,Auto-Caller,Weather Station - GOES,Yukon Forest Service,Northwest Fire Centre,Cassiar Zone,60.773,-137.5762,610,NA,NA,NA,NA\nHARBOUR LAKE,250,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.5227,-119.1133,1516,NA,NA,NA,NA\nHELMUT,118,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,59.4211,-120.7889,588,NA,NA,NA,NA\nHIXON,187,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.4114,-122.5961,640,NA,NA,NA,NA\nHOLY CROSS 2,654,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),53.9362,-124.7765,961,NA,NA,NA,NA\nHOMATHKO,1349,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,51.1019,-124.9502,1481,NA,NA,NA,NA\nHONNA,93,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,53.2532,-132.1156,21,443,173.181.139.76:48053,f123a2e6-fdcf-460a-bfd1-409f859bb62d,6\nHORSEFLY,230,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Horsefly),52.3278,-121.3983,701,NA,NA,NA,NA\nHOUSTON,162,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),54.3939,-126.6175,619,NA,NA,NA,NA\nHUDSON HOPE,132,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,56.0347,-121.9903,697,NA,NA,NA,NA\nIDABEL LAKE 3,876,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.7672,-119.1241,1246,NA,NA,NA,NA\nINGENIKA POINT,145,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,57.0194,-125.1804,680,NA,NA,NA,NA\nINKANEEP 2 EXT,2170,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.1167,-119.3,1384,NA,NA,NA,NA\nIRON CREEK YFS,965,Auto-Caller,Weather Station - GOES,Yukon Forest Service,Northwest Fire Centre,Cassiar Zone,60.0069,-127.9276,674,NA,NA,NA,NA\nISKUT,112,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,57.8617,-130.0181,857,NA,NA,NA,NA\nJERRY,190,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.5264,-122.1064,979,NA,NA,NA,NA\nJOHNSON LAKE,419,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,49.9444,-115.7583,853,NA,NA,NA,NA\nKASIKS PNG,4332,Auto-Caller,External,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),54.3233,-129.3252,10,NA,NA,NA,NA\nKETCHIKA,444,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,58.727,-127.125,687,NA,NA,NA,NA\nKETTLE 2,388,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),49.96,-118.626,1389,NA,NA,NA,NA\nKIMPTON SF,1163,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.5708,-115.8542,2371,NA,NA,NA,NA\nKISPIOX HUB,428,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone (Kispiox),55.4343,-127.6487,328,NA,NA,NA,NA\nKITPARK,106,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),54.1696,-128.5759,55,NA,NA,NA,NA\nKLINAKLINI,1348,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Port McNeill),51.38,-125.7695,1532,NA,NA,NA,NA\nKLUSKUS,166,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),53.383,-124.5121,1125,NA,NA,NA,NA\nKNIFE,225,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),52.0497,-121.8738,821,NA,NA,NA,NA\nKOMIE,4232,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,59.3394,-122.0718,704,NA,NA,NA,NA\nKOOCANUSA,1075,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.0469,-115.2253,804,NA,NA,NA,NA\nLARCH HILLS WEST,1323,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.6906,-119.1761,904,NA,NA,NA,NA\nLAVINA SF,502,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,50.2533,-116.8967,2259,NA,NA,NA,NA\nLEIGHTON LAKE,307,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.6153,-120.8362,1153,NA,NA,NA,NA\nLEMORAY,140,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,55.525,-122.5172,747,NA,NA,NA,NA\nLEO CREEK,171,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),55.0817,-125.4773,909,NA,NA,NA,NA\nLIKELY RS,255,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Horsefly),52.615,-121.5133,1046,NA,NA,NA,NA\nLILLOOET,280,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.672,-121.8882,408,NA,NA,NA,NA\nLITTLE CHOPAKA,3810,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.0251,-119.6909,461,NA,NA,NA,NA\nLONE BUTTE,218,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.507,-121.162,1158,NA,NA,NA,NA\nLOVELL COVE,163,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),55.6881,-126.0525,981,NA,NA,NA,NA\nLOWER BEAVER,1264,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.4149,-117.4741,835,NA,NA,NA,NA\nLOWER CAIN,1350,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Port McNeill),50.2258,-126.3563,1295,NA,NA,NA,NA\nMABEL LAKE 2,362,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.3514,-118.7735,562,NA,NA,NA,NA\nMACHMELL,101,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),51.5931,-126.4508,344,NA,NA,NA,NA\nMACHMELL KLINIKLINI,1276,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),51.6556,-126.1407,1609,NA,NA,NA,NA\nMACKENZIE (NC),142,Environment Canada,External,Environment Canada,Prince George Fire Centre,Mackenzie Zone,55.3,-123.1,690,NA,NA,NA,NA\nMACKENZIE FS,155,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,55.2864,-123.1358,697,NA,NA,NA,NA\nMANSON,141,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,55.5798,-124.2321,1038,NA,NA,NA,NA\nMARION,367,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.0422,-116.3638,1300,NA,NA,NA,NA\nMARTINS GULCH (CRD),1141,Capital Regional District,External,Capital Regional District,Coastal Fire Centre,South Island Zone,48.5161,-123.7644,512,NA,NA,NA,NA\nMATHEW,263,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,52.91,-120.9117,1108,NA,NA,NA,NA\nMAYSON,1082,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.2112,-120.412,1311,NA,NA,NA,NA\nMCBRIDE,195,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,53.2948,-120.153,714,NA,NA,NA,NA\nMCBRIDE LAKE,180,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),54.0747,-127.3994,810,NA,NA,NA,NA\nMCCUDDY,334,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.1483,-119.415,1023,NA,NA,NA,NA\nMCGREGOR 2,192,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.9289,-120.6355,979,NA,NA,NA,NA\nMCLEAN LAKE,311,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.7923,-121.3581,1123,NA,NA,NA,NA\nMCLEOD LAKE,153,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,54.7442,-123.0187,867,NA,NA,NA,NA\nMCLEOD MEADOWS,1242,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Invermere Zone,50.7691,-115.9508,1132,NA,NA,NA,NA\nMCNULTY EXT,1392,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.5557,-120.1732,1595,NA,NA,NA,NA\nMEADOW LAKE,236,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.375,-121.7167,1070,NA,NA,NA,NA\nMEAGER CREEK,1083,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Pemberton Zone,50.62,-123.4101,549,NA,NA,NA,NA\nMENZIES CAMP,19,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.0486,-125.7887,435,NA,NA,NA,NA\nMERRITT 2 HUB,1399,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,50.1214,-120.7442,640,NA,NA,NA,NA\nMESACHIE 2,934,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,South Island Zone,48.8228,-124.1371,185,NA,NA,NA,NA\nMIDDLE LAKE,226,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,51.7017,-124.875,915,NA,NA,NA,NA\nMOOSE LAKE,165,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),53.0715,-125.4121,1094,NA,NA,NA,NA\nMOUNT CAYLEY,1221,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Pemberton Zone,50.0708,-123.2771,1592,NA,NA,NA,NA\nMOUNT MOORE  SF,476,Non-Reporting,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.885,-118.8133,2162,NA,NA,NA,NA\nMUDPIT,1176,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.3127,-119.3926,884,NA,NA,NA,NA\nMUSKWA,131,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,57.8842,-123.6164,769,NA,NA,NA,NA\nNABESHE,151,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,56.3643,-123.3655,1103,NA,NA,NA,NA\nNADINA,179,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),53.9425,-126.9278,954,NA,NA,NA,NA\nNAHATLATCH,316,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.9018,-122.0209,551,NA,NA,NA,NA\nNANCY GREENE,407,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,49.2545,-117.9942,1397,NA,NA,NA,NA\nNASS CAMP,427,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),55.2886,-128.9984,176,NA,NA,NA,NA\nNATAL SF,505,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.6314,-114.8533,2262,NA,NA,NA,NA\nNAZKO,211,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,52.9575,-123.5958,910,NA,NA,NA,NA\nNEL-X DL,464,Non-Reporting,Download,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,58.8513,-122.8351,668,NA,NA,NA,NA\nNELSON FORKS,119,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,59.6173,-124.0985,660,NA,NA,NA,NA\nNEMIAH,216,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,51.48,-123.8183,1220,NA,NA,NA,NA\nNICOLL,393,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Boundary Zone,49.5267,-118.3603,866,NA,NA,NA,NA\nNILKITKWA,172,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone,55.538,-126.5775,969,NA,NA,NA,NA\nNOEL,437,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,55.2956,-120.485,977,NA,NA,NA,NA\nNORNS,408,Auto-Caller,Store Forward,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,49.5025,-117.787,2423,NA,NA,NA,NA\nNORTH BABINE,173,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),55.135,-126.2073,951,NA,NA,NA,NA\nNORTH BASIN (CRD),1166,Capital Regional District,External,Capital Regional District,Coastal Fire Centre,South Island Zone,48.5722,-123.7068,180,NA,NA,NA,NA\nNORTH CHILCO,159,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),54.1546,-123.7542,836,NA,NA,NA,NA\nNORTH COWICHAN (EC),1013,Environment Canada,External,Environment Canada,Coastal Fire Centre,South Island Zone,48.8242,-123.7189,60,NA,NA,NA,NA\nOCTOPUS CREEK,396,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,49.699,-118.081,1432,NA,NA,NA,NA\nOLD FADDY,1270,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,59.8929,-129.0939,866,607,66b5475d99a271067ca51c37,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nONE MILE,1261,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.022,-118.2072,527,NA,NA,NA,NA\nOSBORN,1045,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,56.5553,-120.3952,700,NA,NA,NA,NA\nPADDY,121,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,57.7818,-120.2368,722,NA,NA,NA,NA\nPALLISER,411,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.4946,-115.6664,1100,NA,NA,NA,NA\nPARROTT,183,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),54.0186,-126.389,1259,NA,NA,NA,NA\nPASKA LAKE,326,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.504,-120.674,1488,NA,NA,NA,NA\nPEAVINE  SF,520,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),51.9233,-122.205,1391,NA,NA,NA,NA\nPEDEN,178,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),53.9868,-126.5174,747,NA,NA,NA,NA\nPEMBERTON BASE,301,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Pemberton Zone,50.3059,-122.7287,203,NA,NA,NA,NA\nPENDOREILLE,402,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,49.0506,-117.4139,725,NA,NA,NA,NA\nPENTICTON RS,328,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.5177,-119.5529,492,NA,NA,NA,NA\nPERSEVERANCE,1347,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),49.5936,-125.1313,970,NA,NA,NA,NA\nPG CENTRAL,1248,Auto-Caller,Download,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.9025,-122.7962,1985,NA,NA,NA,NA\nPINE CREEK,938,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone,54.683,-127.3234,1300,NA,NA,NA,NA\nPINK MOUNTAIN,129,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,57.0874,-122.5912,989,NA,NA,NA,NA\nPLACE LAKE,212,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),51.8167,-122,1065,NA,NA,NA,NA\nPLUMMER HUT,1387,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,51.3735,-125.1645,2712,NA,NA,NA,NA\nPORT HARDY AP (EC),2,Environment Canada,External,Environment Canada,Coastal Fire Centre,North Island Mid Coast Zone (Port McNeill),50.7,-127.4,22,NA,NA,NA,NA\nPOWDER CREEK,380,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.9065,-116.8551,1019,NA,NA,NA,NA\nPOWELL RIVER WEST LAKE,1218,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,49.818,-124.4499,160,NA,NA,NA,NA\nPRAIRIE CREEK,264,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Horsefly),52.3917,-120.985,1015,NA,NA,NA,NA\nPRINCE GEORGE (EC),186,Environment Canada,External,Environment Canada,Prince George Fire Centre,Prince George Zone,53.9,-122.7,691,NA,NA,NA,NA\nPRINCE RUPERT (EC),88,Environment Canada,External,Environment Canada,Northwest Fire Centre,Skeena Zone (North Coast),54.3,-130.4,35,NA,NA,NA,NA\nPROMONTORY  SF,478,Non-Reporting,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,50.1949,-120.973,1735,NA,NA,NA,NA\nPUNTZI MOUNTAIN (EC),203,Environment Canada,External,Environment Canada,Cariboo Fire Centre,Chilcotin Zone,52.1,-124.2,910,NA,NA,NA,NA\nPUNTZI SF,1170,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,52.1614,-124.2058,1365,NA,NA,NA,NA\nPURCELL   SF,499,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.2395,-115.9783,2302,NA,NA,NA,NA\nQD3 SIX MILE SLOUGH,4412,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.2,-116.6333,534,NA,NA,NA,NA\nQUALICUM AP (EC),1015,Environment Canada,External,Environment Canada,Coastal Fire Centre,Mid Island Zone,49.3333,-124.3833,58,NA,NA,NA,NA\nQUESNEL (EC),229,Environment Canada,External,Environment Canada,Cariboo Fire Centre,Quesnel Zone,53,-122.4,545,NA,NA,NA,NA\nQUINSAM BASE FWX,1093,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.0267,-125.2929,68,488,173.181.134.41:48031,f123a2e6-fdcf-460a-bfd1-409f859bb62d,13\nRAFT,2512,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.765,-119.6751,920,NA,NA,NA,NA\nRED DEER,138,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,54.633,-120.5762,1306,NA,NA,NA,NA\nREDSTREAK,1260,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Invermere Zone,50.6229,-116.0628,1009,NA,NA,NA,NA\nREVELSTOKE,363,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.0603,-118.2172,680,NA,NA,NA,NA\nRISKE CREEK,210,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),51.9594,-122.5042,929,NA,NA,NA,NA\nROCK CREEK,394,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Boundary Zone,49.052,-118.9367,609,NA,NA,NA,NA\nROCKINGHAM,3190,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.8643,-118.5203,1123,590,66ad273c99a271067ca51c1d,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nRORY CREEK,1092,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,50.6126,-116.7933,1580,NA,NA,NA,NA\nROSSWOOD,105,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),54.9168,-128.8597,239,631,66bfccae99a271067ca51c4e,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nROUND PRAIRIE,788,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,50.082,-114.9004,1647,NA,NA,NA,NA\nSALTSPRING 2,45,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,South Island Zone,48.7729,-123.4745,15,632,66bfcce400e01a5a0ce791a6,f123a2e6-fdcf-460a-bfd1-409f859bb62d,8\nSASKATCHEWAN CROSSING,1239,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,NA,51.968,-116.7148,1442,NA,NA,NA,NA\nSATURNA (EC),915,Environment Canada,External,Environment Canada,Coastal Fire Centre,South Island Zone,48.7833,-123.05,24,NA,NA,NA,NA\nSAWTOOTH,1345,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),55.3144,-125.3484,996,NA,NA,NA,NA\nSCAR CREEK,82,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,51.1891,-125.0281,122,NA,NA,NA,NA\nSECHELT (EC),1016,Environment Canada,External,Environment Canada,Coastal Fire Centre,Sunshine Coast Zone,49.4605,-123.7,86,NA,NA,NA,NA\nSEVEREID,1165,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,54.1693,-121.6519,799,NA,NA,NA,NA\nSEYMOUR ARM,344,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),51.2735,-118.9147,497,NA,NA,NA,NA\nSEYMOUR GVRD,555,Auto-Caller,Weather Station - GOES,Greater Vancouver Water District,Coastal Fire Centre,Fraser Zone,49.483,-122.95,390,NA,NA,NA,NA\nSICAMOUS,882,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.8635,-119.0028,1115,NA,NA,NA,NA\nSIERRA,117,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,58.8381,-121.3967,573,NA,NA,NA,NA\nSIFTON,152,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Mackenzie Zone,57.8517,-126.1168,968,NA,NA,NA,NA\nSILVER,120,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,57.3745,-121.4069,835,NA,NA,NA,NA\nSILVERSTAR SF,480,Auto-Caller,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.3682,-119.0654,1880,NA,NA,NA,NA\nSINKUT  SF,468,Non-Reporting,Store Forward,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),53.817,-123.9717,1488,NA,NA,NA,NA\nSKOONKA,1024,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.4387,-121.5515,1557,NA,NA,NA,NA\nSLOCAN,406,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,49.7847,-117.44,1230,NA,NA,NA,NA\nSMALLWOOD,404,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Southeast Fire Centre,Kootenay Lake Zone,49.4967,-117.4475,997,NA,NA,NA,NA\nSMITHERS AP (EC),157,Environment Canada,External,Environment Canada,Northwest Fire Centre,Bulkley Zone,54.8242,-127.1894,522,NA,NA,NA,NA\nSMOKEY C DL,918,Non-Reporting,Download,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),52.2367,-122.1567,1235,NA,NA,NA,NA\nSPARKS LAKE,305,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),50.9237,-120.8671,960,NA,NA,NA,NA\nSPARWOOD,3110,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.8167,-114.8667,1208,NA,NA,NA,NA\nSPLINTLUM,1055,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Lillooet Zone,50.3511,-121.6549,424,NA,NA,NA,NA\nSQUAMISH AP (EC),83,Environment Canada,External,Environment Canada,Coastal Fire Centre,Pemberton Zone,49.7824,-123.1619,60,NA,NA,NA,NA\nSTATION BAY 2,1359,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.4972,-119.7269,1100,NA,NA,NA,NA\nSTOREY DL,459,Non-Reporting,Download,BC Wildfire Service,Northwest Fire Centre,Nadina Zone (Morice),54.8059,-126.1435,738,NA,NA,NA,NA\nSUCCOUR CREEK,374,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.7162,-117.5417,1000,NA,NA,NA,NA\nSUMMIT,11,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,48.9276,-124.6469,671,NA,NA,NA,NA\nSUSTUT,156,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),56.3288,-127.0339,819,NA,NA,NA,NA\nSWIFT RIVER YFS,967,Non-Reporting,External,Yukon Forest Service,Northwest Fire Centre,Cassiar Zone,60.0025,-131.1883,878,NA,NA,NA,NA\nTABERNACLE WIND,376,Auto-Caller,Store Forward,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.7513,-117.7613,2438,NA,NA,NA,NA\nTABLE RIVER,144,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,54.7158,-122.2747,775,NA,NA,NA,NA\nTACHEEDA  SF,465,Non-Reporting,Store Forward,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,54.6817,-122.4867,1290,NA,NA,NA,NA\nTALCHAKO,233,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Mid Coast),52.2514,-126.0284,306,NA,NA,NA,NA\nTATLA LAKE,208,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,Chilcotin Zone,51.9067,-124.605,945,NA,NA,NA,NA\nTAUTRI,206,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),52.5422,-123.35,1085,NA,NA,NA,NA\nTELEGRAPH CREEK,110,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Cassiar Zone,57.9141,-131.1711,382,NA,NA,NA,NA\nTERRACE,3851,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),54.438,-128.5714,199,NA,NA,NA,NA\nTERRACE (EC),103,Environment Canada,External,Environment Canada,Northwest Fire Centre,Skeena Zone (Kalum),54.5,-128.6,217,NA,NA,NA,NA\nTETRAHEDRON,1313,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,49.5979,-123.6051,1422,NA,NA,NA,NA\nTHUNDER SF,1198,Non-Reporting,Store Forward,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,54.9542,-120.5917,1400,NA,NA,NA,NA\nTHYNNE,279,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.7152,-120.866,1407,NA,NA,NA,NA\nTHYNNE  SF,481,Non-Reporting,Store Forward,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.7033,-120.9217,2002,NA,NA,NA,NA\nTIMOTHY,234,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.913,-121.389,1161,NA,NA,NA,NA\nTIMOTHY SF,517,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.9011,-121.26,1662,NA,NA,NA,NA\nTOAD RIVER,126,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,Fort Nelson Zone,58.8659,-125.3107,702,NA,NA,NA,NA\nTOBA CAMP,75,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,50.5711,-124.0777,49,NA,NA,NA,NA\nTOBY HUB,417,Auto-Caller,Hub Station,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.5128,-116.0553,894,509,173.181.139.55:48050,f123a2e6-fdcf-460a-bfd1-409f859bb62d,13\nTOFINO AIRPORT (PC),2211,Auto-Caller,Weather Station - GOES,Parks Canada,Coastal Fire Centre,Mid Island Zone,49.0868,-125.7786,24,NA,NA,NA,NA\nTOFINO AP (EC),1,Environment Canada,External,Environment Canada,Coastal Fire Centre,Mid Island Zone,49.0781,-125.7696,24,NA,NA,NA,NA\nTROUT LAKE,387,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Arrow Zone,50.6053,-117.4272,991,NA,NA,NA,NA\nTS ARTLISH,995,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.1324,-126.9282,120,NA,NA,NA,NA\nTS ATLUCK,1378,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.2651,-127.0835,384,NA,NA,NA,NA\nTS BLACKWATER,1408,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.1711,-125.5757,289,NA,NA,NA,NA\nTS BURMAN,1362,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),49.6102,-126.0327,71,NA,NA,NA,NA\nTS EFFINGHAM,956,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.17,-125.2825,632,NA,NA,NA,NA\nTS ELPHINSTONE,1002,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,49.428,-123.5649,615,NA,NA,NA,NA\nTS MAURELLE,1056,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,50.2709,-125.1309,140,NA,NA,NA,NA\nTS MCNABB,1066,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,49.5855,-123.3873,140,NA,NA,NA,NA\nTS NAHMINT,1398,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Mid Island Zone,49.2075,-125.1218,354,NA,NA,NA,NA\nTS NAKA CREEK,945,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.3701,-126.4339,515,NA,NA,NA,NA\nTS SAN JUAN,944,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,South Island Zone,48.5713,-124.2,294,NA,NA,NA,NA\nTS THEODOSIA,1025,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,Sunshine Coast Zone,50.1035,-124.6146,103,NA,NA,NA,NA\nTS TSITIKA,4393,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Campbell River),50.3752,-126.5401,211,NA,NA,NA,NA\nTSAR CREEK,361,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Columbia Zone,51.9972,-118.1025,1200,NA,NA,NA,NA\nTSUS SF,1106,Non-Reporting,Store Forward,BC Wildfire Service,Prince George Fire Centre,Prince George Zone,53.6932,-121.918,2000,NA,NA,NA,NA\nTUMBLER HUB,127,Auto-Caller,Hub Station,BC Wildfire Service,Prince George Fire Centre,Dawson Creek Zone,55.0274,-120.934,932,NA,NA,NA,NA\nTURTLE,286,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Kamloops Fire Centre,Vernon Zone (Vernon),50.8036,-119.6307,660,NA,NA,NA,NA\nTWO SISTERS  SF,518,Non-Reporting,Store Forward,BC Wildfire Service,Cariboo Fire Centre,Quesnel Zone,53.2167,-121.5517,2110,NA,NA,NA,NA\nUBC RESEARCH,72,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,Fraser Zone,49.2645,-122.5732,146,NA,NA,NA,NA\nUPPER BEAVER,1265,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.3145,-117.3741,1638,NA,NA,NA,NA\nUPPER FULTON,169,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone,55.034,-126.7996,900,NA,NA,NA,NA\nUPPER KISPIOX,431,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Bulkley Zone (Kispiox),55.6015,-128.0478,410,NA,NA,NA,NA\nVALEMOUNT 2,200,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.7883,-119.3147,1163,NA,NA,NA,NA\nVALEMOUNT AIRPORT,1268,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Prince George Fire Centre,Robson Valley Zone,52.8597,-119.3386,788,NA,NA,NA,NA\nVAN DYKE,430,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Northwest Fire Centre,Skeena Zone (Kalum),56.0127,-129.0998,296,NA,NA,NA,NA\nVANCOUVER AP (EC),69,Environment Canada,External,Environment Canada,Coastal Fire Centre,Fraser Zone,49.2,-123.2,1,NA,NA,NA,NA\nVANDERHOOF HUB,158,Auto-Caller,Hub Station,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Vanderhoof),54.0554,-124.0102,681,NA,NA,NA,NA\nVAVENBY MTN,2513,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),51.5561,-119.7382,1069,NA,NA,NA,NA\nVERMILLION CROSSING,1241,Auto-Caller,Weather Station - GOES,Parks Canada,Southeast Fire Centre,Columbia Zone,51.0234,-115.9789,1277,NA,NA,NA,NA\nVICTORIA AP (EC),49,Environment Canada,External,Environment Canada,Coastal Fire Centre,South Island Zone,48.6482,-123.4288,19,NA,NA,NA,NA\nWELLS GRAY,266,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Kamloops Fire Centre,Kamloops Zone (Kamloops),52.3425,-120.2434,958,NA,NA,NA,NA\nWEST KELOWNA,1277,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Kamloops Fire Centre,Penticton Zone,49.8832,-119.5695,650,NA,NA,NA,NA\nWHISKEY,366,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,51.0653,-116.785,1354,NA,NA,NA,NA\nWHITE RIVER,790,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Southeast Fire Centre,Invermere Zone,50.185,-115.2676,1357,NA,NA,NA,NA\nWILLIAMS LAKE (NC),205,Environment Canada,External,Environment Canada,Cariboo Fire Centre,Central Cariboo Zone (Williams Lake),52.2,-122.1,940,NA,NA,NA,NA\nWILLIS,3873,Auto-Caller,External,BC Wildfire Service,Kamloops Fire Centre,Merritt Zone,49.3394,-120.4071,1455,NA,NA,NA,NA\nWINDY MOUNTAIN,244,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.67,-120.65,1580,NA,NA,NA,NA\nWITCH,154,Auto-Caller,Weather Station - GOES,BC Wildfire Service,Prince George Fire Centre,VanJam Zone (Fort St. James),55.023,-124.2666,1041,NA,NA,NA,NA\nWONOWON,136,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Prince George Fire Centre,Fort St. John Zone,56.7184,-121.7654,958,NA,NA,NA,NA\nWOSS CAMP,21,Auto-Caller,Weather Station - Cell,BC Wildfire Service,Coastal Fire Centre,North Island Mid Coast Zone (Port McNeill),50.2132,-126.6071,151,NA,NA,NA,NA\nYAHK SF,504,Non-Reporting,Store Forward,BC Wildfire Service,Southeast Fire Centre,Cranbrook Zone,49.1928,-115.6986,2182,NA,NA,NA,NA\nYOUNG LAKE,235,Auto-Caller,Weather Station - UHF,BC Wildfire Service,Cariboo Fire Centre,100 Mile House Zone,51.2378,-120.9976,1170,NA,NA,NA,NA\n","type":"text"},{"name":"data/ui_definition2.R","content":"# Copyright 2025 Province of British Columbia\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# ui_definition.R\n\n\n# Define fire centers for the initial UI\n# Will be dynamically updated with data from API once available\nfire_centers <- c(\n  \"Northwest Fire Centre\", \n  \"Prince George Fire Centre\", \n  \"Cariboo Fire Centre\", \n  \"Southeast Fire Centre\", \n  \"Kamloops Fire Centre\", \n  \"Coastal Fire Centre\"\n)\n\nui <- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"www/styles.css\"),\n    \n    tags$script(HTML(\"\n      $(document).ready(function() {\n        $('#fetch_controls_btn').click(function(e) {\n          e.stopPropagation();\n          $('.fetch-controls-dropdown').toggleClass('active');\n        });\n\n        $(document).click(function(e) {\n          if (!$(e.target).closest('.fetch-controls-dropdown').length) {\n            $('.fetch-controls-dropdown').removeClass('active');\n          }\n        });\n\n        $('.fetch-controls-content').click(function(e) {\n          e.stopPropagation();\n        });\n      });\n    \"))\n  ),\n  # Navbar\n   tags$nav(class = \"navbar navbar-default navbar-fixed-top\",\n    div(class = \"container-fluid\",\n      div(class = \"navbar-header\",\n        img(src = \"www/gov3_bc_logo.png\", class = \"nav-logo\"),\n        span(class = \"navbar-title\", \"WX Station Alerts Dashboard\")\n      )\n    )\n  ),\n\n  # Main Container\n  div(class = \"container-fluid\",\n    # Header with controls\n    div(class = \"header-container\",\n      div(class = \"header-left\",\n        # Main Navigation Tabs - Only show after data is fetched\n        conditionalPanel(\n          condition = \"typeof input.fetch_data !== 'undefined' && input.fetch_data > 0\",\n          tabsetPanel(\n            id = \"tabs\",\n            type = \"pills\",\n            tabPanel(\"DB check\", value = \"DB check\"),\n            tabPanel(\"Power\", value = \"Power\"),\n            tabPanel(\"Wind\", value = \"Wind\"),\n            tabPanel(\"Temp\", value = \"Temp\"),\n            tabPanel(\"RH\", value = \"RH\"),\n            tabPanel(\"Precip\", value = \"Precip\"),\n            tabPanel(\"CRMP\", value = \"CRMP\")\n          )\n        )\n      ),\n      \n      # Data Controls Dropdown - Always visible\n      div(class = \"fetch-controls-dropdown\",\n        actionButton(\"fetch_controls_btn\", \"Data Controls\", class = \"btn-primary\"),\n        div(class = \"fetch-controls-content\",\n          radioButtons(\"fetch_type\", \"Select Time Range:\",\n            choices = list(\n              \"Recent Time\" = \"last_n\",\n              \"By Date\" = \"by_date\",\n              \"Date Range\" = \"date_range\"\n            ),\n            selected = \"last_n\"\n          ),\n          selectInput(\"fire_centre\", \"Select Fire Centre:\",\n            choices = fire_centers,\n            selected = fire_centers[1]\n          ),\n          radioButtons(\"station_selection_type\", \"Station Selection:\",\n            choices = list(\n              \"All Stations\" = \"all\",\n              \"Select Specific Stations\" = \"specific\"\n            ),\n            selected = \"all\"\n          ),\n          conditionalPanel(\n            condition = \"input.station_selection_type == 'specific'\",\n            selectizeInput(\"selected_stations\", \"Select Stations:\",\n              choices = NULL,\n              multiple = TRUE,\n              options = list(\n                placeholder = 'Select stations to include',\n                plugins = list('remove_button')\n              )\n            )\n          ),\n          conditionalPanel(\n            condition = \"input.fetch_type == 'last_n'\",\n            div(class = \"time-preset-container\",\n              radioButtons(\"time_preset\", \"Select Time Period:\",\n                choices = list(\n                  \"Last 24 Hours\" = \"24\",\n                  \"Last 3 Days\" = \"72\",\n                  \"Last Week\" = \"168\",\n                  \"Last Month\" = \"720\",\n                  \"Custom\" = \"custom\"\n                ),\n                selected = \"24\"\n              ),\n              conditionalPanel(\n                condition = \"input.time_preset == 'custom'\",\n                numericInput(\"num_entries\", \"Enter Custom Hours:\", \n                  value = 24, min = 1, step = 1\n                )\n              )\n            )\n          ),\n          conditionalPanel(\n            condition = \"input.fetch_type == 'by_date'\",\n            dateInput(\"select_date\", \"Select Date:\", value = Sys.Date())\n          ),\n          conditionalPanel(\n            condition = \"input.fetch_type == 'date_range'\",\n            dateInput(\"start_date\", \"Start Date:\", value = Sys.Date() - 7),\n            dateInput(\"end_date\", \"End Date:\", value = Sys.Date())\n          ),\n          actionButton(\"fetch_data\", \"Retrieve Data\", class = \"btn-primary\")\n        )\n      )\n    ),\n\n    # Welcome message shown when no data is fetched\n    conditionalPanel(\n      condition = \"typeof input.fetch_data === 'undefined' || input.fetch_data === 0\",\n      div(class = \"welcome-container\", style = \"text-align: center; margin-top: 80px; padding: 30px;\",\n        div(class = \"welcome-card\", style = \"max-width: 600px; margin: 0 auto; background-color: #f8f9fa; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);\",\n          h2(\"Welcome to WX Station Alerts Dashboard\", style = \"color: #003366; margin-bottom: 20px;\"),\n          p(\"This dashboard provides analysis and alerts for weather station data across British Columbia.\"),\n          p(\"To get started:\"),\n          tags$ol(\n            tags$li(\"Click the \", tags$b(\"Data Controls\"), \" button in the top right corner\"),\n            tags$li(\"Select your preferred time range and Fire Centre\"),\n            tags$li(\"Click \", tags$b(\"Retrieve Data\"), \" to load the dashboard\")\n          ),\n          p(\"Once data is loaded, you can navigate between different analysis modules using the tabs that will appear at the top of the page.\"),\n          div(class = \"data-hint\", style = \"margin-top: 20px; font-style: italic; color: #666;\", \n            \"For optimal performance, consider limiting your query to specific stations or shorter time periods when analyzing large datasets.\"\n          )\n        )\n      )\n    ),\n\n    # All tab content wrapped in a conditional panel\n    conditionalPanel(\n      condition = \"typeof input.fetch_data !== 'undefined' && input.fetch_data > 0\",\n      \n      # Status indicator for current data selection\n      div(class = \"data-status-container\", style = \"margin: 10px 0; text-align: center;\",\n        div(class = \"data-status-pill\", style = \"display: inline-block; padding: 5px 15px; background-color: #e9f2f9; border-radius: 20px; font-weight: bold;\",\n          textOutput(\"data_status\")\n        )\n      ),\n      \n      # DB check tab\n      conditionalPanel(\n        condition = \"input.tabs == 'DB check'\",\n        div(class = \"station-select-container\", \n          selectInput(\"db_station_select\", \"Select Station\", choices = NULL)\n        ),\n        div(class = \"output-card\",\n          h4(\"Station Report Status\"),\n          DTOutput(\"last_entry_time_check\")\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-7\",\n            div(class = \"output-card\",\n              h4(\"Check for Hourly Data Gaps\"),\n              plotlyOutput(\"missing_entries_plot\", height = \"200px\"),\n              verbatimTextOutput(\"missing_entries_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          ),\n          div(class = \"col-md-5\",\n            div(class = \"output-card\",\n              h4(\"Check for Blanks\"),\n              verbatimTextOutput(\"original_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-5\",\n            div(class = \"output-card\",\n              h4(\"NOAA Alerts\"),\n              DTOutput(\"space_weather_table\")\n            )\n          ),\n          div(class = \"col-md-7\",\n            div(class = \"output-card\",\n              h4(\"Recent Entries\"),\n              DTOutput(\"recent_entries\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"Data Frame Structure\"),\n              verbatimTextOutput(\"df_structure\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # Power tab\n      conditionalPanel(\n        condition = \"input.tabs == 'Power'\",\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"Battery Voltage Alerts\"),\n              verbatimTextOutput(\"battery_voltage_alerts\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Power Status Details\"),\n              selectInput(\"power_station_select\", \"Select Station\", choices = NULL),\n              plotlyOutput(\"vbat_waterfall_plot\", height = \"400px\"),\n              verbatimTextOutput(\"power_status_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          ),\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Vbat Discharge Trends Comparison\"),\n              selectizeInput(\"vbat_trends_station_select\", \"Select Stations to Display\",\n                choices = NULL,\n                multiple = TRUE,\n                options = list(\n                  plugins = list('remove_button'),\n                  placeholder = 'Select stations...'\n                )\n              ),\n              plotlyOutput(\"vbat_trends_plot\", height = \"400px\"),\n              verbatimTextOutput(\"vbat_trends_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # Wind tab\n      conditionalPanel(\n        condition = \"input.tabs == 'Wind'\",\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"High Wspd Check\"),\n              verbatimTextOutput(\"high_wspd_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-8\",\n            div(class = \"output-card\",\n              h4(\"Wind Analysis\"),\n              selectInput(\"zero_wspd_station_select\", \"Select Station\", choices = NULL),\n              plotlyOutput(\"zero_wspd_plot\", height = \"400px\"),\n              verbatimTextOutput(\"zero_wspd_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          ),\n          div(class = \"col-md-4\",\n            div(class = \"output-card\",\n              h4(\"Constant Dir Check\"),\n              verbatimTextOutput(\"dir_check\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # Temperature tab\n      conditionalPanel(\n        condition = \"input.tabs == 'Temp'\",\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"Temperature Change Analysis\"),\n              selectInput(\"temp_analysis_station_select\", \"Select Station\", choices = NULL),\n              plotlyOutput(\"temp_change_heatmap\", height = \"400px\"),\n              verbatimTextOutput(\"erratic_temp_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Constant Temperature Analysis\"),\n              selectInput(\"constant_temp_station_select\", \"Select Station\", choices = NULL),\n              verbatimTextOutput(\"temp_check\") %>% \n                tagAppendAttributes(class = \"scrollable-output tall-output\")\n            )\n          ),\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Time Distribution of Constant Periods\"),\n              plotlyOutput(\"constant_temp_plot\", height = \"400px\")\n            ),\n            div(class = \"output-card\",\n              h4(\"Overall Station Summary\"),\n              plotlyOutput(\"constant_temp_summary_plot\", height = \"400px\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"Temperature Distribution\"),\n              plotlyOutput(\"temp_range_plot\", height = \"550px\"),\n              verbatimTextOutput(\"extreme_temp_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # RH tab\n      conditionalPanel(\n        condition = \"input.tabs == 'RH'\",\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"RH 0%\"),\n              verbatimTextOutput(\"low_rh_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"100% RH Analysis\"),\n              selectInput(\"rh_station_select\", \"Select Station\", choices = NULL),\n              plotlyOutput(\"consecutive_rh_plot\", height = \"400px\"),\n              verbatimTextOutput(\"consecutive_rh_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # Precipitation tab\n      conditionalPanel(\n        condition = \"input.tabs == 'Precip'\",\n        div(class = \"row\",\n          div(class = \"col-md-12\",\n            div(class = \"output-card\",\n              h4(\"Rn_1 Outliers\"),\n              selectInput(\"rn1_outliers_station_select\", \"Select Station\", choices = NULL),\n              plotlyOutput(\"rn1_outliers_plot\", height = \"400px\"),\n              verbatimTextOutput(\"rn1_outliers_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"row\",\n          div(class = \"col-md-4\",\n            div(class = \"output-card\",\n              h4(\"Total Rn_1\"),\n              verbatimTextOutput(\"station_rainfall_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          ),\n          div(class = \"col-md-8\",\n            div(class = \"output-card\",\n              h4(\"Decreasing Temperature Trends with High RH\"),\n              selectInput(\"temp_trends_station_select\", \"Select Station\", choices = NULL),\n              verbatimTextOutput(\"decreasing_trends_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        )\n      ),\n\n      # CRMP tab\n      conditionalPanel(\n        condition = \"input.tabs == 'CRMP'\",\n        div(class = \"row\",\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Snow Depth Sensor Alerts\"),\n              verbatimTextOutput(\"sdepth_concerns_output\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          ),\n          div(class = \"col-md-6\",\n            div(class = \"output-card\",\n              h4(\"Cumulative Precipitation Monitoring\"),\n              verbatimTextOutput(\"crmp_precip_changes\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            )\n          )\n        ),\n        div(class = \"output-card\",\n          div(class = \"station-select-container\",\n            selectInput(\"crmp_station_select\", \"Select Station\", choices = NULL)\n          ),\n          div(class = \"row\",\n            div(class = \"col-md-3\",\n              h4(\"CRMP Recent Entries\"),\n              verbatimTextOutput(\"crmp_entries\") %>% \n                tagAppendAttributes(class = \"scrollable-output\")\n            ),\n            div(class = \"col-md-9\",\n              div(class = \"row\",\n                div(class = \"col-md-12\",\n                  h4(\"Snow Depth Measurements\"),\n                  plotlyOutput(\"sdepth_plot\", height = \"250px\")\n                )\n              ),\n              div(class = \"row\",\n                div(class = \"col-md-12\",\n                  h4(\"Cumulative Precipitation Measurements\"),\n                  plotlyOutput(\"precip_plot\", height = \"250px\")\n                )\n              )\n            )\n          )\n        )\n      )\n    ) # End of conditional panel for tab content\n  ),\n\n  # Footer with Back to Top\n  tags$footer(id = \"footer\",\n    div(id = \"footerWrapper\",\n      div(id = \"footerAdminSection\",\n        div(class = \"container\",\n          div(id = \"footerAdminLinks\",\n            tags$ul(class = \"inline\",\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/gov/content/home\", \"Home\", target = \"_blank\")),\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/gov/content/home/disclaimer\", \"Disclaimer\", target = \"_blank\")),\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/gov/content/home/privacy\", \"Privacy\", target = \"_blank\")),\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/gov/content/home/accessibility\", \"Accessibility\", target = \"_blank\")),\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/gov/content/home/copyright\", \"Copyright\", target = \"_blank\")),\n              tags$li(tags$a(href = \"https://www2.gov.bc.ca/StaticWebResources/static/gov3/html/contact-us.html\", \"Contact\", target = \"_blank\"))\n            )\n          )\n        )\n      )\n    ),\n    tags$img(src = \"www/back-to-top.png\", class = \"back-to-top\", onclick = \"window.scrollTo({top: 0, behavior: 'smooth'});\")\n  ),\n  \n  # JavaScript for back-to-top functionality\n  tags$script(HTML(\"\n    $(document).ready(function() {\n      $(window).scroll(function() {\n        if ($(this).scrollTop() > 100) {\n          $('.back-to-top').fadeIn();\n        } else {\n          $('.back-to-top').fadeOut();\n        }\n      });\n\n      // Check initial scroll position\n      if ($(window).scrollTop() > 100) {\n        $('.back-to-top').show();\n      }\n    });\n  \"))\n) # End fluidPage","type":"text"},{"name":"www/back-to-top.png","content":"iVBORw0KGgoAAAANSUhEUgAAADUAAAA0CAYAAAAqunDVAAAACXBIWXMAAAsTAAALEwEAmpwY\nAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUI\nIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuj\na9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMB\nAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCd\nmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgw\nABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88Suu\nEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHg\ng/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgug\ndfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7i\nJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKS\nKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8/\n/UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBC\nCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHa\niAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyG\nvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPE\nbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKgg\nHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmx\npFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+Io\nUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgX\naPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1Qw\nNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnU\nlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1\ngTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIp\nG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acK\npxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsM\nzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZL\nTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnu\ntrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFn\nYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPj\nthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/u\nNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh\n7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7\n+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGL\nw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8Yu\nZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhO\nOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCep\nkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQ\nrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0d\nWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWF\nfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebe\nLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ2\n7tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHt\nxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTra\ndox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLT\nk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86\nX23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/Xf\nFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9D\nBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl\n/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz\n/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAvZJ\nREFUeNrsmV1vE0cUhp8zM1GVGq9DCkFBohIXTSsT5MQORSmI/14JlCrgCEgc1xiFqEYgAsRx\npKxjZ2emF2BUKtqi7q6N0Zzrs6N59rxzPmbEe8+vdzf9mzddvPdMq4kIFy/Mc+f2DZHfNh++\n6Dx/uei9R0SmFsp7EIHvr1zuqM7zl4sj0mm20fb/6Ly4ovgKLUAFqAAVoAJUgApQASq9mbQL\nOOewzpG2c/SAIGitSduGmrQbOX++xFwpSj22iAjD4ZBXB29xzkKK3/S/obz3zMzM8MvNKoXC\nbGbS2bz/iL39DsaYCURKBGsT9vY7LFycx6WMlBJhMBjSPeqhlJqM/OT9YLbbbLPbzGjQA7RS\nk4Mamdb6M5KJx3v3Wb5TkdKttczOfsP8/BzOubHcg5g8F0+spRQVWb+5yrnCtzzeadFq72GM\nQaYRKrGWuajIrfUaxWIBgNWVMiLQevIMY/R0yS9JEkrFj4FGyWW1Uuanpaskic1NiioPoCgq\ncmu9SrFYoHt0zEl8iveeg9dvAViplFnKEUxlnRRKUcTt9RpRdI7Dbo97G3UGgwEiwm7zKY+2\nfwegWinz49JVrLVf7pmyzlH6yxk67Pa4u1GnH/c/1B1Rwnajhdaa5fIPVFeuISK0n+6nrk2Z\nR8p7z4wx/Hyj8k5yvWPubWwRn/Q/qk2CoJVmZ/cJjWb7XfKolLm0cCHTiGUWKRGI4z5JknC/\nvk0cx+hPZDgRQSvFTqMNHhYXF0iSJFUDmwuUiJAkls0Hj/HeY61Fa43/F3+loNFs02o/e++v\nvsRIyQcJ/dP58H/zH32T9T1+psX3Pzf3ifSdx8PEWMb5cb+nhIuXtLIc1xuYylt2znmOescM\nBkNO4j5K5Q9mcv9rSth62MAYw+npINPOYWJQAGdnCcPh2ViAxgY1qkkh+wWoABWgAlSAClAB\nasqgnHNfBcyIQ9Wqy4dKKaydbjBrHUop1mrXD1R9a+e7tepyJ8vbnEmY1oq12vXOg/r2pT8H\nAIOKK/c2ztg3AAAAAElFTkSuQmCC","type":"binary"},{"name":"www/gov3_bc_logo.png","content":"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\nQmCC","type":"binary"},{"name":"www/styles.css","content":"@font-face {\n  font-family: \"Myriad Pro\";\n}\n\nhtml {\n  position: relative;\n  min-height: 100%;\n}\n\nbody {\n  margin-top: 60px;\n  margin-bottom: 100px;\n  font-family: \"Myriad Pro\", Calibri, Arial, \"sans serif\";\n  color: #494949;\n  overflow-x: hidden;\n  width: 100%;\n}\n\n.container-fluid {\n  padding-right: 15px;\n  padding-left: 15px;\n  margin-right: auto;\n  margin-left: auto;\n  width: 100%;\n  max-width: 100%;\n}\n\n.navbar {\n  position: fixed;\n  top: 0;\n  width: 100%;\n}\n\n.navbar-default {\n  background-color: #036;\n  border-bottom: 2px solid #fcba19;\n  color: #fff;\n}\n\n.navbar-default .navbar-nav>li>a {\n  color: #fff;\n}\n\n.navbar-nav>li>a {\n  font-size: 13px;\n}\n\n.navbar-default .navbar-nav>li>a:focus, \n.navbar-default .navbar-nav>li>a:hover {\n  color: #f0f0f0;\n  text-decoration: underline;\n}\n\n.nav-logo {\n  height: 40px;\n  margin: 5px 10px 5px 0;\n  float: left;\n}\n\n.header-container {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0.75rem 0 0.75rem 1.5rem;\n  background-color: #ffffff;\n  border-bottom: 1px solid #e1e4e8;\n  margin-bottom: 1rem;\n  height: 60px;\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n  gap: 2rem;\n  height: 100%;\n  overflow: hidden;\n}\n\n.navbar-title {\n  float: left;\n  height: 50px;\n  padding: 15px;\n  font-size: 24px;\n  line-height: 20px;\n  color: #ffffff;\n  font-weight: bold;\n  pointer-events: none;\n  user-select: none;\n}\n\n.fetch-controls-dropdown {\n  position: relative;\n  display: inline-block;\n}\n\n.fetch-controls-content {\n  display: none;\n  position: absolute;\n  right: 0;\n  background-color: #ffffff;\n  min-width: 300px;\n  box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n  border: 1px solid #e1e4e8;\n  border-radius: 4px;\n  padding: 1rem;\n  z-index: 1000;\n}\n\n.fetch-controls-dropdown.active .fetch-controls-content {\n  display: block;\n}\n\n.fetch-controls-content:hover,\n.fetch-controls-content:focus-within {\n  display: block;\n}\n\n.btn-primary {\n  background-color: #003366;\n  border: none;\n  color: #ffffff;\n  padding: 0.5rem 1rem;\n  font-weight: 600;\n  border-radius: 4px;\n}\n\n#fetch_controls_btn.btn-primary {\n  background-color: #003366;\n  border: 2px solid #fcba19;\n  color: #ffffff;\n  padding: 0.75rem 1.5rem;\n  font-weight: 700;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  transition: all 0.2s ease-in-out;\n}\n\n#fetch_controls_btn.btn-primary:hover {\n  background-color: #38598a;\n  border-color: #fdd667;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n}\n\n.btn-primary:hover {\n  background-color: #38598a;\n  border-color: #fdd667;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n}\n\n.card {\n  background-color: #ffffff;\n  border: 1px solid #e1e4e8;\n  border-radius: 4px;\n  margin-bottom: 1rem;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\n}\n\n.output-card {\n  padding: 1rem;\n  background-color: #ffffff;\n  border: 1px solid #e1e4e8;\n  border-radius: 4px;\n  margin-bottom: 1rem;\n}\n\n.scrollable-output {\n  max-height: clamp(200px, 40vh, 500px);\n  min-height: 100px;\n  overflow-y: auto;\n  background-color: #f8f9fc;\n  border: 1px solid #e1e4e8;\n  padding: .75rem;\n  font-family: \"Consolas\", monospace;\n}\n\n.nav-pills .nav-link {\n  color: #494949;\n  border-radius: 4px;\n}\n\n.nav-pills .nav-link.active {\n  background-color: #38598a;\n  color: #ffffff;\n}\n\n/* Progress bar styling */\n.shiny-progress-container {\n  margin-bottom: 60px !important;\n}\n\n/* BCGOV Footer Guidelines */\n#footer #footerWrapper {\n  width: 100%;\n  bottom: 0;\n}\n\n#footer {\n  background-color: #003366;\n  border-top: 2px solid #fcba19;\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n  height: 50px;\n}\n\n#footerAdminSection {\n  background-color: #003366;\n}\n\n#footerAdminLinks {\n  clear: both;\n}\n\n#footerAdminSection ul {\n  clear: both;\n  padding: 10px 0;\n}\n\nul.inline {\n  list-style-type: none;\n  margin: 0;\n  overflow: hidden;\n  padding: 0;\n  text-align: center;\n}\n\nul.inline li {\n  display: inline-block;\n  padding: 2px 10px;\n  position: relative;\n}\n\nimg.back-to-top.footer-overlap {\n  position: absolute;\n  top: -63px;\n}\n\nimg.back-to-top {\n  position: fixed;\n  right: 10px;\n  bottom: 10px;\n  opacity: 0.75;\n  filter: alpha(opacity=75);\n  z-index: 1100;\n  cursor: pointer;\n  display: none;\n  vertical-align: middle;\n  border: 0;\n}\n\n#footer a, #footer h2 {\n  color: #fff;\n}\n\na {\n  color: #1a5a96;\n}\n\nul.inline li a:link, nav ul.inline li a:visited {\n  color: white;\n  display: block;\n  text-align: center;\n}\n","type":"text"}]
